import express, { Express, Request, Response, NextFunction } from "express";
import { createServer, type Server } from "http";
// Use database storage
import { storage } from "./database-storage";
import { githubService } from "./github";
import { omdbService } from "./omdb";
import { youtubeService, extractYouTubeReleaseYear, getCleanDescription } from "./youtube";
import { searchService } from "./services/searchService";
import { ZodError } from "zod";
import { insertTvShowReviewSchema, insertFavoriteSchema, TvShowGitHub } from "@shared/schema";
import fs from 'fs';
import { parse } from 'csv-parse/sync';
import { setupAuth } from "./auth";
// Use the new consolidated utility files
import * as imageOptimizer from "../image-optimizer.js";
import * as imageManager from "../image-manager.js";
import * as dataManager from "../data-manager.js";
import * as apiDataUpdater from "../api-data-updater.js";
import { upload, optimizeImage, uploadErrorHandler } from "./image-upload";
import { lookupRouter } from "./lookup-api";
import path from "path";
import { pool } from "./db";

export async function registerRoutes(app: Express): Promise<Server> {
  // Add health check endpoint
  app.get('/api/health', (_req, res) => {
    res.status(200).send('OK');
  });

  // Set up authentication
  setupAuth(app);
  
  // Auth routes - using original custom authentication system
  app.get('/api/auth/user', (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Not authenticated" });
    }
    
    res.json(req.user);
  });
  
  // Use lookup router
  app.use('/api/lookup', lookupRouter);

  // TV show routes
  app.get("/api/tv-shows", async (req: Request, res: Response) => {
    try {
      const { 
        search, 
        age, 
        themes, 
        stimulation, 
        sort, 
        limit: limitStr, 
        offset: offsetStr,
        isYoutube
      } = req.query;
      
      // Convert limit and offset to numbers with defaults
      const limit = limitStr ? parseInt(limitStr as string) : 20;
      const offset = offsetStr ? parseInt(offsetStr as string) : 0;
      
      // Get user ID if logged in
      const userId = req.session?.userId;
      const parsedUserId = userId ? parseInt(userId) : null;
      
      const tvShows = await storage.getTvShows({
        search: search as string,
        ageRange: age as string,
        themes: themes as string,
        stimulationScore: stimulation as string,
        sortBy: sort as string,
        limit,
        offset,
        isYoutube: isYoutube === 'true',
        userId: parsedUserId
      });
      
      res.json(tvShows);
    } catch (error) {
      console.error("Error fetching TV shows:", error);
      res.status(500).json({ message: "Failed to fetch TV shows" });
    }
  });
  
  // Get popular TV shows
  app.get("/api/shows/popular", async (req, res) => {
    try {
      const limit = req.query.limit ? parseInt(req.query.limit as string) : 5;
      const popularShows = await storage.getPopularTvShows(limit);
      res.json(popularShows);
    } catch (error) {
      console.error("Error fetching popular shows:", error);
      res.status(500).json({ message: "Failed to fetch popular shows" });
    }
  });
  
  // Get a single TV show
  app.get("/api/shows/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const userId = req.session?.userId;
      
      // Convert userId to number for database operations
      const parsedUserId = userId ? parseInt(userId) : null;
      
      const tvShow = await storage.getTvShowById(id, parsedUserId);
      
      if (!tvShow) {
        return res.status(404).json({ message: "TV show not found" });
      }
      
      res.json(tvShow);
    } catch (error) {
      console.error("Error fetching TV show:", error);
      res.status(500).json({ message: "Failed to fetch TV show" });
    }
  });
  
  // User dashboard
  app.get("/api/user/dashboard", async (req, res) => {
    try {
      const userId = req.session?.userId;
      if (!userId) {
        return res.status(401).json({ message: "You must be logged in to view your dashboard" });
      }
      
      // Convert userId to integer since database expects integer
      const parsedUserId = parseInt(userId);
      
      // Get user profile
      const user = await storage.getUserById(parsedUserId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Get user reviews
      let reviews = [];
      try {
        reviews = await storage.getReviewsByUserId(parsedUserId);
      } catch (error) {
        console.error('Error getting user reviews:', error);
      }
      
      // Get user favorites
      let favorites = [];
      try {
        favorites = await storage.getUserFavorites(parsedUserId);
      } catch (error) {
        console.error('Error getting user favorites:', error);
      }
      
      // Default point breakdown structure
      const defaultPointsBreakdown = {
        reviews: 0,
        upvotesGiven: 0,
        upvotesReceived: 0,
        consecutiveLogins: 0,
        shares: 0,
        referrals: 0,
        showSubmissions: 0,
        researchRead: 0
      };
      
      // Get user's gamification data
      let pointsInfo = { 
        total: 0, 
        breakdown: {
          ...defaultPointsBreakdown
        }, 
        rank: 'TV Watcher' 
      };
      
      try {
        if (typeof storage.getUserPoints === 'function') {
          const dbPoints = await storage.getUserPoints(parsedUserId);
          if (dbPoints) {
            pointsInfo = dbPoints;
          }
        }
        
        // Always calculate points based on user activities in case db doesn't have updated information
        // Each review is worth 5 points (this value should match the points in INSERT statements)
        const reviewPoints = reviews.length * 5;
        
        // Get upvotes received count
        const upvotesReceivedQuery = await pool.query(
          `SELECT COUNT(*) as count FROM review_upvotes 
           JOIN tv_show_reviews ON review_upvotes.review_id = tv_show_reviews.id 
           WHERE tv_show_reviews.user_id = $1`,
          [parsedUserId]
        );
        
        // Calculate upvotes received points (2 points per upvote)
        const upvotesCount = parseInt(upvotesReceivedQuery.rows[0]?.count || '0');
        const upvotesPoints = upvotesCount * 2;
        
        // Update the breakdown
        pointsInfo.breakdown.reviews = reviewPoints;
        pointsInfo.breakdown.upvotesReceived = upvotesPoints;
        
        // Recalculate total points
        pointsInfo.total = reviewPoints + 
                          (pointsInfo.breakdown.upvotesGiven || 0) + 
                          (pointsInfo.breakdown.upvotesReceived || 0) + 
                          (pointsInfo.breakdown.consecutiveLogins || 0) +
                          (pointsInfo.breakdown.shares || 0) + 
                          (pointsInfo.breakdown.referrals || 0) +
                          (pointsInfo.breakdown.showSubmissions || 0) + 
                          (pointsInfo.breakdown.researchRead || 0);
        
        // Determine rank based on total points
        if (pointsInfo.total >= 100) pointsInfo.rank = 'TV Enthusiast';
        if (pointsInfo.total >= 500) pointsInfo.rank = 'TV Expert';
        if (pointsInfo.total >= 1000) pointsInfo.rank = 'TV Master';
        
        // Ensure we have review points history records for each review
        try {
          // Let's directly create point history records for all reviews
          for (const review of reviews) {
            console.log(`Processing review points for review ID ${review.id}`);
            
            try {
              // First check if we already have a record for this review
              const existingRecords = await pool.query(
                `SELECT id FROM user_points_history 
                 WHERE user_id = $1 
                 AND activity_type = 'review' 
                 AND description LIKE $2`,
                [parsedUserId, `%${review.showName}%`]
              );
              
              // Only add if no record exists
              if (existingRecords.rowCount === 0) {
                // Add points directly using pool query for better compatibility
                await pool.query(
                  `INSERT INTO user_points_history (user_id, points, activity_type, description)
                   VALUES ($1, $2, $3, $4)`,
                  [parsedUserId, 5, 'review', `Review of ${review.showName}`]
                );
                
                console.log(`Successfully added points for review of ${review.showName}`);
              } else {
                console.log(`Points already recorded for review of ${review.showName}`);
              }
            } catch (reviewPointsError) {
              console.error(`Error recording points for review ${review.id}:`, reviewPointsError);
            }
          }
          
          // Force recalculation of points from the history records
          const pointsRecords = await pool.query(
            `SELECT SUM(points) as total FROM user_points_history WHERE user_id = $1 AND activity_type = 'review'`,
            [parsedUserId]
          );
          
          if (pointsRecords.rows.length > 0) {
            pointsInfo.breakdown.reviews = parseInt(pointsRecords.rows[0].total || '0');
            console.log(`Updated review points from history: ${pointsInfo.breakdown.reviews}`);
            
            // Recalculate total again with the fresh data
            pointsInfo.total = pointsInfo.breakdown.reviews + 
                          (pointsInfo.breakdown.upvotesGiven || 0) + 
                          (pointsInfo.breakdown.upvotesReceived || 0) + 
                          (pointsInfo.breakdown.consecutiveLogins || 0) +
                          (pointsInfo.breakdown.shares || 0) + 
                          (pointsInfo.breakdown.referrals || 0) +
                          (pointsInfo.breakdown.showSubmissions || 0) + 
                          (pointsInfo.breakdown.researchRead || 0);
          }
        } catch (error) {
          console.error('Error recording review points history:', error);
        }
        
        console.log(`Calculated points for user ${userId}: Total=${pointsInfo.total}, Reviews=${reviewPoints}`);
      } catch (error) {
        console.error('Error getting user points:', error);
      }
      
      // Get user points history
      let pointsHistory = [];
      try {
        if (typeof storage.getUserPointsHistory === 'function') {
          pointsHistory = await storage.getUserPointsHistory(parsedUserId) || [];
        }
      } catch (error) {
        console.error('Error getting user points history:', error);
      }
      
      // Get similar shows based on user preferences
      let recommendedShows = [];
      try {
        recommendedShows = await storage.getSimilarShows(parsedUserId, 5) || [];
      } catch (error) {
        console.error('Error getting recommended shows:', error);
      }
      
      // Get user login streak
      let streak = 0;
      try {
        if (typeof storage.getUserLoginStreak === 'function') {
          streak = await storage.getUserLoginStreak(parsedUserId) || 0;
        } else {
          // Use the existing login streak functionality
          streak = await storage.updateUserLoginStreak(parsedUserId.toString());
        }
      } catch (error) {
        console.error('Error getting user login streak:', error);
      }
      
      // Get user's read research
      let readResearch = [];
      try {
        readResearch = await storage.getUserReadResearch(parsedUserId) || [];
      } catch (error) {
        console.error('Error getting user read research:', error);
      }
      
      // Get top users (leaderboard)
      let topUsers = [];
      try {
        topUsers = await storage.getTopUsers(5) || [];
      } catch (error) {
        console.error('Error getting top users:', error);
      }
      
      // Get user's show submissions
      let submissions = [];
      try {
        submissions = await storage.getUserShowSubmissions(parsedUserId) || [];
      } catch (error) {
        console.error('Error getting user show submissions:', error);
      }
      
      res.json({
        user,
        points: pointsInfo.total,
        pointsBreakdown: pointsInfo.breakdown,
        rank: pointsInfo.rank,
        reviews,
        favorites,
        pointsHistory,
        streak,
        submissions,
        recommendedShows,
        readResearch,
        topUsers
      });
    } catch (error) {
      console.error("Error fetching user dashboard:", error);
      res.status(500).json({ message: "Failed to fetch user dashboard data" });
    }
  });

  /* Rest of the routes go here - omitted for brevity */

  const httpServer = createServer(app);
  return httpServer;
}