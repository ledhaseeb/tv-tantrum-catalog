This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: package.json, tsconfig.json, vite.config.ts, tailwind.config.ts, drizzle.config.ts, shared/**/*.ts, server/**/*.ts, client/src/**/*.ts, client/src/**/*.tsx, client/index.html, *.md, *.js, *.mjs
- Files matching these patterns are excluded: attached_assets/**, node_modules/**, dist/**, build/**, .git/**, .local/**, postgres/**, migrations/**, backup/**, temp_*/**, tmp_*/**, *.png, *.jpg, *.jpeg, *.gif, *.zip, *.avif, *.webp, *.bin, *.log, public/custom-images/**, public/media/**, public/uploads/**, extracted_research/**, data/**, *.csv
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
client/
  src/
    components/
      ui/
        accordion.tsx
        alert-dialog.tsx
        alert.tsx
        aspect-ratio.tsx
        avatar.tsx
        badge.tsx
        breadcrumb.tsx
        button.tsx
        calendar.tsx
        card.tsx
        carousel.tsx
        chart.tsx
        checkbox.tsx
        collapsible.tsx
        command.tsx
        context-menu.tsx
        dialog.tsx
        drawer.tsx
        dropdown-menu.tsx
        form.tsx
        hover-card.tsx
        input-otp.tsx
        input.tsx
        label.tsx
        menubar.tsx
        navigation-menu.tsx
        pagination.tsx
        popover.tsx
        progress.tsx
        radio-group.tsx
        resizable.tsx
        scroll-area.tsx
        select.tsx
        separator.tsx
        sheet.tsx
        sidebar.tsx
        skeleton.tsx
        slider.tsx
        switch.tsx
        table.tsx
        tabs.tsx
        textarea.tsx
        toast.tsx
        toaster.tsx
        toggle-group.tsx
        toggle.tsx
        tooltip.tsx
      AdContainer.tsx
      ChangePasswordForm.tsx
      ColorPaletteCustomizer.tsx
      CookieConsent.tsx
      FavoriteRegistrationModal.tsx
      FileUploader.tsx
      Footer.tsx
      GhlScriptLoader.tsx
      GoogleAd.tsx
      image-upload.tsx
      Leaderboard.tsx
      LoginForm.tsx
      Navbar.tsx
      RatingBar.tsx
      RegistrationForm.tsx
      ShareModal.tsx
      ShowCard.tsx
      ShowFilters.tsx
      ShowSubmissionForm.tsx
      SimpleShowCard.tsx
      ThemeSelector.tsx
    hooks/
      use-analytics.tsx
      use-auth.tsx
      use-mobile.tsx
      use-toast.ts
      useAuth.ts
    lib/
      adsense.ts
      analytics.ts
      badges.ts
      protected-route-admin.tsx
      protected-route-approved.tsx
      protected-route.tsx
      queryClient.ts
      showUtils.ts
      utils.ts
    pages/
      about.tsx
      admin-page.tsx
      admin-research-links.tsx
      admin-research-manager.tsx
      auth-page-new.tsx
      auth-page.tsx
      browse.tsx
      compare.tsx
      complete-registration.tsx
      detail.tsx
      early-access.tsx
      home.tsx
      landing-page.tsx
      not-found.tsx
      pre-launch-about.tsx
      pre-launch-faq.tsx
      privacy-policy.tsx
      registration-pending.tsx
      research-detail.tsx
      research-link-updater.tsx
      research-view.tsx
      research.tsx
      share.tsx
      show-submission.tsx
      submit-show.tsx
      terms-of-service.tsx
      token-entry.tsx
      user-dashboard.tsx
      user-profile.tsx
    App.tsx
    main.tsx
  index.html
server/
  services/
    searchService.ts
  admin-functions.ts
  auth.ts
  database-favorites.ts
  database-storage.ts
  db.ts
  details-preservator.ts
  direct-upload.ts
  directSearch.ts
  github.ts
  image-optimizer.ts
  image-preservator.ts
  image-upload.ts
  index.ts
  lookup-api.ts
  omdb.ts
  referral-system.ts
  replitAuth.ts
  research-api.ts
  routes.ts
  simple-upload.ts
  storage.ts
  upload-routes.ts
  url-shortener.ts
  vite.ts
  youtube.ts
shared/
  schema.ts
  updated-schema.ts
api-data-updater.js
apply-custom-data.js
apply-custom-data.mjs
apply-migrations.js
apply-migrations.mjs
check-image-orientation.js
check-images.js
COMPLETE_CODEBASE_MERGED.md
convert-avif.js
CURRENT_WORKING_STATE.md
CUSTOM_DATA.md
data-manager.js
drizzle.config.ts
extract-skool-research.js
image-manager.js
image-optimizer.js
import-custom-images.js
manual-research-import.js
optimize-images.mjs
optimize-seo-images.mjs
package.json
postcss.config.js
refresh-data.js
restore-custom-images.mjs
skool-extractor.js
sync-themes.js
tailwind.config.ts
test-webhook.js
test-youtube-integration.js
tsconfig.json
TV_TANTRUM_ARCHITECTURE_REPORT.md
update-all-image-paths.js
update-youtube-shows.mjs
UTILITIES.md
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="client/src/components/ui/accordion.tsx">
import * as React from "react"
import * as AccordionPrimitive from "@radix-ui/react-accordion"
import { ChevronDown } from "lucide-react"

import { cn } from "@/lib/utils"

const Accordion = AccordionPrimitive.Root

const AccordionItem = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>
>(({ className, ...props }, ref) => (
  <AccordionPrimitive.Item
    ref={ref}
    className={cn("border-b", className)}
    {...props}
  />
))
AccordionItem.displayName = "AccordionItem"

const AccordionTrigger = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Header className="flex">
    <AccordionPrimitive.Trigger
      ref={ref}
      className={cn(
        "flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180",
        className
      )}
      {...props}
    >
      {children}
      <ChevronDown className="h-4 w-4 shrink-0 transition-transform duration-200" />
    </AccordionPrimitive.Trigger>
  </AccordionPrimitive.Header>
))
AccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName

const AccordionContent = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Content
    ref={ref}
    className="overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down"
    {...props}
  >
    <div className={cn("pb-4 pt-0", className)}>{children}</div>
  </AccordionPrimitive.Content>
))

AccordionContent.displayName = AccordionPrimitive.Content.displayName

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }
</file>

<file path="client/src/components/ui/alert-dialog.tsx">
import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

const AlertDialog = AlertDialogPrimitive.Root

const AlertDialogTrigger = AlertDialogPrimitive.Trigger

const AlertDialogPortal = AlertDialogPrimitive.Portal

const AlertDialogOverlay = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
AlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName

const AlertDialogContent = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>
>(({ className, ...props }, ref) => (
  <AlertDialogPortal>
    <AlertDialogOverlay />
    <AlertDialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    />
  </AlertDialogPortal>
))
AlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName

const AlertDialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
AlertDialogHeader.displayName = "AlertDialogHeader"

const AlertDialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
AlertDialogFooter.displayName = "AlertDialogFooter"

const AlertDialogTitle = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold", className)}
    {...props}
  />
))
AlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName

const AlertDialogDescription = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
AlertDialogDescription.displayName =
  AlertDialogPrimitive.Description.displayName

const AlertDialogAction = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Action>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Action
    ref={ref}
    className={cn(buttonVariants(), className)}
    {...props}
  />
))
AlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName

const AlertDialogCancel = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Cancel
    ref={ref}
    className={cn(
      buttonVariants({ variant: "outline" }),
      "mt-2 sm:mt-0",
      className
    )}
    {...props}
  />
))
AlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}
</file>

<file path="client/src/components/ui/alert.tsx">
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
))
Alert.displayName = "Alert"

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
))
AlertTitle.displayName = "AlertTitle"

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
))
AlertDescription.displayName = "AlertDescription"

export { Alert, AlertTitle, AlertDescription }
</file>

<file path="client/src/components/ui/aspect-ratio.tsx">
import * as AspectRatioPrimitive from "@radix-ui/react-aspect-ratio"

const AspectRatio = AspectRatioPrimitive.Root

export { AspectRatio }
</file>

<file path="client/src/components/ui/avatar.tsx">
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
      className
    )}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      className
    )}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }
</file>

<file path="client/src/components/ui/badge.tsx">
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }
</file>

<file path="client/src/components/ui/breadcrumb.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { ChevronRight, MoreHorizontal } from "lucide-react"

import { cn } from "@/lib/utils"

const Breadcrumb = React.forwardRef<
  HTMLElement,
  React.ComponentPropsWithoutRef<"nav"> & {
    separator?: React.ReactNode
  }
>(({ ...props }, ref) => <nav ref={ref} aria-label="breadcrumb" {...props} />)
Breadcrumb.displayName = "Breadcrumb"

const BreadcrumbList = React.forwardRef<
  HTMLOListElement,
  React.ComponentPropsWithoutRef<"ol">
>(({ className, ...props }, ref) => (
  <ol
    ref={ref}
    className={cn(
      "flex flex-wrap items-center gap-1.5 break-words text-sm text-muted-foreground sm:gap-2.5",
      className
    )}
    {...props}
  />
))
BreadcrumbList.displayName = "BreadcrumbList"

const BreadcrumbItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentPropsWithoutRef<"li">
>(({ className, ...props }, ref) => (
  <li
    ref={ref}
    className={cn("inline-flex items-center gap-1.5", className)}
    {...props}
  />
))
BreadcrumbItem.displayName = "BreadcrumbItem"

const BreadcrumbLink = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentPropsWithoutRef<"a"> & {
    asChild?: boolean
  }
>(({ asChild, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      ref={ref}
      className={cn("transition-colors hover:text-foreground", className)}
      {...props}
    />
  )
})
BreadcrumbLink.displayName = "BreadcrumbLink"

const BreadcrumbPage = React.forwardRef<
  HTMLSpanElement,
  React.ComponentPropsWithoutRef<"span">
>(({ className, ...props }, ref) => (
  <span
    ref={ref}
    role="link"
    aria-disabled="true"
    aria-current="page"
    className={cn("font-normal text-foreground", className)}
    {...props}
  />
))
BreadcrumbPage.displayName = "BreadcrumbPage"

const BreadcrumbSeparator = ({
  children,
  className,
  ...props
}: React.ComponentProps<"li">) => (
  <li
    role="presentation"
    aria-hidden="true"
    className={cn("[&>svg]:w-3.5 [&>svg]:h-3.5", className)}
    {...props}
  >
    {children ?? <ChevronRight />}
  </li>
)
BreadcrumbSeparator.displayName = "BreadcrumbSeparator"

const BreadcrumbEllipsis = ({
  className,
  ...props
}: React.ComponentProps<"span">) => (
  <span
    role="presentation"
    aria-hidden="true"
    className={cn("flex h-9 w-9 items-center justify-center", className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More</span>
  </span>
)
BreadcrumbEllipsis.displayName = "BreadcrumbElipssis"

export {
  Breadcrumb,
  BreadcrumbList,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbPage,
  BreadcrumbSeparator,
  BreadcrumbEllipsis,
}
</file>

<file path="client/src/components/ui/button.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-bold ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }
</file>

<file path="client/src/components/ui/calendar.tsx">
import * as React from "react"
import { ChevronLeft, ChevronRight } from "lucide-react"
import { DayPicker } from "react-day-picker"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

export type CalendarProps = React.ComponentProps<typeof DayPicker>

function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  ...props
}: CalendarProps) {
  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn("p-3", className)}
      classNames={{
        months: "flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0",
        month: "space-y-4",
        caption: "flex justify-center pt-1 relative items-center",
        caption_label: "text-sm font-medium",
        nav: "space-x-1 flex items-center",
        nav_button: cn(
          buttonVariants({ variant: "outline" }),
          "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100"
        ),
        nav_button_previous: "absolute left-1",
        nav_button_next: "absolute right-1",
        table: "w-full border-collapse space-y-1",
        head_row: "flex",
        head_cell:
          "text-muted-foreground rounded-md w-9 font-normal text-[0.8rem]",
        row: "flex w-full mt-2",
        cell: "h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected].day-range-end)]:rounded-r-md [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md focus-within:relative focus-within:z-20",
        day: cn(
          buttonVariants({ variant: "ghost" }),
          "h-9 w-9 p-0 font-normal aria-selected:opacity-100"
        ),
        day_range_end: "day-range-end",
        day_selected:
          "bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground",
        day_today: "bg-accent text-accent-foreground",
        day_outside:
          "day-outside text-muted-foreground aria-selected:bg-accent/50 aria-selected:text-muted-foreground",
        day_disabled: "text-muted-foreground opacity-50",
        day_range_middle:
          "aria-selected:bg-accent aria-selected:text-accent-foreground",
        day_hidden: "invisible",
        ...classNames,
      }}
      components={{
        IconLeft: ({ className, ...props }) => (
          <ChevronLeft className={cn("h-4 w-4", className)} {...props} />
        ),
        IconRight: ({ className, ...props }) => (
          <ChevronRight className={cn("h-4 w-4", className)} {...props} />
        ),
      }}
      {...props}
    />
  )
}
Calendar.displayName = "Calendar"

export { Calendar }
</file>

<file path="client/src/components/ui/card.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }
</file>

<file path="client/src/components/ui/carousel.tsx">
import * as React from "react"
import useEmblaCarousel, {
  type UseEmblaCarouselType,
} from "embla-carousel-react"
import { ArrowLeft, ArrowRight } from "lucide-react"

import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"

type CarouselApi = UseEmblaCarouselType[1]
type UseCarouselParameters = Parameters<typeof useEmblaCarousel>
type CarouselOptions = UseCarouselParameters[0]
type CarouselPlugin = UseCarouselParameters[1]

type CarouselProps = {
  opts?: CarouselOptions
  plugins?: CarouselPlugin
  orientation?: "horizontal" | "vertical"
  setApi?: (api: CarouselApi) => void
}

type CarouselContextProps = {
  carouselRef: ReturnType<typeof useEmblaCarousel>[0]
  api: ReturnType<typeof useEmblaCarousel>[1]
  scrollPrev: () => void
  scrollNext: () => void
  canScrollPrev: boolean
  canScrollNext: boolean
} & CarouselProps

const CarouselContext = React.createContext<CarouselContextProps | null>(null)

function useCarousel() {
  const context = React.useContext(CarouselContext)

  if (!context) {
    throw new Error("useCarousel must be used within a <Carousel />")
  }

  return context
}

const Carousel = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & CarouselProps
>(
  (
    {
      orientation = "horizontal",
      opts,
      setApi,
      plugins,
      className,
      children,
      ...props
    },
    ref
  ) => {
    const [carouselRef, api] = useEmblaCarousel(
      {
        ...opts,
        axis: orientation === "horizontal" ? "x" : "y",
      },
      plugins
    )
    const [canScrollPrev, setCanScrollPrev] = React.useState(false)
    const [canScrollNext, setCanScrollNext] = React.useState(false)

    const onSelect = React.useCallback((api: CarouselApi) => {
      if (!api) {
        return
      }

      setCanScrollPrev(api.canScrollPrev())
      setCanScrollNext(api.canScrollNext())
    }, [])

    const scrollPrev = React.useCallback(() => {
      api?.scrollPrev()
    }, [api])

    const scrollNext = React.useCallback(() => {
      api?.scrollNext()
    }, [api])

    const handleKeyDown = React.useCallback(
      (event: React.KeyboardEvent<HTMLDivElement>) => {
        if (event.key === "ArrowLeft") {
          event.preventDefault()
          scrollPrev()
        } else if (event.key === "ArrowRight") {
          event.preventDefault()
          scrollNext()
        }
      },
      [scrollPrev, scrollNext]
    )

    React.useEffect(() => {
      if (!api || !setApi) {
        return
      }

      setApi(api)
    }, [api, setApi])

    React.useEffect(() => {
      if (!api) {
        return
      }

      onSelect(api)
      api.on("reInit", onSelect)
      api.on("select", onSelect)

      return () => {
        api?.off("select", onSelect)
      }
    }, [api, onSelect])

    return (
      <CarouselContext.Provider
        value={{
          carouselRef,
          api: api,
          opts,
          orientation:
            orientation || (opts?.axis === "y" ? "vertical" : "horizontal"),
          scrollPrev,
          scrollNext,
          canScrollPrev,
          canScrollNext,
        }}
      >
        <div
          ref={ref}
          onKeyDownCapture={handleKeyDown}
          className={cn("relative", className)}
          role="region"
          aria-roledescription="carousel"
          {...props}
        >
          {children}
        </div>
      </CarouselContext.Provider>
    )
  }
)
Carousel.displayName = "Carousel"

const CarouselContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { carouselRef, orientation } = useCarousel()

  return (
    <div ref={carouselRef} className="overflow-hidden">
      <div
        ref={ref}
        className={cn(
          "flex",
          orientation === "horizontal" ? "-ml-4" : "-mt-4 flex-col",
          className
        )}
        {...props}
      />
    </div>
  )
})
CarouselContent.displayName = "CarouselContent"

const CarouselItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { orientation } = useCarousel()

  return (
    <div
      ref={ref}
      role="group"
      aria-roledescription="slide"
      className={cn(
        "min-w-0 shrink-0 grow-0 basis-full",
        orientation === "horizontal" ? "pl-4" : "pt-4",
        className
      )}
      {...props}
    />
  )
})
CarouselItem.displayName = "CarouselItem"

const CarouselPrevious = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({ className, variant = "outline", size = "icon", ...props }, ref) => {
  const { orientation, scrollPrev, canScrollPrev } = useCarousel()

  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        "absolute  h-8 w-8 rounded-full",
        orientation === "horizontal"
          ? "-left-12 top-1/2 -translate-y-1/2"
          : "-top-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      )}
      disabled={!canScrollPrev}
      onClick={scrollPrev}
      {...props}
    >
      <ArrowLeft className="h-4 w-4" />
      <span className="sr-only">Previous slide</span>
    </Button>
  )
})
CarouselPrevious.displayName = "CarouselPrevious"

const CarouselNext = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({ className, variant = "outline", size = "icon", ...props }, ref) => {
  const { orientation, scrollNext, canScrollNext } = useCarousel()

  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        "absolute h-8 w-8 rounded-full",
        orientation === "horizontal"
          ? "-right-12 top-1/2 -translate-y-1/2"
          : "-bottom-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      )}
      disabled={!canScrollNext}
      onClick={scrollNext}
      {...props}
    >
      <ArrowRight className="h-4 w-4" />
      <span className="sr-only">Next slide</span>
    </Button>
  )
})
CarouselNext.displayName = "CarouselNext"

export {
  type CarouselApi,
  Carousel,
  CarouselContent,
  CarouselItem,
  CarouselPrevious,
  CarouselNext,
}
</file>

<file path="client/src/components/ui/chart.tsx">
"use client"

import * as React from "react"
import * as RechartsPrimitive from "recharts"

import { cn } from "@/lib/utils"

// Format: { THEME_NAME: CSS_SELECTOR }
const THEMES = { light: "", dark: ".dark" } as const

export type ChartConfig = {
  [k in string]: {
    label?: React.ReactNode
    icon?: React.ComponentType
  } & (
    | { color?: string; theme?: never }
    | { color?: never; theme: Record<keyof typeof THEMES, string> }
  )
}

type ChartContextProps = {
  config: ChartConfig
}

const ChartContext = React.createContext<ChartContextProps | null>(null)

function useChart() {
  const context = React.useContext(ChartContext)

  if (!context) {
    throw new Error("useChart must be used within a <ChartContainer />")
  }

  return context
}

const ChartContainer = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    config: ChartConfig
    children: React.ComponentProps<
      typeof RechartsPrimitive.ResponsiveContainer
    >["children"]
  }
>(({ id, className, children, config, ...props }, ref) => {
  const uniqueId = React.useId()
  const chartId = `chart-${id || uniqueId.replace(/:/g, "")}`

  return (
    <ChartContext.Provider value={{ config }}>
      <div
        data-chart={chartId}
        ref={ref}
        className={cn(
          "flex aspect-video justify-center text-xs [&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke='#ccc']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-none [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke='#ccc']]:stroke-border [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-sector]:outline-none [&_.recharts-surface]:outline-none",
          className
        )}
        {...props}
      >
        <ChartStyle id={chartId} config={config} />
        <RechartsPrimitive.ResponsiveContainer>
          {children}
        </RechartsPrimitive.ResponsiveContainer>
      </div>
    </ChartContext.Provider>
  )
})
ChartContainer.displayName = "Chart"

const ChartStyle = ({ id, config }: { id: string; config: ChartConfig }) => {
  const colorConfig = Object.entries(config).filter(
    ([, config]) => config.theme || config.color
  )

  if (!colorConfig.length) {
    return null
  }

  return (
    <style
      dangerouslySetInnerHTML={{
        __html: Object.entries(THEMES)
          .map(
            ([theme, prefix]) => `
${prefix} [data-chart=${id}] {
${colorConfig
  .map(([key, itemConfig]) => {
    const color =
      itemConfig.theme?.[theme as keyof typeof itemConfig.theme] ||
      itemConfig.color
    return color ? `  --color-${key}: ${color};` : null
  })
  .join("\n")}
}
`
          )
          .join("\n"),
      }}
    />
  )
}

const ChartTooltip = RechartsPrimitive.Tooltip

const ChartTooltipContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<typeof RechartsPrimitive.Tooltip> &
    React.ComponentProps<"div"> & {
      hideLabel?: boolean
      hideIndicator?: boolean
      indicator?: "line" | "dot" | "dashed"
      nameKey?: string
      labelKey?: string
    }
>(
  (
    {
      active,
      payload,
      className,
      indicator = "dot",
      hideLabel = false,
      hideIndicator = false,
      label,
      labelFormatter,
      labelClassName,
      formatter,
      color,
      nameKey,
      labelKey,
    },
    ref
  ) => {
    const { config } = useChart()

    const tooltipLabel = React.useMemo(() => {
      if (hideLabel || !payload?.length) {
        return null
      }

      const [item] = payload
      const key = `${labelKey || item?.dataKey || item?.name || "value"}`
      const itemConfig = getPayloadConfigFromPayload(config, item, key)
      const value =
        !labelKey && typeof label === "string"
          ? config[label as keyof typeof config]?.label || label
          : itemConfig?.label

      if (labelFormatter) {
        return (
          <div className={cn("font-medium", labelClassName)}>
            {labelFormatter(value, payload)}
          </div>
        )
      }

      if (!value) {
        return null
      }

      return <div className={cn("font-medium", labelClassName)}>{value}</div>
    }, [
      label,
      labelFormatter,
      payload,
      hideLabel,
      labelClassName,
      config,
      labelKey,
    ])

    if (!active || !payload?.length) {
      return null
    }

    const nestLabel = payload.length === 1 && indicator !== "dot"

    return (
      <div
        ref={ref}
        className={cn(
          "grid min-w-[8rem] items-start gap-1.5 rounded-lg border border-border/50 bg-background px-2.5 py-1.5 text-xs shadow-xl",
          className
        )}
      >
        {!nestLabel ? tooltipLabel : null}
        <div className="grid gap-1.5">
          {payload.map((item, index) => {
            const key = `${nameKey || item.name || item.dataKey || "value"}`
            const itemConfig = getPayloadConfigFromPayload(config, item, key)
            const indicatorColor = color || item.payload.fill || item.color

            return (
              <div
                key={item.dataKey}
                className={cn(
                  "flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5 [&>svg]:text-muted-foreground",
                  indicator === "dot" && "items-center"
                )}
              >
                {formatter && item?.value !== undefined && item.name ? (
                  formatter(item.value, item.name, item, index, item.payload)
                ) : (
                  <>
                    {itemConfig?.icon ? (
                      <itemConfig.icon />
                    ) : (
                      !hideIndicator && (
                        <div
                          className={cn(
                            "shrink-0 rounded-[2px] border-[--color-border] bg-[--color-bg]",
                            {
                              "h-2.5 w-2.5": indicator === "dot",
                              "w-1": indicator === "line",
                              "w-0 border-[1.5px] border-dashed bg-transparent":
                                indicator === "dashed",
                              "my-0.5": nestLabel && indicator === "dashed",
                            }
                          )}
                          style={
                            {
                              "--color-bg": indicatorColor,
                              "--color-border": indicatorColor,
                            } as React.CSSProperties
                          }
                        />
                      )
                    )}
                    <div
                      className={cn(
                        "flex flex-1 justify-between leading-none",
                        nestLabel ? "items-end" : "items-center"
                      )}
                    >
                      <div className="grid gap-1.5">
                        {nestLabel ? tooltipLabel : null}
                        <span className="text-muted-foreground">
                          {itemConfig?.label || item.name}
                        </span>
                      </div>
                      {item.value && (
                        <span className="font-mono font-medium tabular-nums text-foreground">
                          {item.value.toLocaleString()}
                        </span>
                      )}
                    </div>
                  </>
                )}
              </div>
            )
          })}
        </div>
      </div>
    )
  }
)
ChartTooltipContent.displayName = "ChartTooltip"

const ChartLegend = RechartsPrimitive.Legend

const ChartLegendContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> &
    Pick<RechartsPrimitive.LegendProps, "payload" | "verticalAlign"> & {
      hideIcon?: boolean
      nameKey?: string
    }
>(
  (
    { className, hideIcon = false, payload, verticalAlign = "bottom", nameKey },
    ref
  ) => {
    const { config } = useChart()

    if (!payload?.length) {
      return null
    }

    return (
      <div
        ref={ref}
        className={cn(
          "flex items-center justify-center gap-4",
          verticalAlign === "top" ? "pb-3" : "pt-3",
          className
        )}
      >
        {payload.map((item) => {
          const key = `${nameKey || item.dataKey || "value"}`
          const itemConfig = getPayloadConfigFromPayload(config, item, key)

          return (
            <div
              key={item.value}
              className={cn(
                "flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3 [&>svg]:text-muted-foreground"
              )}
            >
              {itemConfig?.icon && !hideIcon ? (
                <itemConfig.icon />
              ) : (
                <div
                  className="h-2 w-2 shrink-0 rounded-[2px]"
                  style={{
                    backgroundColor: item.color,
                  }}
                />
              )}
              {itemConfig?.label}
            </div>
          )
        })}
      </div>
    )
  }
)
ChartLegendContent.displayName = "ChartLegend"

// Helper to extract item config from a payload.
function getPayloadConfigFromPayload(
  config: ChartConfig,
  payload: unknown,
  key: string
) {
  if (typeof payload !== "object" || payload === null) {
    return undefined
  }

  const payloadPayload =
    "payload" in payload &&
    typeof payload.payload === "object" &&
    payload.payload !== null
      ? payload.payload
      : undefined

  let configLabelKey: string = key

  if (
    key in payload &&
    typeof payload[key as keyof typeof payload] === "string"
  ) {
    configLabelKey = payload[key as keyof typeof payload] as string
  } else if (
    payloadPayload &&
    key in payloadPayload &&
    typeof payloadPayload[key as keyof typeof payloadPayload] === "string"
  ) {
    configLabelKey = payloadPayload[
      key as keyof typeof payloadPayload
    ] as string
  }

  return configLabelKey in config
    ? config[configLabelKey]
    : config[key as keyof typeof config]
}

export {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  ChartLegend,
  ChartLegendContent,
  ChartStyle,
}
</file>

<file path="client/src/components/ui/checkbox.tsx">
import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { Check } from "lucide-react"

import { cn } from "@/lib/utils"

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
))
Checkbox.displayName = CheckboxPrimitive.Root.displayName

export { Checkbox }
</file>

<file path="client/src/components/ui/collapsible.tsx">
"use client"

import * as CollapsiblePrimitive from "@radix-ui/react-collapsible"

const Collapsible = CollapsiblePrimitive.Root

const CollapsibleTrigger = CollapsiblePrimitive.CollapsibleTrigger

const CollapsibleContent = CollapsiblePrimitive.CollapsibleContent

export { Collapsible, CollapsibleTrigger, CollapsibleContent }
</file>

<file path="client/src/components/ui/command.tsx">
import * as React from "react"
import { type DialogProps } from "@radix-ui/react-dialog"
import { Command as CommandPrimitive } from "cmdk"
import { Search } from "lucide-react"

import { cn } from "@/lib/utils"
import { Dialog, DialogContent } from "@/components/ui/dialog"

const Command = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive>
>(({ className, ...props }, ref) => (
  <CommandPrimitive
    ref={ref}
    className={cn(
      "flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground",
      className
    )}
    {...props}
  />
))
Command.displayName = CommandPrimitive.displayName

const CommandDialog = ({ children, ...props }: DialogProps) => {
  return (
    <Dialog {...props}>
      <DialogContent className="overflow-hidden p-0 shadow-lg">
        <Command className="[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  )
}

const CommandInput = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Input>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>
>(({ className, ...props }, ref) => (
  <div className="flex items-center border-b px-3" cmdk-input-wrapper="">
    <Search className="mr-2 h-4 w-4 shrink-0 opacity-50" />
    <CommandPrimitive.Input
      ref={ref}
      className={cn(
        "flex h-11 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    />
  </div>
))

CommandInput.displayName = CommandPrimitive.Input.displayName

const CommandList = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.List
    ref={ref}
    className={cn("max-h-[300px] overflow-y-auto overflow-x-hidden", className)}
    {...props}
  />
))

CommandList.displayName = CommandPrimitive.List.displayName

const CommandEmpty = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Empty>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>
>((props, ref) => (
  <CommandPrimitive.Empty
    ref={ref}
    className="py-6 text-center text-sm"
    {...props}
  />
))

CommandEmpty.displayName = CommandPrimitive.Empty.displayName

const CommandGroup = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Group>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Group
    ref={ref}
    className={cn(
      "overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
      className
    )}
    {...props}
  />
))

CommandGroup.displayName = CommandPrimitive.Group.displayName

const CommandSeparator = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 h-px bg-border", className)}
    {...props}
  />
))
CommandSeparator.displayName = CommandPrimitive.Separator.displayName

const CommandItem = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default gap-2 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled=true]:pointer-events-none data-[selected='true']:bg-accent data-[selected=true]:text-accent-foreground data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      className
    )}
    {...props}
  />
))

CommandItem.displayName = CommandPrimitive.Item.displayName

const CommandShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
CommandShortcut.displayName = "CommandShortcut"

export {
  Command,
  CommandDialog,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandShortcut,
  CommandSeparator,
}
</file>

<file path="client/src/components/ui/context-menu.tsx">
import * as React from "react"
import * as ContextMenuPrimitive from "@radix-ui/react-context-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const ContextMenu = ContextMenuPrimitive.Root

const ContextMenuTrigger = ContextMenuPrimitive.Trigger

const ContextMenuGroup = ContextMenuPrimitive.Group

const ContextMenuPortal = ContextMenuPrimitive.Portal

const ContextMenuSub = ContextMenuPrimitive.Sub

const ContextMenuRadioGroup = ContextMenuPrimitive.RadioGroup

const ContextMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <ContextMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </ContextMenuPrimitive.SubTrigger>
))
ContextMenuSubTrigger.displayName = ContextMenuPrimitive.SubTrigger.displayName

const ContextMenuSubContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-context-menu-content-transform-origin]",
      className
    )}
    {...props}
  />
))
ContextMenuSubContent.displayName = ContextMenuPrimitive.SubContent.displayName

const ContextMenuContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Portal>
    <ContextMenuPrimitive.Content
      ref={ref}
      className={cn(
        "z-50 max-h-[--radix-context-menu-content-available-height] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md animate-in fade-in-80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-context-menu-content-transform-origin]",
        className
      )}
      {...props}
    />
  </ContextMenuPrimitive.Portal>
))
ContextMenuContent.displayName = ContextMenuPrimitive.Content.displayName

const ContextMenuItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
ContextMenuItem.displayName = ContextMenuPrimitive.Item.displayName

const ContextMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <ContextMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.CheckboxItem>
))
ContextMenuCheckboxItem.displayName =
  ContextMenuPrimitive.CheckboxItem.displayName

const ContextMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <ContextMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.RadioItem>
))
ContextMenuRadioItem.displayName = ContextMenuPrimitive.RadioItem.displayName

const ContextMenuLabel = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold text-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
ContextMenuLabel.displayName = ContextMenuPrimitive.Label.displayName

const ContextMenuSeparator = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-border", className)}
    {...props}
  />
))
ContextMenuSeparator.displayName = ContextMenuPrimitive.Separator.displayName

const ContextMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
ContextMenuShortcut.displayName = "ContextMenuShortcut"

export {
  ContextMenu,
  ContextMenuTrigger,
  ContextMenuContent,
  ContextMenuItem,
  ContextMenuCheckboxItem,
  ContextMenuRadioItem,
  ContextMenuLabel,
  ContextMenuSeparator,
  ContextMenuShortcut,
  ContextMenuGroup,
  ContextMenuPortal,
  ContextMenuSub,
  ContextMenuSubContent,
  ContextMenuSubTrigger,
  ContextMenuRadioGroup,
}
</file>

<file path="client/src/components/ui/dialog.tsx">
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}
</file>

<file path="client/src/components/ui/drawer.tsx">
"use client"

import * as React from "react"
import { Drawer as DrawerPrimitive } from "vaul"

import { cn } from "@/lib/utils"

const Drawer = ({
  shouldScaleBackground = true,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Root>) => (
  <DrawerPrimitive.Root
    shouldScaleBackground={shouldScaleBackground}
    {...props}
  />
)
Drawer.displayName = "Drawer"

const DrawerTrigger = DrawerPrimitive.Trigger

const DrawerPortal = DrawerPrimitive.Portal

const DrawerClose = DrawerPrimitive.Close

const DrawerOverlay = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Overlay
    ref={ref}
    className={cn("fixed inset-0 z-50 bg-black/80", className)}
    {...props}
  />
))
DrawerOverlay.displayName = DrawerPrimitive.Overlay.displayName

const DrawerContent = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DrawerPortal>
    <DrawerOverlay />
    <DrawerPrimitive.Content
      ref={ref}
      className={cn(
        "fixed inset-x-0 bottom-0 z-50 mt-24 flex h-auto flex-col rounded-t-[10px] border bg-background",
        className
      )}
      {...props}
    >
      <div className="mx-auto mt-4 h-2 w-[100px] rounded-full bg-muted" />
      {children}
    </DrawerPrimitive.Content>
  </DrawerPortal>
))
DrawerContent.displayName = "DrawerContent"

const DrawerHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("grid gap-1.5 p-4 text-center sm:text-left", className)}
    {...props}
  />
)
DrawerHeader.displayName = "DrawerHeader"

const DrawerFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("mt-auto flex flex-col gap-2 p-4", className)}
    {...props}
  />
)
DrawerFooter.displayName = "DrawerFooter"

const DrawerTitle = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DrawerTitle.displayName = DrawerPrimitive.Title.displayName

const DrawerDescription = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DrawerDescription.displayName = DrawerPrimitive.Description.displayName

export {
  Drawer,
  DrawerPortal,
  DrawerOverlay,
  DrawerTrigger,
  DrawerClose,
  DrawerContent,
  DrawerHeader,
  DrawerFooter,
  DrawerTitle,
  DrawerDescription,
}
</file>

<file path="client/src/components/ui/dropdown-menu.tsx">
import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const DropdownMenu = DropdownMenuPrimitive.Root

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger

const DropdownMenuGroup = DropdownMenuPrimitive.Group

const DropdownMenuPortal = DropdownMenuPrimitive.Portal

const DropdownMenuSub = DropdownMenuPrimitive.Sub

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-dropdown-menu-content-transform-origin]",
      className
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 max-h-[var(--radix-dropdown-menu-content-available-height)] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-dropdown-menu-content-transform-origin]",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  )
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}
</file>

<file path="client/src/components/ui/form.tsx">
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { Slot } from "@radix-ui/react-slot"
import {
  Controller,
  FormProvider,
  useFormContext,
  type ControllerProps,
  type FieldPath,
  type FieldValues,
} from "react-hook-form"

import { cn } from "@/lib/utils"
import { Label } from "@/components/ui/label"

const Form = FormProvider

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
> = {
  name: TName
}

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
)

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  )
}

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext)
  const itemContext = React.useContext(FormItemContext)
  const { getFieldState, formState } = useFormContext()

  const fieldState = getFieldState(fieldContext.name, formState)

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>")
  }

  const { id } = itemContext

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  }
}

type FormItemContextValue = {
  id: string
}

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
)

const FormItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const id = React.useId()

  return (
    <FormItemContext.Provider value={{ id }}>
      <div ref={ref} className={cn("space-y-2", className)} {...props} />
    </FormItemContext.Provider>
  )
})
FormItem.displayName = "FormItem"

const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField()

  return (
    <Label
      ref={ref}
      className={cn(error && "text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  )
})
FormLabel.displayName = "FormLabel"

const FormControl = React.forwardRef<
  React.ElementRef<typeof Slot>,
  React.ComponentPropsWithoutRef<typeof Slot>
>(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()

  return (
    <Slot
      ref={ref}
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  )
})
FormControl.displayName = "FormControl"

const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField()

  return (
    <p
      ref={ref}
      id={formDescriptionId}
      className={cn("text-sm text-muted-foreground", className)}
      {...props}
    />
  )
})
FormDescription.displayName = "FormDescription"

const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField()
  const body = error ? String(error?.message ?? "") : children

  if (!body) {
    return null
  }

  return (
    <p
      ref={ref}
      id={formMessageId}
      className={cn("text-sm font-medium text-destructive", className)}
      {...props}
    >
      {body}
    </p>
  )
})
FormMessage.displayName = "FormMessage"

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
}
</file>

<file path="client/src/components/ui/hover-card.tsx">
"use client"

import * as React from "react"
import * as HoverCardPrimitive from "@radix-ui/react-hover-card"

import { cn } from "@/lib/utils"

const HoverCard = HoverCardPrimitive.Root

const HoverCardTrigger = HoverCardPrimitive.Trigger

const HoverCardContent = React.forwardRef<
  React.ElementRef<typeof HoverCardPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof HoverCardPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <HoverCardPrimitive.Content
    ref={ref}
    align={align}
    sideOffset={sideOffset}
    className={cn(
      "z-50 w-64 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-hover-card-content-transform-origin]",
      className
    )}
    {...props}
  />
))
HoverCardContent.displayName = HoverCardPrimitive.Content.displayName

export { HoverCard, HoverCardTrigger, HoverCardContent }
</file>

<file path="client/src/components/ui/input-otp.tsx">
import * as React from "react"
import { OTPInput, OTPInputContext } from "input-otp"
import { Dot } from "lucide-react"

import { cn } from "@/lib/utils"

const InputOTP = React.forwardRef<
  React.ElementRef<typeof OTPInput>,
  React.ComponentPropsWithoutRef<typeof OTPInput>
>(({ className, containerClassName, ...props }, ref) => (
  <OTPInput
    ref={ref}
    containerClassName={cn(
      "flex items-center gap-2 has-[:disabled]:opacity-50",
      containerClassName
    )}
    className={cn("disabled:cursor-not-allowed", className)}
    {...props}
  />
))
InputOTP.displayName = "InputOTP"

const InputOTPGroup = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div">
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("flex items-center", className)} {...props} />
))
InputOTPGroup.displayName = "InputOTPGroup"

const InputOTPSlot = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div"> & { index: number }
>(({ index, className, ...props }, ref) => {
  const inputOTPContext = React.useContext(OTPInputContext)
  const { char, hasFakeCaret, isActive } = inputOTPContext.slots[index]

  return (
    <div
      ref={ref}
      className={cn(
        "relative flex h-10 w-10 items-center justify-center border-y border-r border-input text-sm transition-all first:rounded-l-md first:border-l last:rounded-r-md",
        isActive && "z-10 ring-2 ring-ring ring-offset-background",
        className
      )}
      {...props}
    >
      {char}
      {hasFakeCaret && (
        <div className="pointer-events-none absolute inset-0 flex items-center justify-center">
          <div className="h-4 w-px animate-caret-blink bg-foreground duration-1000" />
        </div>
      )}
    </div>
  )
})
InputOTPSlot.displayName = "InputOTPSlot"

const InputOTPSeparator = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div">
>(({ ...props }, ref) => (
  <div ref={ref} role="separator" {...props}>
    <Dot />
  </div>
))
InputOTPSeparator.displayName = "InputOTPSeparator"

export { InputOTP, InputOTPGroup, InputOTPSlot, InputOTPSeparator }
</file>

<file path="client/src/components/ui/input.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

const Input = React.forwardRef<HTMLInputElement, React.ComponentProps<"input">>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }
</file>

<file path="client/src/components/ui/label.tsx">
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }
</file>

<file path="client/src/components/ui/menubar.tsx">
"use client"

import * as React from "react"
import * as MenubarPrimitive from "@radix-ui/react-menubar"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

function MenubarMenu({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Menu>) {
  return <MenubarPrimitive.Menu {...props} />
}

function MenubarGroup({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Group>) {
  return <MenubarPrimitive.Group {...props} />
}

function MenubarPortal({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Portal>) {
  return <MenubarPrimitive.Portal {...props} />
}

function MenubarRadioGroup({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.RadioGroup>) {
  return <MenubarPrimitive.RadioGroup {...props} />
}

function MenubarSub({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Sub>) {
  return <MenubarPrimitive.Sub data-slot="menubar-sub" {...props} />
}

const Menubar = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Root
    ref={ref}
    className={cn(
      "flex h-10 items-center space-x-1 rounded-md border bg-background p-1",
      className
    )}
    {...props}
  />
))
Menubar.displayName = MenubarPrimitive.Root.displayName

const MenubarTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-3 py-1.5 text-sm font-medium outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      className
    )}
    {...props}
  />
))
MenubarTrigger.displayName = MenubarPrimitive.Trigger.displayName

const MenubarSubTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <MenubarPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </MenubarPrimitive.SubTrigger>
))
MenubarSubTrigger.displayName = MenubarPrimitive.SubTrigger.displayName

const MenubarSubContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-menubar-content-transform-origin]",
      className
    )}
    {...props}
  />
))
MenubarSubContent.displayName = MenubarPrimitive.SubContent.displayName

const MenubarContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Content>
>(
  (
    { className, align = "start", alignOffset = -4, sideOffset = 8, ...props },
    ref
  ) => (
    <MenubarPrimitive.Portal>
      <MenubarPrimitive.Content
        ref={ref}
        align={align}
        alignOffset={alignOffset}
        sideOffset={sideOffset}
        className={cn(
          "z-50 min-w-[12rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-menubar-content-transform-origin]",
          className
        )}
        {...props}
      />
    </MenubarPrimitive.Portal>
  )
)
MenubarContent.displayName = MenubarPrimitive.Content.displayName

const MenubarItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
MenubarItem.displayName = MenubarPrimitive.Item.displayName

const MenubarCheckboxItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <MenubarPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.CheckboxItem>
))
MenubarCheckboxItem.displayName = MenubarPrimitive.CheckboxItem.displayName

const MenubarRadioItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <MenubarPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.RadioItem>
))
MenubarRadioItem.displayName = MenubarPrimitive.RadioItem.displayName

const MenubarLabel = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
MenubarLabel.displayName = MenubarPrimitive.Label.displayName

const MenubarSeparator = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
MenubarSeparator.displayName = MenubarPrimitive.Separator.displayName

const MenubarShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
MenubarShortcut.displayname = "MenubarShortcut"

export {
  Menubar,
  MenubarMenu,
  MenubarTrigger,
  MenubarContent,
  MenubarItem,
  MenubarSeparator,
  MenubarLabel,
  MenubarCheckboxItem,
  MenubarRadioGroup,
  MenubarRadioItem,
  MenubarPortal,
  MenubarSubContent,
  MenubarSubTrigger,
  MenubarGroup,
  MenubarSub,
  MenubarShortcut,
}
</file>

<file path="client/src/components/ui/navigation-menu.tsx">
import * as React from "react"
import * as NavigationMenuPrimitive from "@radix-ui/react-navigation-menu"
import { cva } from "class-variance-authority"
import { ChevronDown } from "lucide-react"

import { cn } from "@/lib/utils"

const NavigationMenu = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Root
    ref={ref}
    className={cn(
      "relative z-10 flex max-w-max flex-1 items-center justify-center",
      className
    )}
    {...props}
  >
    {children}
    <NavigationMenuViewport />
  </NavigationMenuPrimitive.Root>
))
NavigationMenu.displayName = NavigationMenuPrimitive.Root.displayName

const NavigationMenuList = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.List>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.List
    ref={ref}
    className={cn(
      "group flex flex-1 list-none items-center justify-center space-x-1",
      className
    )}
    {...props}
  />
))
NavigationMenuList.displayName = NavigationMenuPrimitive.List.displayName

const NavigationMenuItem = NavigationMenuPrimitive.Item

const navigationMenuTriggerStyle = cva(
  "group inline-flex h-10 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[state=open]:text-accent-foreground data-[state=open]:bg-accent/50 data-[state=open]:hover:bg-accent data-[state=open]:focus:bg-accent"
)

const NavigationMenuTrigger = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Trigger
    ref={ref}
    className={cn(navigationMenuTriggerStyle(), "group", className)}
    {...props}
  >
    {children}{" "}
    <ChevronDown
      className="relative top-[1px] ml-1 h-3 w-3 transition duration-200 group-data-[state=open]:rotate-180"
      aria-hidden="true"
    />
  </NavigationMenuPrimitive.Trigger>
))
NavigationMenuTrigger.displayName = NavigationMenuPrimitive.Trigger.displayName

const NavigationMenuContent = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Content
    ref={ref}
    className={cn(
      "left-0 top-0 w-full data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 md:absolute md:w-auto ",
      className
    )}
    {...props}
  />
))
NavigationMenuContent.displayName = NavigationMenuPrimitive.Content.displayName

const NavigationMenuLink = NavigationMenuPrimitive.Link

const NavigationMenuViewport = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Viewport>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Viewport>
>(({ className, ...props }, ref) => (
  <div className={cn("absolute left-0 top-full flex justify-center")}>
    <NavigationMenuPrimitive.Viewport
      className={cn(
        "origin-top-center relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 md:w-[var(--radix-navigation-menu-viewport-width)]",
        className
      )}
      ref={ref}
      {...props}
    />
  </div>
))
NavigationMenuViewport.displayName =
  NavigationMenuPrimitive.Viewport.displayName

const NavigationMenuIndicator = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Indicator>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Indicator>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Indicator
    ref={ref}
    className={cn(
      "top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in",
      className
    )}
    {...props}
  >
    <div className="relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md" />
  </NavigationMenuPrimitive.Indicator>
))
NavigationMenuIndicator.displayName =
  NavigationMenuPrimitive.Indicator.displayName

export {
  navigationMenuTriggerStyle,
  NavigationMenu,
  NavigationMenuList,
  NavigationMenuItem,
  NavigationMenuContent,
  NavigationMenuTrigger,
  NavigationMenuLink,
  NavigationMenuIndicator,
  NavigationMenuViewport,
}
</file>

<file path="client/src/components/ui/pagination.tsx">
import * as React from "react"
import { ChevronLeft, ChevronRight, MoreHorizontal } from "lucide-react"

import { cn } from "@/lib/utils"
import { ButtonProps, buttonVariants } from "@/components/ui/button"

const Pagination = ({ className, ...props }: React.ComponentProps<"nav">) => (
  <nav
    role="navigation"
    aria-label="pagination"
    className={cn("mx-auto flex w-full justify-center", className)}
    {...props}
  />
)
Pagination.displayName = "Pagination"

const PaginationContent = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    className={cn("flex flex-row items-center gap-1", className)}
    {...props}
  />
))
PaginationContent.displayName = "PaginationContent"

const PaginationItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ className, ...props }, ref) => (
  <li ref={ref} className={cn("", className)} {...props} />
))
PaginationItem.displayName = "PaginationItem"

type PaginationLinkProps = {
  isActive?: boolean
} & Pick<ButtonProps, "size"> &
  React.ComponentProps<"a">

const PaginationLink = ({
  className,
  isActive,
  size = "icon",
  ...props
}: PaginationLinkProps) => (
  <a
    aria-current={isActive ? "page" : undefined}
    className={cn(
      buttonVariants({
        variant: isActive ? "outline" : "ghost",
        size,
      }),
      className
    )}
    {...props}
  />
)
PaginationLink.displayName = "PaginationLink"

const PaginationPrevious = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to previous page"
    size="default"
    className={cn("gap-1 pl-2.5", className)}
    {...props}
  >
    <ChevronLeft className="h-4 w-4" />
    <span>Previous</span>
  </PaginationLink>
)
PaginationPrevious.displayName = "PaginationPrevious"

const PaginationNext = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to next page"
    size="default"
    className={cn("gap-1 pr-2.5", className)}
    {...props}
  >
    <span>Next</span>
    <ChevronRight className="h-4 w-4" />
  </PaginationLink>
)
PaginationNext.displayName = "PaginationNext"

const PaginationEllipsis = ({
  className,
  ...props
}: React.ComponentProps<"span">) => (
  <span
    aria-hidden
    className={cn("flex h-9 w-9 items-center justify-center", className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More pages</span>
  </span>
)
PaginationEllipsis.displayName = "PaginationEllipsis"

export {
  Pagination,
  PaginationContent,
  PaginationEllipsis,
  PaginationItem,
  PaginationLink,
  PaginationNext,
  PaginationPrevious,
}
</file>

<file path="client/src/components/ui/popover.tsx">
import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

const Popover = PopoverPrimitive.Root

const PopoverTrigger = PopoverPrimitive.Trigger

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-popover-content-transform-origin]",
        className
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
))
PopoverContent.displayName = PopoverPrimitive.Content.displayName

export { Popover, PopoverTrigger, PopoverContent }
</file>

<file path="client/src/components/ui/progress.tsx">
"use client"

import * as React from "react"
import * as ProgressPrimitive from "@radix-ui/react-progress"

import { cn } from "@/lib/utils"

const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className={cn(
      "relative h-4 w-full overflow-hidden rounded-full bg-secondary",
      className
    )}
    {...props}
  >
    <ProgressPrimitive.Indicator
      className="h-full w-full flex-1 bg-primary transition-all"
      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
    />
  </ProgressPrimitive.Root>
))
Progress.displayName = ProgressPrimitive.Root.displayName

export { Progress }
</file>

<file path="client/src/components/ui/radio-group.tsx">
import * as React from "react"
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group"
import { Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const RadioGroup = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Root
      className={cn("grid gap-2", className)}
      {...props}
      ref={ref}
    />
  )
})
RadioGroup.displayName = RadioGroupPrimitive.Root.displayName

const RadioGroupItem = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Item
      ref={ref}
      className={cn(
        "aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator className="flex items-center justify-center">
        <Circle className="h-2.5 w-2.5 fill-current text-current" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  )
})
RadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName

export { RadioGroup, RadioGroupItem }
</file>

<file path="client/src/components/ui/resizable.tsx">
"use client"

import { GripVertical } from "lucide-react"
import * as ResizablePrimitive from "react-resizable-panels"

import { cn } from "@/lib/utils"

const ResizablePanelGroup = ({
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelGroup>) => (
  <ResizablePrimitive.PanelGroup
    className={cn(
      "flex h-full w-full data-[panel-group-direction=vertical]:flex-col",
      className
    )}
    {...props}
  />
)

const ResizablePanel = ResizablePrimitive.Panel

const ResizableHandle = ({
  withHandle,
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelResizeHandle> & {
  withHandle?: boolean
}) => (
  <ResizablePrimitive.PanelResizeHandle
    className={cn(
      "relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:-translate-y-1/2 data-[panel-group-direction=vertical]:after:translate-x-0 [&[data-panel-group-direction=vertical]>div]:rotate-90",
      className
    )}
    {...props}
  >
    {withHandle && (
      <div className="z-10 flex h-4 w-3 items-center justify-center rounded-sm border bg-border">
        <GripVertical className="h-2.5 w-2.5" />
      </div>
    )}
  </ResizablePrimitive.PanelResizeHandle>
)

export { ResizablePanelGroup, ResizablePanel, ResizableHandle }
</file>

<file path="client/src/components/ui/scroll-area.tsx">
import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName

export { ScrollArea, ScrollBar }
</file>

<file path="client/src/components/ui/select.tsx">
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "@/lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background data-[placeholder]:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-[--radix-select-content-available-height] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-select-content-transform-origin]",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>

    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}
</file>

<file path="client/src/components/ui/separator.tsx">
import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        className
      )}
      {...props}
    />
  )
)
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator }
</file>

<file path="client/src/components/ui/sheet.tsx">
"use client"

import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Sheet = SheetPrimitive.Root

const SheetTrigger = SheetPrimitive.Trigger

const SheetClose = SheetPrimitive.Close

const SheetPortal = SheetPrimitive.Portal

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName

const sheetVariants = cva(
  "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom:
          "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right:
          "inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
      },
    },
    defaultVariants: {
      side: "right",
    },
  }
)

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
    VariantProps<typeof sheetVariants> {}

const SheetContent = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(({ side = "right", className, children, ...props }, ref) => (
  <SheetPortal>
    <SheetOverlay />
    <SheetPrimitive.Content
      ref={ref}
      className={cn(sheetVariants({ side }), className)}
      {...props}
    >
      {children}
      <SheetPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </SheetPrimitive.Close>
    </SheetPrimitive.Content>
  </SheetPortal>
))
SheetContent.displayName = SheetPrimitive.Content.displayName

const SheetHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
SheetHeader.displayName = "SheetHeader"

const SheetFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
SheetFooter.displayName = "SheetFooter"

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold text-foreground", className)}
    {...props}
  />
))
SheetTitle.displayName = SheetPrimitive.Title.displayName

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
SheetDescription.displayName = SheetPrimitive.Description.displayName

export {
  Sheet,
  SheetPortal,
  SheetOverlay,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}
</file>

<file path="client/src/components/ui/sidebar.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { VariantProps, cva } from "class-variance-authority"
import { PanelLeft } from "lucide-react"

import { useIsMobile } from "@/hooks/use-mobile"
import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Separator } from "@/components/ui/separator"
import {
  Sheet,
  SheetContent,
  SheetDescription,
  SheetHeader,
  SheetTitle,
} from "@/components/ui/sheet"
import { Skeleton } from "@/components/ui/skeleton"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"

const SIDEBAR_COOKIE_NAME = "sidebar_state"
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7
const SIDEBAR_WIDTH = "16rem"
const SIDEBAR_WIDTH_MOBILE = "18rem"
const SIDEBAR_WIDTH_ICON = "3rem"
const SIDEBAR_KEYBOARD_SHORTCUT = "b"

type SidebarContextProps = {
  state: "expanded" | "collapsed"
  open: boolean
  setOpen: (open: boolean) => void
  openMobile: boolean
  setOpenMobile: (open: boolean) => void
  isMobile: boolean
  toggleSidebar: () => void
}

const SidebarContext = React.createContext<SidebarContextProps | null>(null)

function useSidebar() {
  const context = React.useContext(SidebarContext)
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider.")
  }

  return context
}

const SidebarProvider = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    defaultOpen?: boolean
    open?: boolean
    onOpenChange?: (open: boolean) => void
  }
>(
  (
    {
      defaultOpen = true,
      open: openProp,
      onOpenChange: setOpenProp,
      className,
      style,
      children,
      ...props
    },
    ref
  ) => {
    const isMobile = useIsMobile()
    const [openMobile, setOpenMobile] = React.useState(false)

    // This is the internal state of the sidebar.
    // We use openProp and setOpenProp for control from outside the component.
    const [_open, _setOpen] = React.useState(defaultOpen)
    const open = openProp ?? _open
    const setOpen = React.useCallback(
      (value: boolean | ((value: boolean) => boolean)) => {
        const openState = typeof value === "function" ? value(open) : value
        if (setOpenProp) {
          setOpenProp(openState)
        } else {
          _setOpen(openState)
        }

        // This sets the cookie to keep the sidebar state.
        document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`
      },
      [setOpenProp, open]
    )

    // Helper to toggle the sidebar.
    const toggleSidebar = React.useCallback(() => {
      return isMobile
        ? setOpenMobile((open) => !open)
        : setOpen((open) => !open)
    }, [isMobile, setOpen, setOpenMobile])

    // Adds a keyboard shortcut to toggle the sidebar.
    React.useEffect(() => {
      const handleKeyDown = (event: KeyboardEvent) => {
        if (
          event.key === SIDEBAR_KEYBOARD_SHORTCUT &&
          (event.metaKey || event.ctrlKey)
        ) {
          event.preventDefault()
          toggleSidebar()
        }
      }

      window.addEventListener("keydown", handleKeyDown)
      return () => window.removeEventListener("keydown", handleKeyDown)
    }, [toggleSidebar])

    // We add a state so that we can do data-state="expanded" or "collapsed".
    // This makes it easier to style the sidebar with Tailwind classes.
    const state = open ? "expanded" : "collapsed"

    const contextValue = React.useMemo<SidebarContextProps>(
      () => ({
        state,
        open,
        setOpen,
        isMobile,
        openMobile,
        setOpenMobile,
        toggleSidebar,
      }),
      [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]
    )

    return (
      <SidebarContext.Provider value={contextValue}>
        <TooltipProvider delayDuration={0}>
          <div
            style={
              {
                "--sidebar-width": SIDEBAR_WIDTH,
                "--sidebar-width-icon": SIDEBAR_WIDTH_ICON,
                ...style,
              } as React.CSSProperties
            }
            className={cn(
              "group/sidebar-wrapper flex min-h-svh w-full has-[[data-variant=inset]]:bg-sidebar",
              className
            )}
            ref={ref}
            {...props}
          >
            {children}
          </div>
        </TooltipProvider>
      </SidebarContext.Provider>
    )
  }
)
SidebarProvider.displayName = "SidebarProvider"

const Sidebar = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    side?: "left" | "right"
    variant?: "sidebar" | "floating" | "inset"
    collapsible?: "offcanvas" | "icon" | "none"
  }
>(
  (
    {
      side = "left",
      variant = "sidebar",
      collapsible = "offcanvas",
      className,
      children,
      ...props
    },
    ref
  ) => {
    const { isMobile, state, openMobile, setOpenMobile } = useSidebar()

    if (collapsible === "none") {
      return (
        <div
          className={cn(
            "flex h-full w-[--sidebar-width] flex-col bg-sidebar text-sidebar-foreground",
            className
          )}
          ref={ref}
          {...props}
        >
          {children}
        </div>
      )
    }

    if (isMobile) {
      return (
        <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
          <SheetContent
            data-sidebar="sidebar"
            data-mobile="true"
            className="w-[--sidebar-width] bg-sidebar p-0 text-sidebar-foreground [&>button]:hidden"
            style={
              {
                "--sidebar-width": SIDEBAR_WIDTH_MOBILE,
              } as React.CSSProperties
            }
            side={side}
          >
            <SheetHeader className="sr-only">
              <SheetTitle>Sidebar</SheetTitle>
              <SheetDescription>Displays the mobile sidebar.</SheetDescription>
            </SheetHeader>
            <div className="flex h-full w-full flex-col">{children}</div>
          </SheetContent>
        </Sheet>
      )
    }

    return (
      <div
        ref={ref}
        className="group peer hidden text-sidebar-foreground md:block"
        data-state={state}
        data-collapsible={state === "collapsed" ? collapsible : ""}
        data-variant={variant}
        data-side={side}
      >
        {/* This is what handles the sidebar gap on desktop */}
        <div
          className={cn(
            "relative w-[--sidebar-width] bg-transparent transition-[width] duration-200 ease-linear",
            "group-data-[collapsible=offcanvas]:w-0",
            "group-data-[side=right]:rotate-180",
            variant === "floating" || variant === "inset"
              ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4))]"
              : "group-data-[collapsible=icon]:w-[--sidebar-width-icon]"
          )}
        />
        <div
          className={cn(
            "fixed inset-y-0 z-10 hidden h-svh w-[--sidebar-width] transition-[left,right,width] duration-200 ease-linear md:flex",
            side === "left"
              ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]"
              : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
            // Adjust the padding for floating and inset variants.
            variant === "floating" || variant === "inset"
              ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4)_+2px)]"
              : "group-data-[collapsible=icon]:w-[--sidebar-width-icon] group-data-[side=left]:border-r group-data-[side=right]:border-l",
            className
          )}
          {...props}
        >
          <div
            data-sidebar="sidebar"
            className="flex h-full w-full flex-col bg-sidebar group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:border-sidebar-border group-data-[variant=floating]:shadow"
          >
            {children}
          </div>
        </div>
      </div>
    )
  }
)
Sidebar.displayName = "Sidebar"

const SidebarTrigger = React.forwardRef<
  React.ElementRef<typeof Button>,
  React.ComponentProps<typeof Button>
>(({ className, onClick, ...props }, ref) => {
  const { toggleSidebar } = useSidebar()

  return (
    <Button
      ref={ref}
      data-sidebar="trigger"
      variant="ghost"
      size="icon"
      className={cn("h-7 w-7", className)}
      onClick={(event) => {
        onClick?.(event)
        toggleSidebar()
      }}
      {...props}
    >
      <PanelLeft />
      <span className="sr-only">Toggle Sidebar</span>
    </Button>
  )
})
SidebarTrigger.displayName = "SidebarTrigger"

const SidebarRail = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button">
>(({ className, ...props }, ref) => {
  const { toggleSidebar } = useSidebar()

  return (
    <button
      ref={ref}
      data-sidebar="rail"
      aria-label="Toggle Sidebar"
      tabIndex={-1}
      onClick={toggleSidebar}
      title="Toggle Sidebar"
      className={cn(
        "absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] hover:after:bg-sidebar-border group-data-[side=left]:-right-4 group-data-[side=right]:left-0 sm:flex",
        "[[data-side=left]_&]:cursor-w-resize [[data-side=right]_&]:cursor-e-resize",
        "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
        "group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full group-data-[collapsible=offcanvas]:hover:bg-sidebar",
        "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
        "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
        className
      )}
      {...props}
    />
  )
})
SidebarRail.displayName = "SidebarRail"

const SidebarInset = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"main">
>(({ className, ...props }, ref) => {
  return (
    <main
      ref={ref}
      className={cn(
        "relative flex w-full flex-1 flex-col bg-background",
        "md:peer-data-[variant=inset]:m-2 md:peer-data-[state=collapsed]:peer-data-[variant=inset]:ml-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow",
        className
      )}
      {...props}
    />
  )
})
SidebarInset.displayName = "SidebarInset"

const SidebarInput = React.forwardRef<
  React.ElementRef<typeof Input>,
  React.ComponentProps<typeof Input>
>(({ className, ...props }, ref) => {
  return (
    <Input
      ref={ref}
      data-sidebar="input"
      className={cn(
        "h-8 w-full bg-background shadow-none focus-visible:ring-2 focus-visible:ring-sidebar-ring",
        className
      )}
      {...props}
    />
  )
})
SidebarInput.displayName = "SidebarInput"

const SidebarHeader = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="header"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
})
SidebarHeader.displayName = "SidebarHeader"

const SidebarFooter = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="footer"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
})
SidebarFooter.displayName = "SidebarFooter"

const SidebarSeparator = React.forwardRef<
  React.ElementRef<typeof Separator>,
  React.ComponentProps<typeof Separator>
>(({ className, ...props }, ref) => {
  return (
    <Separator
      ref={ref}
      data-sidebar="separator"
      className={cn("mx-2 w-auto bg-sidebar-border", className)}
      {...props}
    />
  )
})
SidebarSeparator.displayName = "SidebarSeparator"

const SidebarContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="content"
      className={cn(
        "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarContent.displayName = "SidebarContent"

const SidebarGroup = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="group"
      className={cn("relative flex w-full min-w-0 flex-col p-2", className)}
      {...props}
    />
  )
})
SidebarGroup.displayName = "SidebarGroup"

const SidebarGroupLabel = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & { asChild?: boolean }
>(({ className, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "div"

  return (
    <Comp
      ref={ref}
      data-sidebar="group-label"
      className={cn(
        "flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium text-sidebar-foreground/70 outline-none ring-sidebar-ring transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
        className
      )}
      {...props}
    />
  )
})
SidebarGroupLabel.displayName = "SidebarGroupLabel"

const SidebarGroupAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & { asChild?: boolean }
>(({ className, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      ref={ref}
      data-sidebar="group-action"
      className={cn(
        "absolute right-3 top-3.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarGroupAction.displayName = "SidebarGroupAction"

const SidebarGroupContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-sidebar="group-content"
    className={cn("w-full text-sm", className)}
    {...props}
  />
))
SidebarGroupContent.displayName = "SidebarGroupContent"

const SidebarMenu = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    data-sidebar="menu"
    className={cn("flex w-full min-w-0 flex-col gap-1", className)}
    {...props}
  />
))
SidebarMenu.displayName = "SidebarMenu"

const SidebarMenuItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ className, ...props }, ref) => (
  <li
    ref={ref}
    data-sidebar="menu-item"
    className={cn("group/menu-item relative", className)}
    {...props}
  />
))
SidebarMenuItem.displayName = "SidebarMenuItem"

const sidebarMenuButtonVariants = cva(
  "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-none ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-[[data-sidebar=menu-action]]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:!size-8 group-data-[collapsible=icon]:!p-2 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
        outline:
          "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]",
      },
      size: {
        default: "h-8 text-sm",
        sm: "h-7 text-xs",
        lg: "h-12 text-sm group-data-[collapsible=icon]:!p-0",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

const SidebarMenuButton = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean
    isActive?: boolean
    tooltip?: string | React.ComponentProps<typeof TooltipContent>
  } & VariantProps<typeof sidebarMenuButtonVariants>
>(
  (
    {
      asChild = false,
      isActive = false,
      variant = "default",
      size = "default",
      tooltip,
      className,
      ...props
    },
    ref
  ) => {
    const Comp = asChild ? Slot : "button"
    const { isMobile, state } = useSidebar()

    const button = (
      <Comp
        ref={ref}
        data-sidebar="menu-button"
        data-size={size}
        data-active={isActive}
        className={cn(sidebarMenuButtonVariants({ variant, size }), className)}
        {...props}
      />
    )

    if (!tooltip) {
      return button
    }

    if (typeof tooltip === "string") {
      tooltip = {
        children: tooltip,
      }
    }

    return (
      <Tooltip>
        <TooltipTrigger asChild>{button}</TooltipTrigger>
        <TooltipContent
          side="right"
          align="center"
          hidden={state !== "collapsed" || isMobile}
          {...tooltip}
        />
      </Tooltip>
    )
  }
)
SidebarMenuButton.displayName = "SidebarMenuButton"

const SidebarMenuAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean
    showOnHover?: boolean
  }
>(({ className, asChild = false, showOnHover = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-action"
      className={cn(
        "absolute right-1 top-1.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 peer-hover/menu-button:text-sidebar-accent-foreground [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        showOnHover &&
          "group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 peer-data-[active=true]/menu-button:text-sidebar-accent-foreground md:opacity-0",
        className
      )}
      {...props}
    />
  )
})
SidebarMenuAction.displayName = "SidebarMenuAction"

const SidebarMenuBadge = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-sidebar="menu-badge"
    className={cn(
      "pointer-events-none absolute right-1 flex h-5 min-w-5 select-none items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums text-sidebar-foreground",
      "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
      "peer-data-[size=sm]/menu-button:top-1",
      "peer-data-[size=default]/menu-button:top-1.5",
      "peer-data-[size=lg]/menu-button:top-2.5",
      "group-data-[collapsible=icon]:hidden",
      className
    )}
    {...props}
  />
))
SidebarMenuBadge.displayName = "SidebarMenuBadge"

const SidebarMenuSkeleton = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    showIcon?: boolean
  }
>(({ className, showIcon = false, ...props }, ref) => {
  // Random width between 50 to 90%.
  const width = React.useMemo(() => {
    return `${Math.floor(Math.random() * 40) + 50}%`
  }, [])

  return (
    <div
      ref={ref}
      data-sidebar="menu-skeleton"
      className={cn("flex h-8 items-center gap-2 rounded-md px-2", className)}
      {...props}
    >
      {showIcon && (
        <Skeleton
          className="size-4 rounded-md"
          data-sidebar="menu-skeleton-icon"
        />
      )}
      <Skeleton
        className="h-4 max-w-[--skeleton-width] flex-1"
        data-sidebar="menu-skeleton-text"
        style={
          {
            "--skeleton-width": width,
          } as React.CSSProperties
        }
      />
    </div>
  )
})
SidebarMenuSkeleton.displayName = "SidebarMenuSkeleton"

const SidebarMenuSub = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    data-sidebar="menu-sub"
    className={cn(
      "mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l border-sidebar-border px-2.5 py-0.5",
      "group-data-[collapsible=icon]:hidden",
      className
    )}
    {...props}
  />
))
SidebarMenuSub.displayName = "SidebarMenuSub"

const SidebarMenuSubItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ ...props }, ref) => <li ref={ref} {...props} />)
SidebarMenuSubItem.displayName = "SidebarMenuSubItem"

const SidebarMenuSubButton = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentProps<"a"> & {
    asChild?: boolean
    size?: "sm" | "md"
    isActive?: boolean
  }
>(({ asChild = false, size = "md", isActive, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-sub-button"
      data-size={size}
      data-active={isActive}
      className={cn(
        "flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 text-sidebar-foreground outline-none ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 [&>svg]:text-sidebar-accent-foreground",
        "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
        size === "sm" && "text-xs",
        size === "md" && "text-sm",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarMenuSubButton.displayName = "SidebarMenuSubButton"

export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  useSidebar,
}
</file>

<file path="client/src/components/ui/skeleton.tsx">
import { cn } from "@/lib/utils"

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-muted", className)}
      {...props}
    />
  )
}

export { Skeleton }
</file>

<file path="client/src/components/ui/slider.tsx">
import * as React from "react"
import * as SliderPrimitive from "@radix-ui/react-slider"

import { cn } from "@/lib/utils"

const Slider = React.forwardRef<
  React.ElementRef<typeof SliderPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>
>(({ className, ...props }, ref) => (
  <SliderPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex w-full touch-none select-none items-center",
      className
    )}
    {...props}
  >
    <SliderPrimitive.Track className="relative h-2 w-full grow overflow-hidden rounded-full bg-secondary">
      <SliderPrimitive.Range className="absolute h-full bg-primary" />
    </SliderPrimitive.Track>
    <SliderPrimitive.Thumb className="block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50" />
  </SliderPrimitive.Root>
))
Slider.displayName = SliderPrimitive.Root.displayName

export { Slider }
</file>

<file path="client/src/components/ui/switch.tsx">
import * as React from "react"
import * as SwitchPrimitives from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
))
Switch.displayName = SwitchPrimitives.Root.displayName

export { Switch }
</file>

<file path="client/src/components/ui/table.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
))
Table.displayName = "Table"

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
))
TableHeader.displayName = "TableHeader"

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
))
TableBody.displayName = "TableBody"

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className
    )}
    {...props}
  />
))
TableFooter.displayName = "TableFooter"

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className
    )}
    {...props}
  />
))
TableRow.displayName = "TableRow"

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0",
      className
    )}
    {...props}
  />
))
TableHead.displayName = "TableHead"

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn("p-4 align-middle [&:has([role=checkbox])]:pr-0", className)}
    {...props}
  />
))
TableCell.displayName = "TableCell"

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
))
TableCaption.displayName = "TableCaption"

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}
</file>

<file path="client/src/components/ui/tabs.tsx">
import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }
</file>

<file path="client/src/components/ui/textarea.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

const Textarea = React.forwardRef<
  HTMLTextAreaElement,
  React.ComponentProps<"textarea">
>(({ className, ...props }, ref) => {
  return (
    <textarea
      className={cn(
        "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      ref={ref}
      {...props}
    />
  )
})
Textarea.displayName = "Textarea"

export { Textarea }
</file>

<file path="client/src/components/ui/toast.tsx">
import * as React from "react"
import * as ToastPrimitives from "@radix-ui/react-toast"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const ToastProvider = ToastPrimitives.Provider

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className
    )}
    {...props}
  />
))
ToastViewport.displayName = ToastPrimitives.Viewport.displayName

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive:
          "destructive group border-destructive bg-destructive text-destructive-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  )
})
Toast.displayName = ToastPrimitives.Root.displayName

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      className
    )}
    {...props}
  />
))
ToastAction.displayName = ToastPrimitives.Action.displayName

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
))
ToastClose.displayName = ToastPrimitives.Close.displayName

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold", className)}
    {...props}
  />
))
ToastTitle.displayName = ToastPrimitives.Title.displayName

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-sm opacity-90", className)}
    {...props}
  />
))
ToastDescription.displayName = ToastPrimitives.Description.displayName

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>

type ToastActionElement = React.ReactElement<typeof ToastAction>

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
}
</file>

<file path="client/src/components/ui/toaster.tsx">
import { useToast } from "@/hooks/use-toast"
import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from "@/components/ui/toast"

export function Toaster() {
  const { toasts } = useToast()

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        )
      })}
      <ToastViewport />
    </ToastProvider>
  )
}
</file>

<file path="client/src/components/ui/toggle-group.tsx">
"use client"

import * as React from "react"
import * as ToggleGroupPrimitive from "@radix-ui/react-toggle-group"
import { type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"
import { toggleVariants } from "@/components/ui/toggle"

const ToggleGroupContext = React.createContext<
  VariantProps<typeof toggleVariants>
>({
  size: "default",
  variant: "default",
})

const ToggleGroup = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, children, ...props }, ref) => (
  <ToggleGroupPrimitive.Root
    ref={ref}
    className={cn("flex items-center justify-center gap-1", className)}
    {...props}
  >
    <ToggleGroupContext.Provider value={{ variant, size }}>
      {children}
    </ToggleGroupContext.Provider>
  </ToggleGroupPrimitive.Root>
))

ToggleGroup.displayName = ToggleGroupPrimitive.Root.displayName

const ToggleGroupItem = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Item> &
    VariantProps<typeof toggleVariants>
>(({ className, children, variant, size, ...props }, ref) => {
  const context = React.useContext(ToggleGroupContext)

  return (
    <ToggleGroupPrimitive.Item
      ref={ref}
      className={cn(
        toggleVariants({
          variant: context.variant || variant,
          size: context.size || size,
        }),
        className
      )}
      {...props}
    >
      {children}
    </ToggleGroupPrimitive.Item>
  )
})

ToggleGroupItem.displayName = ToggleGroupPrimitive.Item.displayName

export { ToggleGroup, ToggleGroupItem }
</file>

<file path="client/src/components/ui/toggle.tsx">
import * as React from "react"
import * as TogglePrimitive from "@radix-ui/react-toggle"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const toggleVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0 gap-2",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline:
          "border border-input bg-transparent hover:bg-accent hover:text-accent-foreground",
      },
      size: {
        default: "h-10 px-3 min-w-10",
        sm: "h-9 px-2.5 min-w-9",
        lg: "h-11 px-5 min-w-11",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

const Toggle = React.forwardRef<
  React.ElementRef<typeof TogglePrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof TogglePrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, ...props }, ref) => (
  <TogglePrimitive.Root
    ref={ref}
    className={cn(toggleVariants({ variant, size, className }))}
    {...props}
  />
))

Toggle.displayName = TogglePrimitive.Root.displayName

export { Toggle, toggleVariants }
</file>

<file path="client/src/components/ui/tooltip.tsx">
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-tooltip-content-transform-origin]",
      className
    )}
    {...props}
  />
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }
</file>

<file path="client/src/components/ChangePasswordForm.tsx">
import { useState } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { Button } from "@/components/ui/button";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { useToast } from "@/hooks/use-toast";
import { apiRequest } from "@/lib/queryClient";
import { Lock, Eye, EyeOff } from "lucide-react";

const changePasswordSchema = z.object({
  currentPassword: z.string().min(1, "Current password is required"),
  newPassword: z.string().min(6, "New password must be at least 6 characters"),
  confirmPassword: z.string().min(1, "Please confirm your new password"),
}).refine((data) => data.newPassword === data.confirmPassword, {
  message: "New passwords don't match",
  path: ["confirmPassword"],
});

type ChangePasswordForm = z.infer<typeof changePasswordSchema>;

export default function ChangePasswordForm() {
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [showCurrentPassword, setShowCurrentPassword] = useState(false);
  const [showNewPassword, setShowNewPassword] = useState(false);
  const [showConfirmPassword, setShowConfirmPassword] = useState(false);
  const { toast } = useToast();

  const form = useForm<ChangePasswordForm>({
    resolver: zodResolver(changePasswordSchema),
    defaultValues: {
      currentPassword: "",
      newPassword: "",
      confirmPassword: "",
    },
  });

  const onSubmit = async (data: ChangePasswordForm) => {
    setIsSubmitting(true);
    
    try {
      const response = await fetch('/api/change-password', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'include',
        body: JSON.stringify({
          currentPassword: data.currentPassword,
          newPassword: data.newPassword,
        }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Failed to change password');
      }

      toast({
        title: "Password Changed Successfully",
        description: "Your password has been updated.",
      });

      // Reset form after successful change
      form.reset();
    } catch (error: any) {
      toast({
        title: "Password Change Failed",
        description: error.message || "Failed to change password. Please try again.",
        variant: "destructive",
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <div className="max-w-md space-y-6">
      <div className="flex items-center space-x-2 text-sm text-gray-600">
        <Lock className="w-4 h-4" />
        <span>Change Your Password</span>
      </div>
      
      <Form {...form}>
        <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
          <FormField
            control={form.control}
            name="currentPassword"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Current Password</FormLabel>
                <FormControl>
                  <div className="relative">
                    <Input
                      type={showCurrentPassword ? "text" : "password"}
                      placeholder="Enter your current password"
                      {...field}
                    />
                    <Button
                      type="button"
                      variant="ghost"
                      size="sm"
                      className="absolute right-0 top-0 h-full px-3 py-2 hover:bg-transparent"
                      onClick={() => setShowCurrentPassword(!showCurrentPassword)}
                    >
                      {showCurrentPassword ? (
                        <EyeOff className="h-4 w-4" />
                      ) : (
                        <Eye className="h-4 w-4" />
                      )}
                    </Button>
                  </div>
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />

          <FormField
            control={form.control}
            name="newPassword"
            render={({ field }) => (
              <FormItem>
                <FormLabel>New Password</FormLabel>
                <FormControl>
                  <div className="relative">
                    <Input
                      type={showNewPassword ? "text" : "password"}
                      placeholder="Enter your new password"
                      {...field}
                    />
                    <Button
                      type="button"
                      variant="ghost"
                      size="sm"
                      className="absolute right-0 top-0 h-full px-3 py-2 hover:bg-transparent"
                      onClick={() => setShowNewPassword(!showNewPassword)}
                    >
                      {showNewPassword ? (
                        <EyeOff className="h-4 w-4" />
                      ) : (
                        <Eye className="h-4 w-4" />
                      )}
                    </Button>
                  </div>
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />

          <FormField
            control={form.control}
            name="confirmPassword"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Confirm New Password</FormLabel>
                <FormControl>
                  <div className="relative">
                    <Input
                      type={showConfirmPassword ? "text" : "password"}
                      placeholder="Confirm your new password"
                      {...field}
                    />
                    <Button
                      type="button"
                      variant="ghost"
                      size="sm"
                      className="absolute right-0 top-0 h-full px-3 py-2 hover:bg-transparent"
                      onClick={() => setShowConfirmPassword(!showConfirmPassword)}
                    >
                      {showConfirmPassword ? (
                        <EyeOff className="h-4 w-4" />
                      ) : (
                        <Eye className="h-4 w-4" />
                      )}
                    </Button>
                  </div>
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />

          <Button 
            type="submit" 
            disabled={isSubmitting}
            className="w-full"
          >
            {isSubmitting ? "Changing Password..." : "Change Password"}
          </Button>
        </form>
      </Form>

      <div className="text-xs text-gray-500 space-y-1">
        <p>• Password must be at least 6 characters long</p>
        <p>• For password reset assistance, contact hello@tvtantrum.com</p>
      </div>
    </div>
  );
}
</file>

<file path="client/src/components/ColorPaletteCustomizer.tsx">
import React, { useState, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { 
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from '@/components/ui/dialog';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from '@/components/ui/tooltip';
import { Paintbrush, Check, Undo2 } from 'lucide-react';
import { useToast } from '@/hooks/use-toast';

// Define preset color themes
const colorPresets = {
  teal: {
    primary: '#285161',
    secondary: '#FFC107',
    accent: '#10B981',
  },
  purple: {
    primary: '#7C3AED',
    secondary: '#FFC107',
    accent: '#10B981',
  },
  blue: {
    primary: '#2563EB',
    secondary: '#F59E0B',
    accent: '#10B981',
  },
  green: {
    primary: '#047857',
    secondary: '#F59E0B',
    accent: '#6366F1',
  },
  red: {
    primary: '#B91C1C',
    secondary: '#FBBF24',
    accent: '#06B6D4',
  },
};

// Convert hex to HSL for CSS variables
function hexToHSL(hex: string) {
  // Remove the # if present
  hex = hex.replace(/^#/, '');
  
  // Parse the hex values
  let r = parseInt(hex.substring(0, 2), 16) / 255;
  let g = parseInt(hex.substring(2, 4), 16) / 255;
  let b = parseInt(hex.substring(4, 6), 16) / 255;
  
  // Find min and max values
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  
  // Calculate lightness
  let l = (max + min) / 2;
  
  let h = 0;
  let s = 0;
  
  if (max !== min) {
    // Calculate saturation
    s = l > 0.5 ? (max - min) / (2 - max - min) : (max - min) / (max + min);
    
    // Calculate hue
    if (max === r) {
      h = (g - b) / (max - min) + (g < b ? 6 : 0);
    } else if (max === g) {
      h = (b - r) / (max - min) + 2;
    } else {
      h = (r - g) / (max - min) + 4;
    }
    h = h * 60;
  }
  
  // Round values
  h = Math.round(h);
  s = Math.round(s * 100);
  l = Math.round(l * 100);
  
  return { h, s, l };
}

// Interface for our color palette
interface ColorPalette {
  primary: string;
  secondary: string;
  accent: string;
}

export default function ColorPaletteCustomizer() {
  const { toast } = useToast();
  // Get stored colors from localStorage or use defaults
  const storedColors = localStorage.getItem('tvtantrumColorPalette');
  
  const [isOpen, setIsOpen] = useState(false);
  const [selectedTab, setSelectedTab] = useState('presets');
  const [selectedPreset, setSelectedPreset] = useState<string | null>(null);
  const [colorPalette, setColorPalette] = useState<ColorPalette>(
    storedColors 
      ? JSON.parse(storedColors) 
      : {
          primary: '#285161',   // Default teal
          secondary: '#FFC107', // Default yellow/gold
          accent: '#10B981',    // Default green
        }
  );
  
  // Apply colors to CSS variables
  const applyColorPalette = (palette: ColorPalette) => {
    // Convert HEX to HSL for CSS variables
    const primaryHSL = hexToHSL(palette.primary);
    const secondaryHSL = hexToHSL(palette.secondary);
    const accentHSL = hexToHSL(palette.accent);
    
    // Apply to CSS variables
    document.documentElement.style.setProperty('--primary', `${primaryHSL.h} ${primaryHSL.s}% ${primaryHSL.l}%`);
    document.documentElement.style.setProperty('--secondary', `${secondaryHSL.h} ${secondaryHSL.s}% ${secondaryHSL.l}%`);
    document.documentElement.style.setProperty('--accent', `${accentHSL.h} ${accentHSL.s}% ${accentHSL.l}%`);
    document.documentElement.style.setProperty('--chart-1', `${primaryHSL.h} ${primaryHSL.s}% ${primaryHSL.l}%`);
    
    // Save to localStorage
    localStorage.setItem('tvtantrumColorPalette', JSON.stringify(palette));
  };
  
  // Apply colors on component mount
  useEffect(() => {
    applyColorPalette(colorPalette);
  }, []);
  
  // Handle preset selection
  const selectPreset = (presetName: string) => {
    setSelectedPreset(presetName);
    const newPalette = colorPresets[presetName as keyof typeof colorPresets];
    setColorPalette(newPalette);
  };
  
  // Handle custom color change
  const handleColorChange = (colorType: keyof ColorPalette, value: string) => {
    setSelectedPreset(null); // Clear preset selection when custom colors are used
    setColorPalette(prev => ({
      ...prev,
      [colorType]: value
    }));
  };
  
  // Apply the selected colors
  const applyColors = () => {
    applyColorPalette(colorPalette);
    setIsOpen(false);
    
    toast({
      title: "Colors updated!",
      description: "Your custom color palette has been applied.",
    });
  };
  
  // Reset to default colors
  const resetToDefault = () => {
    const defaultPalette = colorPresets.teal;
    setColorPalette(defaultPalette);
    setSelectedPreset('teal');
    
    // This will update the preview, but not apply until "Apply" is clicked
  };
  
  return (
    <Dialog open={isOpen} onOpenChange={setIsOpen}>
      <TooltipProvider>
        <Tooltip>
          <TooltipTrigger asChild>
            <Button 
              variant="outline" 
              size="icon" 
              onClick={() => setIsOpen(true)}
              className="fixed bottom-4 right-4 rounded-full shadow-lg z-50"
            >
              <Paintbrush className="h-5 w-5" />
            </Button>
          </TooltipTrigger>
          <TooltipContent>
            <p>Customize Colors</p>
          </TooltipContent>
        </Tooltip>
      </TooltipProvider>
      
      <DialogContent className="sm:max-w-md">
        <DialogHeader>
          <DialogTitle>Customize Website Colors</DialogTitle>
          <DialogDescription>
            Personalize the website's color scheme to suit your preferences.
          </DialogDescription>
        </DialogHeader>
        
        <Tabs value={selectedTab} onValueChange={setSelectedTab} className="mt-4">
          <TabsList className="grid w-full grid-cols-2">
            <TabsTrigger value="presets">Color Presets</TabsTrigger>
            <TabsTrigger value="custom">Custom Colors</TabsTrigger>
          </TabsList>
          
          <TabsContent value="presets" className="py-4">
            <div className="grid grid-cols-3 gap-3">
              {Object.entries(colorPresets).map(([name, colors]) => (
                <button
                  key={name}
                  className={`relative flex flex-col items-center p-2 rounded-md transition-all ${
                    selectedPreset === name ? 'ring-2 ring-primary' : 'hover:bg-gray-100'
                  }`}
                  onClick={() => selectPreset(name)}
                >
                  <div className="flex gap-1 mb-2">
                    <div 
                      className="w-5 h-5 rounded-full" 
                      style={{ backgroundColor: colors.primary }}
                    />
                    <div 
                      className="w-5 h-5 rounded-full" 
                      style={{ backgroundColor: colors.secondary }}
                    />
                    <div 
                      className="w-5 h-5 rounded-full" 
                      style={{ backgroundColor: colors.accent }}
                    />
                  </div>
                  <span className="text-xs capitalize font-bold">{name}</span>
                  {selectedPreset === name && (
                    <div className="absolute top-1 right-1">
                      <Check className="h-3 w-3 text-primary" />
                    </div>
                  )}
                </button>
              ))}
            </div>
          </TabsContent>
          
          <TabsContent value="custom" className="py-4">
            <div className="space-y-4">
              <div className="space-y-2">
                <Label htmlFor="primary-color">Primary Color</Label>
                <div className="flex items-center gap-2">
                  <div 
                    className="w-8 h-8 rounded-md" 
                    style={{ backgroundColor: colorPalette.primary }}
                  />
                  <Input
                    id="primary-color"
                    type="text"
                    value={colorPalette.primary}
                    onChange={(e) => handleColorChange('primary', e.target.value)}
                    placeholder="#285161"
                  />
                  <Input 
                    type="color"
                    value={colorPalette.primary}
                    onChange={(e) => handleColorChange('primary', e.target.value)}
                    className="w-10 h-10 p-0 overflow-hidden"
                  />
                </div>
              </div>
              
              <div className="space-y-2">
                <Label htmlFor="secondary-color">Secondary Color</Label>
                <div className="flex items-center gap-2">
                  <div 
                    className="w-8 h-8 rounded-md" 
                    style={{ backgroundColor: colorPalette.secondary }}
                  />
                  <Input
                    id="secondary-color"
                    type="text"
                    value={colorPalette.secondary}
                    onChange={(e) => handleColorChange('secondary', e.target.value)}
                    placeholder="#FFC107"
                  />
                  <Input 
                    type="color"
                    value={colorPalette.secondary}
                    onChange={(e) => handleColorChange('secondary', e.target.value)}
                    className="w-10 h-10 p-0 overflow-hidden"
                  />
                </div>
              </div>
              
              <div className="space-y-2">
                <Label htmlFor="accent-color">Accent Color</Label>
                <div className="flex items-center gap-2">
                  <div 
                    className="w-8 h-8 rounded-md" 
                    style={{ backgroundColor: colorPalette.accent }}
                  />
                  <Input
                    id="accent-color"
                    type="text"
                    value={colorPalette.accent}
                    onChange={(e) => handleColorChange('accent', e.target.value)}
                    placeholder="#10B981"
                  />
                  <Input 
                    type="color"
                    value={colorPalette.accent}
                    onChange={(e) => handleColorChange('accent', e.target.value)}
                    className="w-10 h-10 p-0 overflow-hidden"
                  />
                </div>
              </div>
            </div>
          </TabsContent>
        </Tabs>
        
        <div className="mt-4 p-4 bg-gray-50 rounded-md">
          <h4 className="font-medium mb-2">Preview</h4>
          <div className="flex gap-2">
            <div className="flex-1 p-2 rounded-md text-white text-center font-medium" style={{ backgroundColor: colorPalette.primary }}>Primary</div>
            <div className="flex-1 p-2 rounded-md text-white text-center font-medium" style={{ backgroundColor: colorPalette.secondary }}>Secondary</div>
            <div className="flex-1 p-2 rounded-md text-white text-center font-medium" style={{ backgroundColor: colorPalette.accent }}>Accent</div>
          </div>
        </div>
        
        <DialogFooter className="flex justify-between items-center mt-4">
          <Button
            type="button"
            variant="outline"
            onClick={resetToDefault}
            className="gap-1"
          >
            <Undo2 className="h-4 w-4" /> Reset
          </Button>
          <div className="flex gap-2">
            <Button type="button" variant="outline" onClick={() => setIsOpen(false)}>
              Cancel
            </Button>
            <Button type="button" onClick={applyColors}>
              Apply Colors
            </Button>
          </div>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="client/src/components/FavoriteRegistrationModal.tsx">
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { CheckCircle2 } from "lucide-react";
import { useLocation } from "wouter";

interface FavoriteRegistrationModalProps {
  isOpen: boolean;
  onClose: () => void;
  showName?: string;
}

export function FavoriteRegistrationModal({ isOpen, onClose, showName }: FavoriteRegistrationModalProps) {
  const [, navigate] = useLocation();

  const handleRegister = () => {
    onClose();
    navigate("/auth");
  };

  const handleMaybeLater = () => {
    onClose();
  };

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="sm:max-w-md">
        <DialogHeader>
          <DialogTitle className="text-lg font-semibold">Save to Favorites</DialogTitle>
          <DialogDescription className="text-sm text-muted-foreground">
            {showName ? `To save "${showName}" to your favorites, ` : "To save shows to your favorites, "}
            you'll need to create a free account.
          </DialogDescription>
        </DialogHeader>
        
        <div className="space-y-3 py-4">
          <h4 className="font-medium text-sm">With a free account, you can:</h4>
          <div className="space-y-2">
            <div className="flex items-start space-x-2">
              <CheckCircle2 className="h-4 w-4 text-primary mt-0.5 flex-shrink-0" />
              <p className="text-sm">Save favorites and create watchlists</p>
            </div>
            <div className="flex items-start space-x-2">
              <CheckCircle2 className="h-4 w-4 text-primary mt-0.5 flex-shrink-0" />
              <p className="text-sm">Get personalized recommendations</p>
            </div>
            <div className="flex items-start space-x-2">
              <CheckCircle2 className="h-4 w-4 text-primary mt-0.5 flex-shrink-0" />
              <p className="text-sm">Access research summaries</p>
            </div>
            <div className="flex items-start space-x-2">
              <CheckCircle2 className="h-4 w-4 text-primary mt-0.5 flex-shrink-0" />
              <p className="text-sm">Leave reviews</p>
            </div>
          </div>
        </div>

        <DialogFooter className="flex flex-col sm:flex-row gap-2">
          <Button 
            variant="outline" 
            onClick={handleMaybeLater}
            className="w-full sm:w-auto"
          >
            Maybe Later
          </Button>
          <Button 
            onClick={handleRegister}
            className="w-full sm:w-auto"
          >
            Yes, Register for Free
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="client/src/components/FileUploader.tsx">
import React, { useState, useRef } from 'react';
import { UploadCloud, CheckCircle, AlertCircle } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Progress } from '@/components/ui/progress';

interface FileUploaderProps {
  onUploadComplete: (url: string) => void;
  onUploadStart?: () => void;
  onUploadError?: (error: string) => void;
  folder?: string;
  allowedTypes?: string[];
  maxSizeMB?: number;
}

const FileUploader: React.FC<FileUploaderProps> = ({
  onUploadComplete,
  onUploadStart,
  onUploadError,
  folder = 'uploads',
  allowedTypes = ['image/jpeg', 'image/png', 'image/webp', 'image/gif'],
  maxSizeMB = 5
}) => {
  const [isUploading, setIsUploading] = useState(false);
  const [uploadProgress, setUploadProgress] = useState(0);
  const [uploadStatus, setUploadStatus] = useState<'idle' | 'uploading' | 'success' | 'error'>('idle');
  const [statusMessage, setStatusMessage] = useState('');
  const fileInputRef = useRef<HTMLInputElement>(null);

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    // Validate file type
    if (!allowedTypes.includes(file.type)) {
      setUploadStatus('error');
      setStatusMessage(`Invalid file type. Allowed types: ${allowedTypes.join(', ')}`);
      if (onUploadError) onUploadError(`Invalid file type. Allowed types: ${allowedTypes.join(', ')}`);
      return;
    }

    // Validate file size
    const maxSizeBytes = maxSizeMB * 1024 * 1024;
    if (file.size > maxSizeBytes) {
      setUploadStatus('error');
      setStatusMessage(`File too large. Maximum size: ${maxSizeMB}MB`);
      if (onUploadError) onUploadError(`File too large. Maximum size: ${maxSizeMB}MB`);
      return;
    }

    // Start upload
    setIsUploading(true);
    setUploadStatus('uploading');
    setUploadProgress(0);
    if (onUploadStart) onUploadStart();

    const formData = new FormData();
    formData.append('file', file);
    formData.append('folder', folder);

    // Use XMLHttpRequest for better progress tracking
    const xhr = new XMLHttpRequest();
    
    xhr.upload.addEventListener('progress', (event) => {
      if (event.lengthComputable) {
        const progress = Math.round((event.loaded / event.total) * 100);
        setUploadProgress(progress);
      }
    });

    xhr.onreadystatechange = function() {
      if (xhr.readyState === 4) {
        if (xhr.status === 200) {
          try {
            const response = JSON.parse(xhr.responseText);
            console.log('Upload response:', response);
            if (response.url) {
              setUploadStatus('success');
              setStatusMessage('File uploaded successfully');
              onUploadComplete(response.url);
            } else {
              throw new Error('No URL in response');
            }
          } catch (error) {
            console.error('Error parsing response:', error);
            setUploadStatus('error');
            setStatusMessage('Failed to parse server response');
            if (onUploadError) onUploadError('Failed to parse server response');
          }
        } else {
          console.error('Upload failed:', xhr.status, xhr.statusText);
          setUploadStatus('error');
          setStatusMessage(`Upload failed: ${xhr.statusText || 'Server error'}`);
          if (onUploadError) onUploadError(`Upload failed: ${xhr.statusText || 'Server error'}`);
        }
        setIsUploading(false);
      }
    };

    xhr.open('POST', '/api/upload', true);
    xhr.send(formData);
  };

  const triggerFileInput = () => {
    fileInputRef.current?.click();
  };

  return (
    <div className="w-full">
      <input
        type="file"
        ref={fileInputRef}
        onChange={handleFileChange}
        accept={allowedTypes.join(',')}
        className="hidden"
      />
      
      <div className="border-2 border-dashed border-gray-300 rounded-lg p-6 text-center hover:bg-gray-50 transition cursor-pointer" onClick={triggerFileInput}>
        {uploadStatus === 'idle' && (
          <>
            <UploadCloud className="mx-auto h-12 w-12 text-gray-400" />
            <div className="mt-2 text-sm text-gray-600">
              <p className="font-medium">Click to upload or drag and drop</p>
              <p className="text-xs">
                {allowedTypes.map(type => type.replace('image/', '.')).join(', ')} up to {maxSizeMB}MB
              </p>
            </div>
          </>
        )}
        
        {uploadStatus === 'uploading' && (
          <div className="space-y-2">
            <div className="animate-pulse flex justify-center">
              <UploadCloud className="h-12 w-12 text-primary" />
            </div>
            <p className="text-sm text-gray-600">Uploading file...</p>
            <Progress value={uploadProgress} className="h-2 w-full" />
            <p className="text-xs text-gray-500">{uploadProgress}%</p>
          </div>
        )}
        
        {uploadStatus === 'success' && (
          <div className="space-y-2">
            <CheckCircle className="mx-auto h-12 w-12 text-green-500" />
            <p className="text-sm text-green-600">{statusMessage}</p>
            <Button 
              variant="outline" 
              size="sm" 
              className="mt-2"
              onClick={(e) => {
                e.stopPropagation();
                setUploadStatus('idle');
                if (fileInputRef.current) fileInputRef.current.value = '';
              }}
            >
              Upload another
            </Button>
          </div>
        )}
        
        {uploadStatus === 'error' && (
          <div className="space-y-2">
            <AlertCircle className="mx-auto h-12 w-12 text-red-500" />
            <p className="text-sm text-red-600">{statusMessage}</p>
            <Button 
              variant="outline" 
              size="sm" 
              className="mt-2"
              onClick={(e) => {
                e.stopPropagation();
                setUploadStatus('idle');
                if (fileInputRef.current) fileInputRef.current.value = '';
              }}
            >
              Try again
            </Button>
          </div>
        )}
      </div>
    </div>
  );
};

export default FileUploader;
</file>

<file path="client/src/components/GhlScriptLoader.tsx">
import { useEffect, useRef } from 'react';

export default function GhlScriptLoader() {
  const scriptLoaded = useRef(false);
  
  useEffect(() => {
    if (scriptLoaded.current) return;
    
    const script = document.createElement('script');
    script.src = 'https://link.msgsndr.com/js/form_embed.js';
    script.async = true;
    script.onload = () => {
      scriptLoaded.current = true;
      
      // Re-initialize the form if needed
      if (window.ghl && window.ghl.loadEmbed) {
        window.ghl.loadEmbed();
      }
    };
    
    document.body.appendChild(script);
    
    return () => {
      document.body.removeChild(script);
    };
  }, []);
  
  return null;
}

// Add this to global.d.ts or a similar file
declare global {
  interface Window {
    ghl?: {
      loadEmbed: () => void;
      [key: string]: any;
    };
  }
}
</file>

<file path="client/src/components/image-upload.tsx">
import { useState, useRef } from 'react';
import { Button } from '@/components/ui/button';
import { Label } from '@/components/ui/label';
import { Upload, Image as ImageIcon, Loader2 } from 'lucide-react';
import { useToast } from '@/hooks/use-toast';

interface ImageUploadProps {
  imageUrl: string | null;
  onImageChange: (imageUrl: string) => void;
  className?: string;
}

export function ImageUpload({ imageUrl, onImageChange, className = '' }: ImageUploadProps) {
  const [isUploading, setIsUploading] = useState(false);
  const [uploadPreview, setUploadPreview] = useState<string | null>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const { toast } = useToast();

  const handleFileSelect = () => {
    fileInputRef.current?.click();
  };

  const handleFileChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    // Check file type
    if (!file.type.startsWith('image/')) {
      toast({
        title: 'Invalid file type',
        description: 'Please select an image file (JPEG, PNG, etc.)',
        variant: 'destructive',
      });
      return;
    }

    // Check file size (max 5MB)
    if (file.size > 5 * 1024 * 1024) {
      toast({
        title: 'File too large',
        description: 'Image must be less than 5MB',
        variant: 'destructive',
      });
      return;
    }

    // Show preview immediately
    const objectUrl = URL.createObjectURL(file);
    setUploadPreview(objectUrl);

    // Upload to server
    setIsUploading(true);
    try {
      const formData = new FormData();
      formData.append('image', file);

      const response = await fetch('/api/shows/upload-image', {
        method: 'POST',
        body: formData,
        credentials: 'include'
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(errorText || 'Failed to upload image');
      }

      const data = await response.json();
      
      // Use the optimized image path
      onImageChange(data.optimizedPath);
      
      toast({
        title: 'Image uploaded',
        description: 'Image has been uploaded and optimized successfully',
      });
    } catch (error) {
      console.error('Error uploading image:', error);
      // Revert preview on error
      setUploadPreview(null);
      toast({
        title: 'Upload failed',
        description: error instanceof Error ? error.message : 'Failed to upload image',
        variant: 'destructive',
      });
    } finally {
      setIsUploading(false);
      // Reset the input so the same file can be selected again if needed
      if (fileInputRef.current) {
        fileInputRef.current.value = '';
      }
    }
  };

  // Determine which image to display (preview, existing, or placeholder)
  const displayImage = uploadPreview || imageUrl;

  return (
    <div className={`space-y-4 ${className}`}>
      <div>
        <Label htmlFor="show-image" className="block mb-2">
          Show Image
        </Label>
        <div className="border rounded-md p-4 flex flex-col items-center justify-center bg-muted/20">
          <div className="relative w-full h-48 mb-4 flex items-center justify-center overflow-hidden bg-gray-50 rounded-md">
            {isUploading ? (
              <div className="flex flex-col items-center justify-center text-muted-foreground">
                <Loader2 className="h-10 w-10 animate-spin mb-2" />
                <p>Uploading and optimizing...</p>
              </div>
            ) : displayImage ? (
              <img
                src={displayImage}
                alt="Show preview"
                className="max-h-full object-contain"
                onError={() => {
                  setUploadPreview(null);
                  toast({
                    title: 'Image error',
                    description: 'Could not load the image',
                    variant: 'destructive',
                  });
                }}
              />
            ) : (
              <div className="flex flex-col items-center justify-center text-muted-foreground">
                <ImageIcon className="h-16 w-16 mb-2" />
                <p>No image selected</p>
              </div>
            )}
          </div>
          
          <input
            ref={fileInputRef}
            type="file"
            id="show-image"
            accept="image/*"
            className="hidden"
            onChange={handleFileChange}
          />
          
          <Button
            type="button"
            variant="outline"
            onClick={handleFileSelect}
            disabled={isUploading}
            className="flex items-center gap-2"
          >
            <Upload className="h-4 w-4" />
            {isUploading ? 'Uploading...' : 'Upload Image'}
          </Button>
          
          <p className="text-xs mt-2 text-muted-foreground text-center max-w-md">
            Upload a portrait-style image for the show (recommended ratio 3:4).
            The image will be automatically optimized for web display.
          </p>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="client/src/components/Leaderboard.tsx">
import React from 'react';
import { useQuery } from '@tanstack/react-query';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import { Badge } from '@/components/ui/badge';
import { Skeleton } from '@/components/ui/skeleton';

const Leaderboard = () => {
  const { data: users, isLoading } = useQuery({
    queryKey: ['/api/leaderboard'],
  });

  if (isLoading) {
    return (
      <Card className="w-full">
        <CardHeader>
          <CardTitle className="text-center">Leaderboard</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="space-y-4">
            {[...Array(5)].map((_, i) => (
              <div key={i} className="flex items-center gap-4">
                <div className="flex-shrink-0 font-bold text-gray-400 w-6 text-center">
                  {i + 1}
                </div>
                <Skeleton className="h-10 w-10 rounded-full" />
                <div className="flex-1">
                  <Skeleton className="h-4 w-24" />
                </div>
                <Skeleton className="h-6 w-16" />
              </div>
            ))}
          </div>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card className="w-full">
      <CardHeader>
        <CardTitle className="text-center">Leaderboard</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="space-y-4">
          {users?.slice(0, 5).map((user: any, index: number) => (
            <div key={user.id} className="flex items-center gap-4">
              <div className="flex-shrink-0 font-bold text-gray-400 w-6 text-center">
                {index + 1}
              </div>
              <Avatar>
                <AvatarImage src={user.profileImageUrl} alt={user.username} />
                <AvatarFallback>
                  {user.username?.slice(0, 2).toUpperCase() || 'U'}
                </AvatarFallback>
              </Avatar>
              <div className="flex-1">
                <div className="font-medium">{user.username}</div>
              </div>
              <Badge variant="secondary" className="ml-auto">
                {user.totalPoints} Points
              </Badge>
            </div>
          ))}
        </div>
      </CardContent>
    </Card>
  );
};

export default Leaderboard;
</file>

<file path="client/src/components/LoginForm.tsx">
import { useState } from "react";
import { zodResolver } from "@hookform/resolvers/zod";
import { useForm } from "react-hook-form";
import { z } from "zod";
import { Button } from "@/components/ui/button";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { useAuth } from "@/hooks/use-auth";
import { Loader2 } from "lucide-react";

const formSchema = z.object({
  username: z.string().min(2, {
    message: "Username must be at least 2 characters.",
  }),
  password: z.string().min(6, {
    message: "Password must be at least 6 characters.",
  }),
});

export function LoginForm({ onSuccess }: { onSuccess: () => void }) {
  const { loginMutation } = useAuth();
  const [authError, setAuthError] = useState<string | null>(null);

  const form = useForm<z.infer<typeof formSchema>>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      username: "",
      password: "",
    },
  });

  function onSubmit(values: z.infer<typeof formSchema>) {
    setAuthError(null);
    
    loginMutation.mutate({ 
      identifier: values.username, // Using identifier which works for both username or email
      password: values.password 
    }, {
      onSuccess: () => {
        if (onSuccess) {
          onSuccess();
        }
      },
      onError: (error) => {
        setAuthError(error.message || "Login failed. Please check your credentials.");
      }
    });
  }

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
        {authError && (
          <div className="p-3 my-2 text-sm text-white bg-destructive rounded-md">
            {authError}
          </div>
        )}
        
        <FormField
          control={form.control}
          name="username"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Username or Email</FormLabel>
              <FormControl>
                <Input placeholder="Enter your username or email" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        
        <FormField
          control={form.control}
          name="password"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Password</FormLabel>
              <FormControl>
                <Input type="password" placeholder="Enter your password" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        
        <Button 
          type="submit" 
          className="w-full" 
          disabled={loginMutation.isPending}
        >
          {loginMutation.isPending ? (
            <>
              <Loader2 className="mr-2 h-4 w-4 animate-spin" />
              Logging in...
            </>
          ) : (
            "Log in"
          )}
        </Button>
      </form>
    </Form>
  );
}
</file>

<file path="client/src/components/RatingBar.tsx">
interface RatingBarProps {
  value: number;
  max: number;
  colorClass?: string;
  height?: string;
}

export default function RatingBar({ 
  value, 
  max, 
  colorClass = "bg-primary", 
  height = "h-2" 
}: RatingBarProps) {
  const percentage = (value / max) * 100;
  
  return (
    <div className={`w-24 ${height} bg-gray-200 rounded-full overflow-hidden`}>
      <div 
        className={`h-full ${colorClass} rounded-full`} 
        style={{ width: `${percentage}%` }}
      ></div>
    </div>
  );
}
</file>

<file path="client/src/components/RegistrationForm.tsx">
import { useState, useEffect } from "react";
import { zodResolver } from "@hookform/resolvers/zod";
import { useForm } from "react-hook-form";
import { z } from "zod";
import { Button } from "@/components/ui/button";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
  FormDescription,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { useAuth } from "@/hooks/use-auth";
import { Loader2, CheckCircle, XCircle } from "lucide-react";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { apiRequest } from "@/lib/queryClient";

const countries = [
  { name: "Afghanistan", code: "AF" },
  { name: "Åland Islands", code: "AX" },
  { name: "Albania", code: "AL" },
  { name: "Algeria", code: "DZ" },
  { name: "American Samoa", code: "AS" },
  { name: "Andorra", code: "AD" },
  { name: "Angola", code: "AO" },
  { name: "Anguilla", code: "AI" },
  { name: "Antarctica", code: "AQ" },
  { name: "Antigua and Barbuda", code: "AG" },
  { name: "Argentina", code: "AR" },
  { name: "Armenia", code: "AM" },
  { name: "Aruba", code: "AW" },
  { name: "Australia", code: "AU" },
  { name: "Austria", code: "AT" },
  { name: "Azerbaijan", code: "AZ" },
  { name: "Bahamas", code: "BS" },
  { name: "Bahrain", code: "BH" },
  { name: "Bangladesh", code: "BD" },
  { name: "Barbados", code: "BB" },
  { name: "Belarus", code: "BY" },
  { name: "Belgium", code: "BE" },
  { name: "Belize", code: "BZ" },
  { name: "Benin", code: "BJ" },
  { name: "Bermuda", code: "BM" },
  { name: "Bhutan", code: "BT" },
  { name: "Bolivia", code: "BO" },
  { name: "Bosnia and Herzegovina", code: "BA" },
  { name: "Botswana", code: "BW" },
  { name: "Bouvet Island", code: "BV" },
  { name: "Brazil", code: "BR" },
  { name: "British Indian Ocean Territory", code: "IO" },
  { name: "Brunei Darussalam", code: "BN" },
  { name: "Bulgaria", code: "BG" },
  { name: "Burkina Faso", code: "BF" },
  { name: "Burundi", code: "BI" },
  { name: "Cambodia", code: "KH" },
  { name: "Cameroon", code: "CM" },
  { name: "Canada", code: "CA" },
  { name: "Cape Verde", code: "CV" },
  { name: "Cayman Islands", code: "KY" },
  { name: "Central African Republic", code: "CF" },
  { name: "Chad", code: "TD" },
  { name: "Chile", code: "CL" },
  { name: "China", code: "CN" },
  { name: "Christmas Island", code: "CX" },
  { name: "Cocos (Keeling) Islands", code: "CC" },
  { name: "Colombia", code: "CO" },
  { name: "Comoros", code: "KM" },
  { name: "Congo", code: "CG" },
  { name: "Congo, The Democratic Republic of the", code: "CD" },
  { name: "Cook Islands", code: "CK" },
  { name: "Costa Rica", code: "CR" },
  { name: "Cote D'Ivoire", code: "CI" },
  { name: "Croatia", code: "HR" },
  { name: "Cuba", code: "CU" },
  { name: "Cyprus", code: "CY" },
  { name: "Czech Republic", code: "CZ" },
  { name: "Denmark", code: "DK" },
  { name: "Djibouti", code: "DJ" },
  { name: "Dominica", code: "DM" },
  { name: "Dominican Republic", code: "DO" },
  { name: "Ecuador", code: "EC" },
  { name: "Egypt", code: "EG" },
  { name: "El Salvador", code: "SV" },
  { name: "Equatorial Guinea", code: "GQ" },
  { name: "Eritrea", code: "ER" },
  { name: "Estonia", code: "EE" },
  { name: "Ethiopia", code: "ET" },
  { name: "Falkland Islands (Malvinas)", code: "FK" },
  { name: "Faroe Islands", code: "FO" },
  { name: "Fiji", code: "FJ" },
  { name: "Finland", code: "FI" },
  { name: "France", code: "FR" },
  { name: "French Guiana", code: "GF" },
  { name: "French Polynesia", code: "PF" },
  { name: "French Southern Territories", code: "TF" },
  { name: "Gabon", code: "GA" },
  { name: "Gambia", code: "GM" },
  { name: "Georgia", code: "GE" },
  { name: "Germany", code: "DE" },
  { name: "Ghana", code: "GH" },
  { name: "Gibraltar", code: "GI" },
  { name: "Greece", code: "GR" },
  { name: "Greenland", code: "GL" },
  { name: "Grenada", code: "GD" },
  { name: "Guadeloupe", code: "GP" },
  { name: "Guam", code: "GU" },
  { name: "Guatemala", code: "GT" },
  { name: "Guernsey", code: "GG" },
  { name: "Guinea", code: "GN" },
  { name: "Guinea-Bissau", code: "GW" },
  { name: "Guyana", code: "GY" },
  { name: "Haiti", code: "HT" },
  { name: "Heard Island and Mcdonald Islands", code: "HM" },
  { name: "Holy See (Vatican City State)", code: "VA" },
  { name: "Honduras", code: "HN" },
  { name: "Hong Kong", code: "HK" },
  { name: "Hungary", code: "HU" },
  { name: "Iceland", code: "IS" },
  { name: "India", code: "IN" },
  { name: "Indonesia", code: "ID" },
  { name: "Iran, Islamic Republic Of", code: "IR" },
  { name: "Iraq", code: "IQ" },
  { name: "Ireland", code: "IE" },
  { name: "Isle of Man", code: "IM" },
  { name: "Israel", code: "IL" },
  { name: "Italy", code: "IT" },
  { name: "Jamaica", code: "JM" },
  { name: "Japan", code: "JP" },
  { name: "Jersey", code: "JE" },
  { name: "Jordan", code: "JO" },
  { name: "Kazakhstan", code: "KZ" },
  { name: "Kenya", code: "KE" },
  { name: "Kiribati", code: "KI" },
  { name: "Korea, Democratic People'S Republic of", code: "KP" },
  { name: "Korea, Republic of", code: "KR" },
  { name: "Kuwait", code: "KW" },
  { name: "Kyrgyzstan", code: "KG" },
  { name: "Lao People'S Democratic Republic", code: "LA" },
  { name: "Latvia", code: "LV" },
  { name: "Lebanon", code: "LB" },
  { name: "Lesotho", code: "LS" },
  { name: "Liberia", code: "LR" },
  { name: "Libyan Arab Jamahiriya", code: "LY" },
  { name: "Liechtenstein", code: "LI" },
  { name: "Lithuania", code: "LT" },
  { name: "Luxembourg", code: "LU" },
  { name: "Macao", code: "MO" },
  { name: "Macedonia, The Former Yugoslav Republic of", code: "MK" },
  { name: "Madagascar", code: "MG" },
  { name: "Malawi", code: "MW" },
  { name: "Malaysia", code: "MY" },
  { name: "Maldives", code: "MV" },
  { name: "Mali", code: "ML" },
  { name: "Malta", code: "MT" },
  { name: "Marshall Islands", code: "MH" },
  { name: "Martinique", code: "MQ" },
  { name: "Mauritania", code: "MR" },
  { name: "Mauritius", code: "MU" },
  { name: "Mayotte", code: "YT" },
  { name: "Mexico", code: "MX" },
  { name: "Micronesia, Federated States of", code: "FM" },
  { name: "Moldova, Republic of", code: "MD" },
  { name: "Monaco", code: "MC" },
  { name: "Mongolia", code: "MN" },
  { name: "Montserrat", code: "MS" },
  { name: "Morocco", code: "MA" },
  { name: "Mozambique", code: "MZ" },
  { name: "Myanmar", code: "MM" },
  { name: "Namibia", code: "NA" },
  { name: "Nauru", code: "NR" },
  { name: "Nepal", code: "NP" },
  { name: "Netherlands", code: "NL" },
  { name: "Netherlands Antilles", code: "AN" },
  { name: "New Caledonia", code: "NC" },
  { name: "New Zealand", code: "NZ" },
  { name: "Nicaragua", code: "NI" },
  { name: "Niger", code: "NE" },
  { name: "Nigeria", code: "NG" },
  { name: "Niue", code: "NU" },
  { name: "Norfolk Island", code: "NF" },
  { name: "Northern Mariana Islands", code: "MP" },
  { name: "Norway", code: "NO" },
  { name: "Oman", code: "OM" },
  { name: "Pakistan", code: "PK" },
  { name: "Palau", code: "PW" },
  { name: "Palestinian Territory, Occupied", code: "PS" },
  { name: "Panama", code: "PA" },
  { name: "Papua New Guinea", code: "PG" },
  { name: "Paraguay", code: "PY" },
  { name: "Peru", code: "PE" },
  { name: "Philippines", code: "PH" },
  { name: "Pitcairn", code: "PN" },
  { name: "Poland", code: "PL" },
  { name: "Portugal", code: "PT" },
  { name: "Puerto Rico", code: "PR" },
  { name: "Qatar", code: "QA" },
  { name: "Reunion", code: "RE" },
  { name: "Romania", code: "RO" },
  { name: "Russian Federation", code: "RU" },
  { name: "Rwanda", code: "RW" },
  { name: "Saint Helena", code: "SH" },
  { name: "Saint Kitts and Nevis", code: "KN" },
  { name: "Saint Lucia", code: "LC" },
  { name: "Saint Pierre and Miquelon", code: "PM" },
  { name: "Saint Vincent and the Grenadines", code: "VC" },
  { name: "Samoa", code: "WS" },
  { name: "San Marino", code: "SM" },
  { name: "Sao Tome and Principe", code: "ST" },
  { name: "Saudi Arabia", code: "SA" },
  { name: "Senegal", code: "SN" },
  { name: "Serbia and Montenegro", code: "CS" },
  { name: "Seychelles", code: "SC" },
  { name: "Sierra Leone", code: "SL" },
  { name: "Singapore", code: "SG" },
  { name: "Slovakia", code: "SK" },
  { name: "Slovenia", code: "SI" },
  { name: "Solomon Islands", code: "SB" },
  { name: "Somalia", code: "SO" },
  { name: "South Africa", code: "ZA" },
  { name: "South Georgia and the South Sandwich Islands", code: "GS" },
  { name: "Spain", code: "ES" },
  { name: "Sri Lanka", code: "LK" },
  { name: "Sudan", code: "SD" },
  { name: "Suriname", code: "SR" },
  { name: "Svalbard and Jan Mayen", code: "SJ" },
  { name: "Swaziland", code: "SZ" },
  { name: "Sweden", code: "SE" },
  { name: "Switzerland", code: "CH" },
  { name: "Syrian Arab Republic", code: "SY" },
  { name: "Taiwan, Province of China", code: "TW" },
  { name: "Tajikistan", code: "TJ" },
  { name: "Tanzania, United Republic of", code: "TZ" },
  { name: "Thailand", code: "TH" },
  { name: "Timor-Leste", code: "TL" },
  { name: "Togo", code: "TG" },
  { name: "Tokelau", code: "TK" },
  { name: "Tonga", code: "TO" },
  { name: "Trinidad and Tobago", code: "TT" },
  { name: "Tunisia", code: "TN" },
  { name: "Turkey", code: "TR" },
  { name: "Turkmenistan", code: "TM" },
  { name: "Turks and Caicos Islands", code: "TC" },
  { name: "Tuvalu", code: "TV" },
  { name: "Uganda", code: "UG" },
  { name: "Ukraine", code: "UA" },
  { name: "United Arab Emirates", code: "AE" },
  { name: "United Kingdom", code: "GB" },
  { name: "United States", code: "US" },
  { name: "United States Minor Outlying Islands", code: "UM" },
  { name: "Uruguay", code: "UY" },
  { name: "Uzbekistan", code: "UZ" },
  { name: "Vanuatu", code: "VU" },
  { name: "Venezuela", code: "VE" },
  { name: "Vietnam", code: "VN" },
  { name: "Virgin Islands, British", code: "VG" },
  { name: "Virgin Islands, U.S.", code: "VI" },
  { name: "Wallis and Futuna", code: "WF" },
  { name: "Western Sahara", code: "EH" },
  { name: "Yemen", code: "YE" },
  { name: "Zambia", code: "ZM" },
  { name: "Zimbabwe", code: "ZW" }
];

// Create the registration form schema
const formSchema = z.object({
  email: z.string().email({
    message: "Please enter a valid email address.",
  }),
  username: z.string().min(2, {
    message: "Username must be at least 2 characters.",
  }),
  password: z.string().min(6, {
    message: "Password must be at least 6 characters.",
  }),
});

export function RegistrationForm({ onSuccess }: { onSuccess: () => void }) {
  const { registerMutation } = useAuth();
  const [authError, setAuthError] = useState<string | null>(null);
  const [usernameAvailable, setUsernameAvailable] = useState<boolean | null>(null);
  const [checkingUsername, setCheckingUsername] = useState(false);
  const [emailAvailable, setEmailAvailable] = useState<boolean | null>(null);
  const [checkingEmail, setCheckingEmail] = useState(false);

  const form = useForm<z.infer<typeof formSchema>>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      email: "",
      username: "",
      password: "",
    },
  });

  // Check for referral data on component mount
  useEffect(() => {
    const urlParams = new URLSearchParams(window.location.search);
    const referrerId = urlParams.get('ref');
    const showId = urlParams.get('show');
    
    if (referrerId) {
      localStorage.setItem('referrer_id', referrerId);
    }
    if (showId) {
      localStorage.setItem('referral_show_id', showId);
    }
    
    // Also check localStorage for existing referral data
    const storedReferrerId = localStorage.getItem('referrer_id');
    const storedShowId = localStorage.getItem('referral_show_id');
    
    console.log('Referral data found:', { 
      urlReferrer: referrerId, 
      urlShow: showId,
      storedReferrer: storedReferrerId, 
      storedShow: storedShowId 
    });
  }, []);

  // Username availability check
  useEffect(() => {
    // Debounce username check
    const username = form.watch('username');
    
    if (username && username.length >= 2) {
      const timeoutId = setTimeout(() => {
        checkUsernameAvailability(username);
      }, 500);
      
      return () => clearTimeout(timeoutId);
    } else {
      setUsernameAvailable(null);
    }
  }, [form.watch('username')]);
  
  // Email availability check
  useEffect(() => {
    // Debounce email check
    const email = form.watch('email');
    
    if (email && email.includes('@') && email.includes('.')) {
      const timeoutId = setTimeout(() => {
        checkEmailAvailability(email);
      }, 500);
      
      return () => clearTimeout(timeoutId);
    } else {
      setEmailAvailable(null);
    }
  }, [form.watch('email')]);

  async function checkUsernameAvailability(username: string) {
    if (username.length < 2) return;
    
    setCheckingUsername(true);
    try {
      const response = await fetch(
        `/api/check-username?username=${encodeURIComponent(username)}`
      );
      const data = await response.json();
      setUsernameAvailable(data.available);
    } catch (error) {
      console.error('Error checking username:', error);
      setUsernameAvailable(null);
    } finally {
      setCheckingUsername(false);
    }
  }

  async function checkEmailAvailability(email: string) {
    if (!email.includes('@') || !email.includes('.')) return;
    
    setCheckingEmail(true);
    try {
      const response = await fetch(
        `/api/check-email?email=${encodeURIComponent(email)}`
      );
      const data = await response.json();
      setEmailAvailable(data.available);
    } catch (error) {
      console.error('Error checking email:', error);
      setEmailAvailable(null);
    } finally {
      setCheckingEmail(false);
    }
  }

  function onSubmit(values: z.infer<typeof formSchema>) {
    setAuthError(null);
    
    if (usernameAvailable === false) {
      setAuthError("Username is already taken. Please choose another.");
      return;
    }
    
    if (emailAvailable === false) {
      setAuthError("Email is already registered. Please use another email or login.");
      return;
    }
    
    // Check for any stored referral information in localStorage
    const referrerId = localStorage.getItem('referrer_id');
    
    // Add referral information to registration data if available
    const registrationData = {
      ...values,
      referrerId: referrerId || undefined
    };
    
    registerMutation.mutate(registrationData, {
      onSuccess: () => {
        // Clear referral data after successful registration
        localStorage.removeItem('referrer_id');
        localStorage.removeItem('referral_show_id');
        
        if (onSuccess) {
          onSuccess();
        }
      },
      onError: (error) => {
        setAuthError(error.message || "Registration failed. Please check your information.");
      }
    });
  }

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
        {authError && (
          <div className="p-3 my-2 text-sm text-white bg-destructive rounded-md">
            {authError}
          </div>
        )}
        
        <FormField
          control={form.control}
          name="email"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Email</FormLabel>
              <div className="relative">
                <FormControl>
                  <Input placeholder="Enter your email" {...field} />
                </FormControl>
                {checkingEmail && (
                  <div className="absolute right-2 top-2">
                    <Loader2 className="h-4 w-4 animate-spin text-muted-foreground" />
                  </div>
                )}
                {emailAvailable === true && !checkingEmail && (
                  <div className="absolute right-2 top-2">
                    <CheckCircle className="h-4 w-4 text-green-500" />
                  </div>
                )}
                {emailAvailable === false && !checkingEmail && (
                  <div className="absolute right-2 top-2">
                    <XCircle className="h-4 w-4 text-red-500" />
                  </div>
                )}
              </div>
              <FormMessage />
              {emailAvailable === false && (
                <FormDescription className="text-red-500">
                  This email is already registered.
                </FormDescription>
              )}
            </FormItem>
          )}
        />
        
        <FormField
          control={form.control}
          name="username"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Username</FormLabel>
              <div className="relative">
                <FormControl>
                  <Input placeholder="Choose a username" {...field} />
                </FormControl>
                {checkingUsername && (
                  <div className="absolute right-2 top-2">
                    <Loader2 className="h-4 w-4 animate-spin text-muted-foreground" />
                  </div>
                )}
                {usernameAvailable === true && !checkingUsername && (
                  <div className="absolute right-2 top-2">
                    <CheckCircle className="h-4 w-4 text-green-500" />
                  </div>
                )}
                {usernameAvailable === false && !checkingUsername && (
                  <div className="absolute right-2 top-2">
                    <XCircle className="h-4 w-4 text-red-500" />
                  </div>
                )}
              </div>
              <FormMessage />
              {usernameAvailable === false && (
                <FormDescription className="text-red-500">
                  This username is already taken.
                </FormDescription>
              )}
            </FormItem>
          )}
        />
        
        <FormField
          control={form.control}
          name="password"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Password</FormLabel>
              <FormControl>
                <Input type="password" placeholder="Create a password" {...field} />
              </FormControl>
              <FormMessage />
              <FormDescription>
                Must be at least 6 characters.
              </FormDescription>
            </FormItem>
          )}
        />
        
        <Button 
          type="submit" 
          className="w-full" 
          disabled={
            registerMutation.isPending || 
            usernameAvailable === false || 
            emailAvailable === false
          }
        >
          {registerMutation.isPending ? (
            <>
              <Loader2 className="mr-2 h-4 w-4 animate-spin" />
              Registering...
            </>
          ) : (
            "Register"
          )}
        </Button>
      </form>
    </Form>
  );
}
</file>

<file path="client/src/components/ShowFilters.tsx">
import { useState, useEffect, useRef } from "react";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Checkbox } from "@/components/ui/checkbox";
import {
  Card,
  CardContent,
} from "@/components/ui/card";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Slider } from "@/components/ui/slider";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { RadioGroup, RadioGroupItem } from "@/components/ui/radio-group";
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
  CommandList,
} from "@/components/ui/command";
import { useQuery } from "@tanstack/react-query";
import { TvShow } from "@shared/schema";
import { Search, CheckIcon, X } from "lucide-react";
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover";

interface FiltersType {
  ageGroup?: string;
  ageRange?: {min: number, max: number};
  tantrumFactor?: string; // We'll continue using this field name for continuity, but it maps to stimulationScore
  sortBy?: string;
  search?: string;
  themes?: string[];
  themeMatchMode?: 'AND' | 'OR';
  interactionLevel?: string;
  interactivityLevel?: string;
  stimulationScoreRange?: {min: number, max: number};
}

interface ShowFiltersProps {
  activeFilters: FiltersType;
  onFilterChange: (filters: FiltersType) => void;
  onClearFilters: () => void;
}

export default function ShowFilters({ activeFilters, onFilterChange, onClearFilters }: ShowFiltersProps) {
  const [filters, setFilters] = useState<FiltersType>(activeFilters);
  const [searchInput, setSearchInput] = useState(activeFilters.search || "");
  const [selectedThemes, setSelectedThemes] = useState<string[]>(activeFilters.themes || []);
  const [themeMatchMode, setThemeMatchMode] = useState<'AND' | 'OR'>(activeFilters.themeMatchMode || 'AND');
  const [openAutoComplete, setOpenAutoComplete] = useState(false);
  const [showSearchDropdown, setShowSearchDropdown] = useState(false);
  const searchContainerRef = useRef<HTMLDivElement>(null);
  
  // Fetch shows for autocomplete and theme analysis
  const { data: shows } = useQuery<TvShow[]>({
    queryKey: ['/api/tv-shows'],
    staleTime: 300000, // 5 minutes
  });
  
  // Computed state for relevant secondary themes based on the primary theme
  const [relevantSecondaryThemes, setRelevantSecondaryThemes] = useState<string[]>([]);
  
  // Common themes extracted dynamically from the database
  const [commonThemes, setCommonThemes] = useState<string[]>([]);
  const [availableThemes, setAvailableThemes] = useState<string[]>([]);
  
  // Extract all themes from the database when shows data is loaded
  useEffect(() => {
    if (!shows || !Array.isArray(shows)) return;
    
    const allThemes = new Set<string>();
    
    shows.forEach(show => {
      if (show.themes && Array.isArray(show.themes)) {
        show.themes.forEach(theme => {
          if (theme && theme.trim() !== '') {
            allThemes.add(theme.trim());
          }
        });
      }
    });
    
    // Convert to array and sort alphabetically
    const sortedThemes = Array.from(allThemes).sort();
    console.log(`Found ${sortedThemes.length} unique themes in the database`);
    
    setCommonThemes(sortedThemes);
    setAvailableThemes(sortedThemes); // Initially all themes are available
  }, [shows]);

  // Calculate available themes based on selected themes and match mode
  useEffect(() => {
    if (!shows || !Array.isArray(shows) || themeMatchMode === 'OR') {
      // In OR mode or no shows, all themes are available
      setAvailableThemes(commonThemes);
      return;
    }

    if (selectedThemes.length === 0) {
      // No themes selected, all themes are available
      setAvailableThemes(commonThemes);
      return;
    }

    // In AND mode with selected themes, find themes that co-exist
    const coexistingThemes = new Set<string>();
    
    // Find shows that contain ALL currently selected themes
    const matchingShows = shows.filter(show => {
      if (!show.themes || !Array.isArray(show.themes)) return false;
      const themes = show.themes as string[];
      return selectedThemes.every(selectedTheme => 
        themes.includes(selectedTheme)
      );
    });

    // Collect all themes from shows that match the current selection
    matchingShows.forEach(show => {
      if (show.themes && Array.isArray(show.themes)) {
        show.themes.forEach(theme => {
          if (theme && theme.trim() !== '') {
            coexistingThemes.add(theme.trim());
          }
        });
      }
    });

    // Convert to array and sort, including already selected themes
    const availableThemesList = Array.from(coexistingThemes).sort();
    setAvailableThemes(availableThemesList);
    
    console.log(`AND mode: Found ${availableThemesList.length} themes that co-exist with selected themes`);
  }, [shows, selectedThemes, themeMatchMode, commonThemes]);
  
  // Update local state when props change
  useEffect(() => {
    setFilters(activeFilters);
    setSearchInput(activeFilters.search || "");
    setSelectedThemes(activeFilters.themes || []);
  }, [activeFilters]);
  
  // Update relevant secondary themes when shows data loads, selected themes change, or theme match mode changes
  useEffect(() => {
    if (shows && selectedThemes.length > 0) {
      // For OR mode, display all available themes
      // For AND mode, display only co-existing themes
      if (themeMatchMode === 'OR') {
        setRelevantSecondaryThemes(commonThemes.filter(theme => !selectedThemes.includes(theme)));
      } else {
        findRelevantSecondaryThemes(selectedThemes[0]);
      }
    } else {
      // Reset if no primary theme is selected
      setRelevantSecondaryThemes([]);
    }
  }, [shows, selectedThemes[0], themeMatchMode, commonThemes]);
  
  // Log for debugging
  useEffect(() => {
    console.log("Current filters in ShowFilters component:", filters);
  }, [filters]);

  // Hide search dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (searchContainerRef.current && !searchContainerRef.current.contains(event.target as Node)) {
        setShowSearchDropdown(false);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, []);
  
  // Find relevant secondary themes based on shows that have the primary theme
  const findRelevantSecondaryThemes = (primaryTheme: string) => {
    if (!shows || !primaryTheme || primaryTheme === "any") {
      setRelevantSecondaryThemes([]);
      return;
    }

    try {
      console.log(`Finding relevant secondary themes for primary theme: ${primaryTheme}`);

      // Normalize the primary theme for consistent matching
      const normalizedPrimaryTheme = primaryTheme.trim().toLowerCase();

      // Create a safe copy to avoid runtime errors
      let showsWithPrimaryTheme: TvShow[] = [];

      // Ensure we're getting exact matches or close matches for themes
      const exactMatches = shows.filter(show => {
        if (!show || !show.themes || !Array.isArray(show.themes)) return false;
        
        // Case-insensitive matching for themes
        return show.themes.some(theme => 
          theme && 
          typeof theme === 'string' &&
          theme.trim().toLowerCase() === normalizedPrimaryTheme
        );
      });
      
      showsWithPrimaryTheme = [...exactMatches];
      console.log(`Found ${showsWithPrimaryTheme.length} shows with exact match for theme: ${primaryTheme}`);
      
      // If no exact matches, try partial matches (contains)
      if (showsWithPrimaryTheme.length === 0) {
        const partialMatches = shows.filter(show => {
          if (!show || !show.themes || !Array.isArray(show.themes)) return false;
          
          return show.themes.some(theme => 
            theme && 
            typeof theme === 'string' &&
            theme.trim().toLowerCase().includes(normalizedPrimaryTheme)
          );
        });
        
        console.log(`Found ${partialMatches.length} shows with partial match for theme: ${primaryTheme}`);
        
        // Add partial matches if found
        if (partialMatches.length > 0) {
          showsWithPrimaryTheme = [...partialMatches];
        }
      }

      // Count occurrences of each secondary theme
      const themeCounts: Record<string, number> = {};
      
      // Safely process the shows
      showsWithPrimaryTheme.forEach(show => {
        if (!show || !show.themes || !Array.isArray(show.themes)) return;
        
        show.themes.forEach(theme => {
          if (!theme || typeof theme !== 'string' || theme.trim() === "") return;
          
          // Skip the primary theme (exact or case-insensitive match)
          const themeNormalized = theme.trim();
          const themeLower = themeNormalized.toLowerCase();
          
          if (themeLower !== normalizedPrimaryTheme && 
              themeLower !== primaryTheme.toLowerCase()) {
            themeCounts[themeNormalized] = (themeCounts[themeNormalized] || 0) + 1;
          }
        });
      });

      // Sort themes by frequency (most frequent first)
      const sortedThemes = Object.entries(themeCounts)
        .sort((a, b) => b[1] - a[1])  // Sort by count
        .map(([theme]) => theme);     // Take just the theme name

      console.log(`Found ${sortedThemes.length} relevant secondary themes for ${primaryTheme}`);
      
      // Only show themes that actually co-exist with the primary theme
      // If none are found, don't show any secondary theme options
      setRelevantSecondaryThemes(sortedThemes);
    } catch (error) {
      console.error("Error finding relevant secondary themes:", error);
      // Fallback to empty array on error
      setRelevantSecondaryThemes([]);
    }
  };
  
  const handleFilterChange = (key: keyof FiltersType, value: any) => {
    const updatedFilters = { ...filters, [key]: value };
    setFilters(updatedFilters);
  };
  
  const handleThemeToggle = (theme: string) => {
    let newThemes: string[];
    
    if (selectedThemes.includes(theme)) {
      newThemes = selectedThemes.filter(t => t !== theme);
    } else {
      newThemes = [...selectedThemes, theme];
    }
    
    setSelectedThemes(newThemes);
    handleFilterChange('themes', newThemes.length ? newThemes : undefined);
  };
  
  const handleApplyFilters = () => {
    // Include search term from input
    onFilterChange({ 
      ...filters, 
      search: searchInput,
      themes: selectedThemes.length ? selectedThemes : undefined
    });
  };
  
  const removeFilter = (key: keyof FiltersType) => {
    const updatedFilters = { ...filters };
    delete updatedFilters[key];
    
    // Also clear search input if removing search filter
    if (key === 'search') {
      setSearchInput("");
    }
    
    // Clear selected themes if removing themes filter
    if (key === 'themes') {
      setSelectedThemes([]);
    }
    
    onFilterChange(updatedFilters);
  };
  
  // Get human-readable filter labels
  const getFilterLabel = (key: keyof FiltersType, value: any) => {
    switch (key) {
      case 'ageGroup':
        return `Age: ${value}`;
      case 'ageRange':
        const ageRange = value as {min: number, max: number};
        if (ageRange.min === 0 && ageRange.max === 13) {
          return 'Age: Any';
        } else if (ageRange.max === 13) {
          return `Age: ${ageRange.min}+`;
        } else {
          return `Age: ${ageRange.min}-${ageRange.max}`;
        }
      case 'tantrumFactor':
        switch (value) {
          case 'low': return 'Low Stimulation (1)';
          case 'low-medium': return 'Low-Medium Stimulation (2)';
          case 'medium': return 'Medium Stimulation (3)';
          case 'medium-high': return 'Medium-High Stimulation (4)';
          case 'high': return 'High Stimulation (5)';
          default: return value;
        }
      case 'interactivityLevel':
        return `Interactivity Level: ${value}`;
      case 'stimulationScoreRange':
        const range = value as {min: number, max: number};
        if (range.min === range.max) {
          return `Stimulation Score: ${range.min}`;
        } else {
          return `Stimulation Score: ${range.min}-${range.max}`;
        }
      case 'sortBy':
        switch (value) {
          case 'name': return 'Sorted by Name';
          case 'stimulation-score': return 'Sorted by Stimulation Score';
          case 'interactivity-level': return 'Sorted by Interactivity Level';
          case 'overall-rating': return 'Sorted by Rating';
          case 'popular': return 'Sorted by Popularity';
          default: return value;
        }
      case 'search':
        return `Search: "${value}"`;
      case 'themes':
        if (Array.isArray(value) && value.length === 1) {
          return `Theme: ${value[0]}`;
        } else if (Array.isArray(value) && value.length > 1) {
          return `Themes: ${value[0]} +${value.length - 1}`;
        }
        return 'Themes';
      default:
        return value;
    }
  };
  
  return (
    <Card className="mb-8 bg-white rounded-lg shadow">
      <CardContent className="p-6">
        <h2 className="text-xl font-heading font-bold mb-6">Filters</h2>
        
        <div className="space-y-6">
          {/* Search by show name with autocomplete */}
          <div ref={searchContainerRef}>
            <Label htmlFor="show-name" className="block text-sm font-medium text-gray-700 mb-2">
              Show Name
            </Label>
            
            <form 
              onSubmit={(e) => {
                e.preventDefault();
                console.log('Search form submitted with term:', searchInput);
                setShowSearchDropdown(false);
                handleFilterChange('search', searchInput);
                const updatedFilters = {
                  ...filters,
                  search: searchInput
                };
                console.log('Applying filters:', updatedFilters);
                onFilterChange(updatedFilters);
              }}
              className="flex"
            >
              <div className="relative flex-grow">
                <Search className="absolute left-2 top-2.5 h-4 w-4 text-gray-500" />
                <Input
                  id="show-name"
                  placeholder="Enter show title..."
                  value={searchInput}
                  onChange={(e) => {
                    setSearchInput(e.target.value);
                    setShowSearchDropdown(e.target.value.trim().length > 0);
                  }}
                  className="w-full pl-8 rounded-r-none"
                />
              </div>
              <Button 
                type="submit" 
                className="rounded-l-none"
              >
                Search
              </Button>
            </form>
              
            {/* Show matching results based on searchInput */}
            {showSearchDropdown && searchInput.trim().length > 0 && (
              <div className="relative mt-1">
                <div className="absolute z-10 mt-1 w-full bg-white rounded-md shadow-lg max-h-60 overflow-auto border border-gray-200">
                  <div className="py-1">
                    {shows
                      ?.filter(show => {
                        // Skip if no search input
                        if (!searchInput.trim()) return false;
                        
                        const searchLower = searchInput.toLowerCase().trim();
                        const nameLower = show.name.toLowerCase();
                        
                        // Direct match in name
                        if (nameLower.includes(searchLower)) return true;
                        
                        // Handle shows with year ranges (e.g., "Show Name 2018-present")
                        const nameWithoutYears = nameLower.replace(/\s+\d{4}(-\d{4}|-present)?/g, '');
                        if (nameWithoutYears.includes(searchLower)) return true;
                        
                        // Match any part of a word (for show names like "Blue's Clues")
                        const words = nameLower.split(/\s+/);
                        if (words.some(word => word.includes(searchLower))) return true;
                        
                        // Handle apostrophes and special characters
                        const simplifiedName = nameLower.replace(/[''\.]/g, '');
                        if (simplifiedName.includes(searchLower)) return true;
                        
                        return false;
                      })
                      .slice(0, 8)
                      .map(show => (
                        <div
                          key={show.id}
                          className="px-4 py-2 hover:bg-gray-100 cursor-pointer"
                          onClick={() => {
                            console.log('Selecting show from dropdown:', show.name);
                            setSearchInput(show.name);
                            setShowSearchDropdown(false);
                            handleFilterChange('search', show.name);
                            const updatedFilters = {
                              ...filters,
                              search: show.name
                            };
                            console.log('Applying updated filters from dropdown selection:', updatedFilters);
                            onFilterChange(updatedFilters);
                          }}
                        >
                          <div className="font-medium">{show.name}</div>
                          <div className="text-xs text-gray-500">
                            Ages: {show.ageRange || 'Unknown'} 
                            {show.releaseYear ? ` • (${show.releaseYear})` : ''}
                          </div>
                        </div>
                      ))
                    }
                    
                    {shows?.filter(show => {
                      const searchLower = searchInput.toLowerCase().trim();
                      const nameLower = show.name.toLowerCase();
                      
                      // Direct match
                      if (nameLower.includes(searchLower)) return true;
                      
                      // Without years
                      const nameWithoutYears = nameLower.replace(/\s+\d{4}(-\d{4}|-present)?/g, '');
                      if (nameWithoutYears.includes(searchLower)) return true;
                      
                      // Within words
                      const words = nameLower.split(/\s+/);
                      if (words.some(word => word.includes(searchLower))) return true;
                      
                      // Simplified name
                      const simplifiedName = nameLower.replace(/[''\.]/g, '');
                      if (simplifiedName.includes(searchLower)) return true;
                      
                      return false;
                    }).length === 0 && (
                      <div className="px-4 py-2 text-sm text-gray-500">
                        No shows match your search
                      </div>
                    )}
                  </div>
                </div>
              </div>
            )}
          </div>
          
          {/* Age Range - using separate min/max sliders */}
          <div>
            <Label className="block text-sm font-medium text-gray-700 mb-1">
              Age Range
            </Label>
            <div className="flex flex-col space-y-4">
              {/* Min slider */}
              <div>
                <div className="flex justify-between mb-1">
                  <span className="text-xs font-medium">Minimum: {filters.ageRange?.min || 0} years</span>
                </div>
                <div className="relative pt-1">
                  <input 
                    type="range" 
                    min="0" 
                    max="13" 
                    step="1" 
                    value={filters.ageRange?.min || 0}
                    onChange={(e) => {
                      const newMin = parseInt(e.target.value);
                      const currentMax = filters.ageRange?.max || 13;
                      handleFilterChange('ageRange', {
                        min: newMin,
                        max: Math.max(newMin, currentMax) // Ensure max is at least equal to min
                      });
                    }}
                    className="w-full appearance-none rounded-full h-2 bg-gray-200 outline-none accent-green-600" 
                  />
                </div>
                <div className="flex justify-between text-[10px] text-gray-600 mt-1">
                  <span>0</span>
                  <span>2</span>
                  <span>4</span>
                  <span>6</span>
                  <span>8</span>
                  <span>10</span>
                  <span>13</span>
                </div>
              </div>
              
              {/* Max slider */}
              <div>
                <div className="flex justify-between mb-1">
                  <span className="text-xs font-medium">Maximum: {filters.ageRange?.max === 13 ? '13+' : filters.ageRange?.max || 13} years</span>
                </div>
                <div className="relative pt-1">
                  <input 
                    type="range" 
                    min="0" 
                    max="13" 
                    step="1" 
                    value={filters.ageRange?.max || 13}
                    onChange={(e) => {
                      const newMax = parseInt(e.target.value);
                      const currentMin = filters.ageRange?.min || 0;
                      handleFilterChange('ageRange', {
                        min: Math.min(currentMin, newMax), // Ensure min is at most equal to max
                        max: newMax
                      });
                    }}
                    className="w-full appearance-none rounded-full h-2 bg-gray-200 outline-none accent-green-600" 
                  />
                </div>
                <div className="flex justify-between text-[10px] text-gray-600 mt-1">
                  <span>0</span>
                  <span>2</span>
                  <span>4</span>
                  <span>6</span>
                  <span>8</span>
                  <span>10</span>
                  <span>13+</span>
                </div>
              </div>
            </div>
          </div>
          
          {/* Themes with checkboxes */}
          <div>
            <div className="flex items-center justify-between mb-2">
              <Label className="text-sm font-medium text-gray-700">
                Themes
              </Label>
              {selectedThemes.length > 0 && (
                <div className="flex space-x-1">
                  <Button 
                    size="sm" 
                    variant={themeMatchMode === 'AND' ? "default" : "outline"}
                    onClick={() => {
                      setThemeMatchMode('AND');
                      handleFilterChange('themeMatchMode', 'AND');
                    }}
                    className="h-6 px-2 text-xs"
                  >
                    AND
                  </Button>
                  <Button 
                    size="sm" 
                    variant={themeMatchMode === 'OR' ? "default" : "outline"}
                    onClick={() => {
                      setThemeMatchMode('OR');
                      handleFilterChange('themeMatchMode', 'OR');
                    }}
                    className="h-6 px-2 text-xs"
                  >
                    OR
                  </Button>
                </div>
              )}
            </div>
            
            <div className="space-y-2 max-h-80 overflow-y-auto border rounded-md p-2">
              {availableThemes.map((theme) => {
                const isSelected = selectedThemes.includes(theme);
                const isDisabled = themeMatchMode === 'AND' && selectedThemes.length > 0 && !isSelected && !availableThemes.includes(theme);
                
                return (
                  <div key={theme} className={`flex items-center space-x-2 ${isDisabled ? 'opacity-50' : ''}`}>
                    <Checkbox
                      id={`theme-${theme}`}
                      checked={isSelected}
                      disabled={isDisabled}
                      onCheckedChange={(checked) => {
                        if (checked) {
                          const newThemes = [...selectedThemes, theme];
                          setSelectedThemes(newThemes);
                          handleFilterChange('themes', newThemes);
                        } else {
                          const newThemes = selectedThemes.filter(t => t !== theme);
                          setSelectedThemes(newThemes);
                          handleFilterChange('themes', newThemes.length > 0 ? newThemes : undefined);
                        }
                      }}
                    />
                    <label
                      htmlFor={`theme-${theme}`}
                      className={`text-sm cursor-pointer flex-1 ${isDisabled ? 'text-gray-400 cursor-not-allowed' : ''}`}
                    >
                      {theme}
                    </label>
                  </div>
                );
              })}
            </div>
            
            {/* Theme match mode explanation */}
            {selectedThemes.length > 0 && (
              <p className="text-xs text-gray-500 mt-2">
                {themeMatchMode === 'AND' 
                  ? 'Shows must contain ALL selected themes' 
                  : 'Shows can contain ANY of the selected themes'}
              </p>
            )}
          </div>
          
          {/* Interactivity Level */}
          <div>
            <Label htmlFor="interactivity-level" className="block text-sm font-medium text-gray-700 mb-1">
              Interactivity Level
            </Label>
            <Select 
              value={filters.interactionLevel} 
              onValueChange={(value) => handleFilterChange('interactionLevel', value)}
            >
              <SelectTrigger id="interactivity-level">
                <SelectValue placeholder="Any" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="Any">Any</SelectItem>
                <SelectItem value="Low">Low</SelectItem>
                <SelectItem value="Moderate-Low">Moderate-Low</SelectItem>
                <SelectItem value="Moderate">Moderate</SelectItem>
                <SelectItem value="Moderate-High">Moderate-High</SelectItem>
                <SelectItem value="High">High</SelectItem>
              </SelectContent>
            </Select>
          </div>
          
          {/* Sort By */}
          <div>
            <Label htmlFor="sort-by" className="block text-sm font-medium text-gray-700 mb-1">
              Sort By
            </Label>
            <Select 
              value={filters.sortBy} 
              onValueChange={(value) => handleFilterChange('sortBy', value)}
            >
              <SelectTrigger id="sort-by">
                <SelectValue placeholder="Name (A-Z)" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="name">Name (A-Z)</SelectItem>
                <SelectItem value="stimulation-score">Stimulation Score (Low to High)</SelectItem>
                <SelectItem value="interactivity-level">Interactivity Level (Low to High)</SelectItem>
                <SelectItem value="overall-rating">Rating (High to Low)</SelectItem>
                <SelectItem value="popular">Popular</SelectItem>
              </SelectContent>
            </Select>
          </div>
          
          {/* Stimulation Score Range - always visible */}
          <div>
            <Label className="block text-sm font-medium text-gray-700 mb-1">
              Stimulation Score Range
            </Label>
            <div className="flex flex-col space-y-4">
              {/* Min slider */}
              <div>
                <div className="flex justify-between mb-1">
                  <span className="text-xs font-medium">Minimum: {filters.stimulationScoreRange?.min || 1}</span>
                </div>
                <div className="relative pt-1">
                  <input 
                    type="range" 
                    min="1" 
                    max="5" 
                    step="1" 
                    value={filters.stimulationScoreRange?.min || 1}
                    onChange={(e) => {
                      const newMin = parseInt(e.target.value);
                      const currentMax = filters.stimulationScoreRange?.max || 5;
                      handleFilterChange('stimulationScoreRange', {
                        min: newMin,
                        max: Math.max(newMin, currentMax) // Ensure max is at least equal to min
                      });
                    }}
                    className="w-full appearance-none rounded-full h-2 bg-gray-200 outline-none accent-green-600" 
                  />
                </div>
                <div className="flex justify-between text-[10px] text-gray-600 mt-1">
                  <span>1</span>
                  <span>2</span>
                  <span>3</span>
                  <span>4</span>
                  <span>5</span>
                </div>
              </div>
              
              {/* Max slider */}
              <div>
                <div className="flex justify-between mb-1">
                  <span className="text-xs font-medium">Maximum: {filters.stimulationScoreRange?.max || 5}</span>
                </div>
                <div className="relative pt-1">
                  <input 
                    type="range" 
                    min="1" 
                    max="5" 
                    step="1" 
                    value={filters.stimulationScoreRange?.max || 5}
                    onChange={(e) => {
                      const newMax = parseInt(e.target.value);
                      const currentMin = filters.stimulationScoreRange?.min || 1;
                      handleFilterChange('stimulationScoreRange', {
                        min: Math.min(currentMin, newMax), // Ensure min is at most equal to max
                        max: newMax
                      });
                    }}
                    className="w-full appearance-none rounded-full h-2 bg-gray-200 outline-none accent-green-600" 
                  />
                </div>
                <div className="flex justify-between text-[10px] text-gray-600 mt-1">
                  <span>1</span>
                  <span>2</span>
                  <span>3</span>
                  <span>4</span>
                  <span>5</span>
                </div>
              </div>
            </div>
          </div>
          
          {/* Apply Filters and Reset */}
          <div className="space-y-2">
            <Button
              type="button"
              onClick={handleApplyFilters}
              className="w-full bg-secondary hover:bg-secondary/90"
              style={{fontWeight: 'bold'}}
            >
              Apply Filters
            </Button>
            {Object.keys(filters).length > 0 && (
              <Button 
                type="button" 
                variant="outline" 
                onClick={onClearFilters} 
                className="w-full"
              >
                Reset All Filters
              </Button>
            )}
          </div>
        </div>
        
        {/* Active Filters Display */}
        {Object.keys(activeFilters).length > 0 && (
          <div className="mt-4 flex flex-wrap gap-2 items-center">
            {Object.entries(activeFilters).map(([key, value]) => {
              if (!value || (Array.isArray(value) && value.length === 0)) return null;
              return (
                <Badge 
                  key={key} 
                  variant="secondary" 
                  className="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-primary-100 text-primary-800"
                >
                  {getFilterLabel(key as keyof FiltersType, value)}
                  <button 
                    type="button" 
                    className="ml-1 focus:outline-none"
                    onClick={() => removeFilter(key as keyof FiltersType)}
                  >
                    <X className="h-3.5 w-3.5 text-gray-500" />
                  </button>
                </Badge>
              );
            })}
          </div>
        )}
      </CardContent>
    </Card>
  );
}
</file>

<file path="client/src/components/ShowSubmissionForm.tsx">
import { useState } from 'react';
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Textarea } from '@/components/ui/textarea';
import { useToast } from '@/hooks/use-toast';
import { apiRequest } from '@/lib/queryClient';
import { Plus, Send } from 'lucide-react';

interface ShowSubmissionFormProps {
  onSuccess?: () => void;
}

export function ShowSubmissionForm({ onSuccess }: ShowSubmissionFormProps) {
  const [showName, setShowName] = useState('');
  const [whereTheyWatch, setWhereTheyWatch] = useState('');
  const { toast } = useToast();
  const queryClient = useQueryClient();

  const submitMutation = useMutation({
    mutationFn: async (data: { showName: string; whereTheyWatch: string }) => {
      const response = await fetch('/api/show-submissions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'include',
        body: JSON.stringify(data),
      });
      
      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || 'Failed to submit show');
      }
      
      return await response.json();
    },
    onSuccess: (response) => {
      // Use setTimeout to avoid React's setState warning during render
      setTimeout(() => {
        if (response.isDuplicate) {
          // Show already exists in our database
          toast({
            title: "Show already exists!",
            description: `"${response.existingShow.name}" is already in our database. You can find it by searching.`,
            variant: "default",
          });
        } else if (response.isNewSubmission === false) {
          // Someone already submitted this - we increased priority
          toast({
            title: "Request noted!",
            description: "This show has been requested before. We've increased its priority for review.",
          });
        } else {
          // Brand new submission
          toast({
            title: "Show submitted successfully!",
            description: "Thank you for your suggestion. We'll review it soon.",
          });
        }

        // Reset form
        setShowName('');
        setWhereTheyWatch('');
        
        // Invalidate user submissions query to refresh any lists
        queryClient.invalidateQueries({ queryKey: ['/api/show-submissions/my'] });
        // Also refetch to ensure immediate update
        queryClient.refetchQueries({ queryKey: ['/api/show-submissions/my'] });
        
        onSuccess?.();
      }, 0);
    },
    onError: (error: any) => {
      toast({
        variant: "destructive",
        title: "Submission failed",
        description: error.message || "Something went wrong. Please try again.",
      });
    },
  });

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!showName.trim() || !whereTheyWatch.trim()) {
      toast({
        variant: "destructive",
        title: "Missing information",
        description: "Please fill in both fields.",
      });
      return;
    }

    submitMutation.mutate({
      showName: showName.trim(),
      whereTheyWatch: whereTheyWatch.trim(),
    });
  };

  return (
    <Card className="w-full max-w-md mx-auto">
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <Plus className="h-5 w-5 text-blue-600" />
          Suggest a Show
        </CardTitle>
        <CardDescription>
          Help us grow our database by suggesting shows you love!
        </CardDescription>
      </CardHeader>
      <CardContent>
        <form onSubmit={handleSubmit} className="space-y-4">
          <div className="space-y-2">
            <Label htmlFor="showName">Show Name</Label>
            <Input
              id="showName"
              type="text"
              placeholder="e.g., Bluey, Peppa Pig, etc."
              value={showName}
              onChange={(e) => setShowName(e.target.value)}
              disabled={submitMutation.isPending}
            />
          </div>

          <div className="space-y-2">
            <Label htmlFor="whereTheyWatch">Where do you watch it?</Label>
            <Textarea
              id="whereTheyWatch"
              placeholder="e.g., Netflix in Australia, Disney+ UK, PBS Kids America, YouTube, etc."
              value={whereTheyWatch}
              onChange={(e) => setWhereTheyWatch(e.target.value)}
              disabled={submitMutation.isPending}
              rows={3}
            />
          </div>

          <Button 
            type="submit" 
            className="w-full" 
            disabled={submitMutation.isPending}
          >
            {submitMutation.isPending ? (
              <>
                <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-white mr-2" />
                Submitting...
              </>
            ) : (
              <>
                <Send className="h-4 w-4 mr-2" />
                Submit Show
              </>
            )}
          </Button>
        </form>

        <div className="mt-4 p-3 bg-blue-50 rounded-lg">
          <p className="text-sm text-blue-800">
            <strong>Earn 20 points</strong> when your suggested show gets added to our database!
          </p>
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="client/src/components/SimpleShowCard.tsx">
import { TvShow } from "@shared/schema";

interface SimpleShowCardProps {
  show: TvShow;
  onClick: () => void;
}

export default function SimpleShowCard({ show, onClick }: SimpleShowCardProps) {
  console.log('SimpleShowCard received:', show);
  
  return (
    <div 
      className="bg-white border rounded-lg p-4 cursor-pointer hover:shadow-md"
      onClick={onClick}
    >
      <h3 className="font-bold text-lg">{show.name || 'No Name'}</h3>
      <p className="text-sm text-gray-600">Ages: {show.ageRange || 'Unknown'}</p>
      <p className="text-sm text-gray-600">Score: {show.stimulationScore || 0}/5</p>
      <button className="mt-2 bg-yellow-500 text-white px-4 py-2 rounded">
        Learn More
      </button>
    </div>
  );
}
</file>

<file path="client/src/components/ThemeSelector.tsx">
import { useState, useEffect } from 'react';
import { X, Plus, Check } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Badge } from '@/components/ui/badge';
import { Command, CommandEmpty, CommandGroup, CommandInput, CommandItem, CommandList } from '@/components/ui/command';
import { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover';

interface Theme {
  id: number;
  name: string;
}

interface ThemeSelectorProps {
  selectedThemes: string[];
  onThemesChange: (themes: string[]) => void;
  placeholder?: string;
}

export function ThemeSelector({ selectedThemes, onThemesChange, placeholder = "Select themes..." }: ThemeSelectorProps) {
  const [allThemes, setAllThemes] = useState<Theme[]>([]);
  const [open, setOpen] = useState(false);
  const [searchValue, setSearchValue] = useState('');
  const [isLoading, setIsLoading] = useState(true);

  // Fetch all available themes
  useEffect(() => {
    const fetchThemes = async () => {
      try {
        const response = await fetch('/api/themes');
        const themes = await response.json();
        setAllThemes(themes.sort((a: Theme, b: Theme) => a.name.localeCompare(b.name)));
      } catch (error) {
        console.error('Error fetching themes:', error);
      } finally {
        setIsLoading(false);
      }
    };

    fetchThemes();
  }, []);

  // Add a theme to the selection
  const addTheme = (themeName: string) => {
    const trimmedName = themeName.trim();
    if (trimmedName && !selectedThemes.includes(trimmedName)) {
      onThemesChange([...selectedThemes, trimmedName]);
    }
    setSearchValue('');
    setOpen(false);
  };

  // Remove a theme from the selection
  const removeTheme = (themeToRemove: string) => {
    onThemesChange(selectedThemes.filter(theme => theme !== themeToRemove));
  };

  // Add a new custom theme
  const addCustomTheme = () => {
    const trimmedValue = searchValue.trim();
    if (trimmedValue && !selectedThemes.includes(trimmedValue)) {
      // Format the theme name properly (Title Case)
      const formattedTheme = trimmedValue
        .split(' ')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
        .join(' ');
      
      addTheme(formattedTheme);
    }
  };

  // Filter themes based on search and exclude already selected ones
  const filteredThemes = allThemes.filter(theme => 
    theme.name.toLowerCase().includes(searchValue.toLowerCase()) &&
    !selectedThemes.includes(theme.name)
  );

  // Check if the search value would create a new theme
  const isNewTheme = searchValue.trim() && 
    !allThemes.some(theme => theme.name.toLowerCase() === searchValue.toLowerCase()) &&
    !selectedThemes.includes(searchValue.trim());

  return (
    <div className="space-y-2">
      {/* Selected themes display */}
      {selectedThemes.length > 0 && (
        <div className="flex flex-wrap gap-2">
          {selectedThemes.map((theme) => (
            <Badge key={theme} variant="secondary" className="flex items-center gap-1">
              {theme}
              <button
                type="button"
                onClick={() => removeTheme(theme)}
                className="ml-1 hover:text-destructive"
              >
                <X className="h-3 w-3" />
              </button>
            </Badge>
          ))}
        </div>
      )}

      {/* Theme selector */}
      <Popover open={open} onOpenChange={setOpen}>
        <PopoverTrigger asChild>
          <Button
            variant="outline"
            role="combobox"
            aria-expanded={open}
            className="w-full justify-start text-left font-normal"
          >
            <Plus className="mr-2 h-4 w-4" />
            {placeholder}
          </Button>
        </PopoverTrigger>
        <PopoverContent className="w-full p-0" align="start">
          <Command>
            <CommandInput
              placeholder="Search themes..."
              value={searchValue}
              onValueChange={setSearchValue}
            />
            <CommandList>
              <CommandEmpty>
                {isLoading ? (
                  "Loading themes..."
                ) : isNewTheme ? (
                  <div className="p-2">
                    <Button
                      type="button"
                      variant="ghost"
                      onClick={addCustomTheme}
                      className="w-full justify-start"
                    >
                      <Plus className="mr-2 h-4 w-4" />
                      Add "{searchValue.trim()}" as new theme
                    </Button>
                  </div>
                ) : (
                  "No themes found."
                )}
              </CommandEmpty>
              
              {filteredThemes.length > 0 && (
                <CommandGroup>
                  {filteredThemes.map((theme) => (
                    <CommandItem
                      key={theme.id}
                      value={theme.name}
                      onSelect={() => addTheme(theme.name)}
                    >
                      <Check className="mr-2 h-4 w-4 opacity-0" />
                      {theme.name}
                    </CommandItem>
                  ))}
                </CommandGroup>
              )}

              {/* Show option to add new theme if search doesn't match existing */}
              {isNewTheme && filteredThemes.length > 0 && (
                <CommandGroup>
                  <CommandItem onSelect={addCustomTheme}>
                    <Plus className="mr-2 h-4 w-4" />
                    Add "{searchValue.trim()}" as new theme
                  </CommandItem>
                </CommandGroup>
              )}
            </CommandList>
          </Command>
        </PopoverContent>
      </Popover>
    </div>
  );
}
</file>

<file path="client/src/hooks/use-mobile.tsx">
import * as React from "react"

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}
</file>

<file path="client/src/hooks/use-toast.ts">
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }
</file>

<file path="client/src/hooks/useAuth.ts">
import { useQuery } from "@tanstack/react-query";

export function useAuth() {
  const { data: user, isLoading } = useQuery({
    queryKey: ["/api/auth/user"],
    retry: false,
  });

  return {
    user,
    isLoading,
    isAuthenticated: !!user,
  };
}
</file>

<file path="client/src/lib/badges.ts">
export interface Badge {
  name: string;
  emoji: string;
  points: number;
  description: string;
}

export const BADGES: Badge[] = [
  { name: "Tablet Baby", emoji: "👶", points: 25, description: "Welcome to TV Tantrum!" },
  { name: "TV Tamer", emoji: "🧑‍🧒", points: 50, description: "Getting the hang of it" },
  { name: "Algorithm Avoider", emoji: "🫷", points: 100, description: "Discovering new content" },
  { name: "Mood-Swing Mediator", emoji: "🧑‍⚖️", points: 200, description: "Sharing your thoughts" },
  { name: "Rhythm Regulator", emoji: "🪪", points: 300, description: "Really getting into it" },
  { name: "Pixel Protector", emoji: "🥽", points: 400, description: "Becoming an expert" },
  { name: "Screen-Time Sherpa", emoji: "🤝", points: 500, description: "True connoisseur" },
  { name: "Programme Peacekeeper", emoji: "✌️", points: 750, description: "Master of family viewing" },
  { name: "Calm-Ware Engineer", emoji: "🧑‍🔧", points: 1000, description: "Ruling the remote" },
  { name: "Digital Diplomat", emoji: "🧑‍💼", points: 1250, description: "Mystical viewing powers" },
  { name: "Sensory Sentinel", emoji: "🦾", points: 1500, description: "Artistic taste" },
  { name: "Guardian of the Glow", emoji: "🥷", points: 1750, description: "Wisdom of the streams" },
  { name: "Screen Sensei", emoji: "🧘", points: 2000, description: "Ultimate TV master" }
];

export function getCurrentBadge(points: number): Badge {
  // Find the highest badge the user has earned
  const earnedBadges = BADGES.filter(badge => points >= badge.points);
  return earnedBadges.length > 0 ? earnedBadges[earnedBadges.length - 1] : BADGES[0];
}

export function getNextBadge(points: number): Badge | null {
  // Find the next badge to unlock
  const nextBadge = BADGES.find(badge => points < badge.points);
  return nextBadge || null;
}

export function getBadgeName(points: number): string {
  const badge = getCurrentBadge(points);
  return badge.name;
}

export function getBadgeEmoji(points: number): string {
  const badge = getCurrentBadge(points);
  return badge.emoji;
}
</file>

<file path="client/src/lib/protected-route-admin.tsx">
import { useAuth } from "@/hooks/use-auth";
import { Loader2 } from "lucide-react";
import { Redirect, Route } from "wouter";
import { useToast } from "@/hooks/use-toast";
import { useEffect } from "react";
import { useQuery } from "@tanstack/react-query";

export function AdminRoute({
  path,
  component: Component,
}: {
  path: string;
  component: () => React.JSX.Element;
}) {
  const { user, isLoading } = useAuth();
  // We'll need to check if user is admin via an API call
  const { data: isAdmin } = useQuery({
    queryKey: ["/api/user/is-admin"],
    enabled: !!user,
  });
  const { toast } = useToast();

  useEffect(() => {
    // If user is logged in but not an admin, show toast
    if (user && isAdmin === false) {
      toast({
        title: "Access Denied",
        description: "You do not have admin privileges to access this page.",
        variant: "destructive",
      });
    }
  }, [user, isAdmin, toast]);

  if (isLoading) {
    return (
      <Route path={path}>
        <div className="flex items-center justify-center min-h-screen">
          <Loader2 className="h-8 w-8 animate-spin text-border" />
        </div>
      </Route>
    );
  }

  // If not logged in, redirect to auth page
  if (!user) {
    return (
      <Route path={path}>
        <Redirect to="/auth" />
      </Route>
    );
  }

  // If logged in but not an admin, redirect to home
  if (isAdmin === false) {
    return (
      <Route path={path}>
        <Redirect to="/home" />
      </Route>
    );
  }

  // If logged in, approved, and an admin, show the component
  return <Route path={path}><Component /></Route>;
}
</file>

<file path="client/src/lib/protected-route-approved.tsx">
import { useAuth } from "@/hooks/use-auth";
import { Loader2 } from "lucide-react";
import { Redirect, Route } from "wouter";
import { useToast } from "@/hooks/use-toast";
import { useEffect } from "react";

export function ApprovedRoute({
  path,
  component: Component,
}: {
  path: string;
  component: () => React.JSX.Element;
}) {
  const { user, isLoading } = useAuth();
  const { toast } = useToast();
  
  useEffect(() => {
    // If user is logged in but not approved, show toast and redirect
    if (user && user.isApproved === false) {
      toast({
        title: "Access Denied",
        description: "Your account is pending approval by an administrator.",
        variant: "destructive",
      });
    }
  }, [user, toast]);

  // Show loading state when authenticating OR when we have no user and not done loading
  if (isLoading || (!user && !isLoading)) {
    return (
      <Route path={path}>
        <div className="flex items-center justify-center min-h-screen">
          <Loader2 className="h-8 w-8 animate-spin text-border" />
        </div>
      </Route>
    );
  }

  // Only redirect if we're definitively not logged in (not loading and no user)
  if (!isLoading && !user) {
    return (
      <Route path={path}>
        <Redirect to="/early-access" />
      </Route>
    );
  }

  // Auto-approve all logged in users (GHL integration handles verification)
  // If logged in, show the component
  return <Route path={path}><Component /></Route>;
}
</file>

<file path="client/src/lib/protected-route.tsx">
import { useAuth } from "@/hooks/use-auth";
import { Loader2 } from "lucide-react";
import { Redirect, Route, useLocation } from "wouter";

export function ProtectedRoute({
  path,
  component: Component,
}: {
  path: string;
  component: () => React.JSX.Element;
}) {
  const { user, isLoading } = useAuth();
  const [location] = useLocation();

  if (isLoading) {
    return (
      <Route path={path}>
        <div className="flex items-center justify-center min-h-screen">
          <Loader2 className="h-8 w-8 animate-spin text-border" />
        </div>
      </Route>
    );
  }

  if (!user) {
    return (
      <Route path={path}>
        <Redirect to={`/auth?redirect=${encodeURIComponent(location)}`} />
      </Route>
    );
  }

  return <Route path={path} component={Component} />;
}
</file>

<file path="client/src/lib/queryClient.ts">
import { QueryClient, QueryFunction } from "@tanstack/react-query";

async function throwIfResNotOk(res: Response) {
  if (!res.ok) {
    let errorMessage = res.statusText || 'Request failed';
    try {
      // Clone the response to avoid consuming the body
      const clonedRes = res.clone();
      const text = await clonedRes.text();
      if (text) {
        errorMessage = text;
      }
    } catch (e) {
      console.error('Error reading response text:', e);
    }
    throw new Error(`${res.status}: ${errorMessage}`);
  }
}

export async function apiRequest<T = any>(
  method: string,
  url: string,
  data?: unknown | undefined,
): Promise<Response> {
  // Ensure we always send cookies/credentials with every request
  const headers: HeadersInit = {
    'Accept': 'application/json'
  };
  
  if (data) {
    headers['Content-Type'] = 'application/json';
  }
  
  // Return the actual Response object instead of parsing JSON
  // This allows the caller to handle the response as needed
  return fetch(url, {
    method,
    headers,
    body: data ? JSON.stringify(data) : undefined,
    credentials: "include", // Always include credentials (cookies)
  });
}

export async function apiGet<T = any>(url: string): Promise<T> {
  const response = await apiRequest('GET', url);
  await throwIfResNotOk(response);
  return await response.json();
}

type UnauthorizedBehavior = "returnNull" | "throw";
export const getQueryFn: <T>(options: {
  on401: UnauthorizedBehavior;
}) => QueryFunction<T> =
  ({ on401: unauthorizedBehavior }) =>
  async ({ queryKey }) => {
    // Handle basic URL vs. URL with filters
    let url = queryKey[0] as string;
    
    // If there are filters in the second element of the queryKey
    if (queryKey.length > 1 && typeof queryKey[1] === 'object' && queryKey[1] !== null) {
      const filters = queryKey[1] as Record<string, any>;
      
      // Build query parameters 
      if (Object.keys(filters).length > 0) {
        const searchParams = new URLSearchParams();
        
        Object.entries(filters).forEach(([key, value]) => {
          if (value !== undefined && value !== null) {
            if (Array.isArray(value)) {
              searchParams.append(key, value.join(','));
            } else if (typeof value === 'object') {
              // For objects like stimulationScoreRange
              searchParams.append(key, JSON.stringify(value));
            } else {
              searchParams.append(key, String(value));
            }
          }
        });
        
        // Append query string to URL
        const queryString = searchParams.toString();
        if (queryString) {
          url = `${url}?${queryString}`;
          console.log('Debug - URL with filters:', url);
        }
      }
    }
    
    const res = await fetch(url, {
      credentials: "include",
    });

    if (unauthorizedBehavior === "returnNull" && res.status === 401) {
      return null;
    }

    await throwIfResNotOk(res);
    return await res.json();
  };

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      queryFn: getQueryFn({ on401: "throw" }),
      refetchInterval: false,
      refetchOnWindowFocus: false,
      staleTime: Infinity,
      retry: false,
    },
    mutations: {
      retry: false,
    },
  },
});
</file>

<file path="client/src/lib/showUtils.ts">
import { TvShow } from "@shared/schema";

/**
 * Returns a color class based on the stimulation score value
 * Lower stimulation score is better for calmness
 */
export function getStimulationScoreColor(value: number): string {
  if (value <= 2) return "green-rating";
  if (value <= 4) return "yellow-rating";
  return "red-rating";
}

/**
 * Returns a color class based on overall rating
 */
export function getPositiveRatingColor(value: number): string {
  if (value >= 4) return "purple-rating";
  if (value >= 3) return "yellow-rating";
  return "red-rating";
}

/**
 * Returns a text description for the stimulation score
 */
export function getStimulationScoreDescription(value: number): string {
  if (value === 1) {
    return "Low stimulation - calming content with gentle pacing.";
  } else if (value === 2) {
    return "Low-Medium stimulation - mostly calm content with occasional moderate energy.";
  } else if (value === 3) {
    return "Medium stimulation - balanced content with moderate energy.";
  } else if (value === 4) {
    return "Medium-High stimulation - moderately energetic content with some intense moments.";
  } else {
    return "High stimulation - energetic content that may be overstimulating for some children.";
  }
}

/**
 * Returns a description for interactivity level
 */
export function getInteractivityLevelDescription(value: string): string {
  switch (value) {
    case "Low":
      return "Minimal audience interaction, children mostly observe passively.";
    case "Moderate-Low":
      return "Some audience engagement, primarily through questions or simple responses.";
    case "Moderate":
      return "Balanced audience engagement with regular interaction throughout the show.";
    case "Moderate-High":
      return "Frequent audience engagement with multiple interactive elements.";
    case "High":
      return "Very interactive format that encourages active participation throughout.";
    default:
      return "Moderate level of interactivity.";
  }
}

/**
 * Returns a description for dialogue intensity
 */
export function getDialogueIntensityDescription(value: string): string {
  switch (value) {
    case "Low":
      return "Minimal dialogue, relies more on visuals and music.";
    case "Moderate-Low":
      return "Simple dialogue with plenty of pauses and visual storytelling.";
    case "Moderate":
      return "Balanced dialogue that's appropriate for the target age group.";
    case "Moderate-High":
      return "Conversation-heavy with more complex language patterns.";
    case "High":
      return "Very dialogue-rich content with complex vocabulary or frequent conversations.";
    default:
      return "Moderate level of dialogue.";
  }
}

/**
 * Returns a description for sound effects level
 */
export function getSoundEffectsLevelDescription(value: string): string {
  switch (value) {
    case "Low":
      return "Minimal sound effects, creating a calm viewing experience.";
    case "Moderate-Low":
      return "Gentle sound effects that enhance the content without overwhelming.";
    case "Moderate":
      return "Balanced use of sound effects to support the storytelling.";
    case "Moderate-High":
      return "Frequent sound effects that play a significant role in the experience.";
    case "High":
      return "Sound effect-heavy show with prominent audio elements throughout.";
    default:
      return "Moderate level of sound effects.";
  }
}

/**
 * Generate a default placeholder image URL for a show
 */
export function getDefaultShowImage(showName: string): string {
  // This function would typically return a real image URL
  // But since we can't use images, returning empty string
  return "";
}

/**
 * Filter shows based on provided filters
 */
export function filterShows(
  shows: TvShow[],
  filters: {
    ageGroup?: string;
    tantrumFactor?: string;
    search?: string;
    themes?: string[];
    interactionLevel?: string;
    stimulationScoreRange?: {min: number, max: number};
  }
): TvShow[] {
  return shows.filter(show => {
    // Filter by age group
    if (filters.ageGroup && show.ageRange) {
      if (filters.ageGroup === 'Toddler' && !show.ageRange.match(/^[0-3]|toddler/i)) {
        return false;
      }
      if (filters.ageGroup === 'Preschool' && !show.ageRange.match(/^[2-5]|preschool/i)) {
        return false;
      }
      if (filters.ageGroup === 'School-Age' && !show.ageRange.match(/^[5-9]|school/i)) {
        return false;
      }
      if (filters.ageGroup === 'Tween' && !show.ageRange.match(/^[8-9]|10-1[2-3]|tween/i)) {
        return false;
      }
    }
    
    // Filter by tantrum factor (stimulation score)
    if (filters.tantrumFactor) {
      if (filters.tantrumFactor.toLowerCase() === 'low' && show.stimulationScore !== 1) {
        return false;
      }
      if (filters.tantrumFactor.toLowerCase() === 'low-medium' && show.stimulationScore !== 2) {
        return false;
      }
      if (filters.tantrumFactor.toLowerCase() === 'medium' && show.stimulationScore !== 3) {
        return false;
      }
      if (filters.tantrumFactor.toLowerCase() === 'medium-high' && show.stimulationScore !== 4) {
        return false;
      }
      if (filters.tantrumFactor.toLowerCase() === 'high' && show.stimulationScore !== 5) {
        return false;
      }
    }
    
    // Filter by themes
    if (filters.themes && filters.themes.length > 0) {
      if (!show.themes || show.themes.length === 0) {
        return false;
      }
      
      // Check if ALL selected themes are present in the show's themes
      const showThemesLower = show.themes.map(t => t.toLowerCase());
      if (!filters.themes.every(theme => showThemesLower.some(t => t.includes(theme.toLowerCase())))) {
        return false;
      }
    }
    
    // Filter by interactivity level
    if (filters.interactionLevel && show.interactivityLevel) {
      // Handle exact match or level-based match
      if (filters.interactionLevel === 'Low' && 
          !['Low', 'Limited', 'Minimal'].some(term => show.interactivityLevel?.includes(term))) {
        return false;
      }
      if (filters.interactionLevel === 'Moderate' && 
          !['Moderate', 'Medium', 'Some'].some(term => show.interactivityLevel?.includes(term))) {
        return false;
      }
      if (filters.interactionLevel === 'High' && 
          !['High', 'Heavy', 'Strong', 'Frequent'].some(term => show.interactivityLevel?.includes(term))) {
        return false;
      }
    }
    

    
    // Filter by stimulation score range
    if (filters.stimulationScoreRange && show.stimulationScore) {
      if (show.stimulationScore < filters.stimulationScoreRange.min || 
          show.stimulationScore > filters.stimulationScoreRange.max) {
        return false;
      }
    }
    
    // Search by show name or description
    if (filters.search && filters.search.trim()) {
      const searchTerm = filters.search.trim().toLowerCase();
      const showName = show.name.toLowerCase();
      const showDescription = (show.description || '').toLowerCase();

      // Check for exact match first - highest priority
      if (showName === searchTerm) {
        return true;
      }
      
      // Direct match in name or description
      if (showName.includes(searchTerm) || showDescription.includes(searchTerm)) {
        return true;
      }
      
      // Handle shows with year ranges (e.g., "Show Name 2018-present")
      const nameWithoutYears = showName.replace(/\s+\d{4}(-\d{4}|-present)?/g, '');
      if (nameWithoutYears.includes(searchTerm)) {
        return true;
      }
      
      // Match any part of a word (for show names like "Blue's Clues")
      const words = showName.split(/\s+/);
      if (words.some(word => word.includes(searchTerm))) {
        return true;
      }
      
      // Handle apostrophes and special characters
      const simplifiedName = showName.replace(/[''\.]/g, '');
      if (simplifiedName.includes(searchTerm)) {
        return true;
      }
      
      // Check themes for matches
      if (show.themes && show.themes.some(theme => theme.toLowerCase().includes(searchTerm))) {
        return true;
      }
      
      // If no match found, exclude this show
      return false;
    }
    
    return true;
  });
}

/**
 * Sort shows based on provided sort option
 */
export function sortShows(
  shows: TvShow[],
  sortBy?: string
): TvShow[] {
  if (!sortBy) return shows;
  
  return [...shows].sort((a, b) => {
    switch (sortBy) {
      case 'name':
        return a.name.localeCompare(b.name);
      case 'stimulation-score':
        return a.stimulationScore - b.stimulationScore; // Lower is better
      case 'interactivity-level':
        // Sort by interactivity level - Low, Moderate, High
        const levelMap: {[key: string]: number} = {
          'Low': 1,
          'Moderate-Low': 2,
          'Moderate': 3,
          'Moderate-High': 4,
          'High': 5
        };
        const aLevel = levelMap[a.interactivityLevel || 'Moderate'] || 3;
        const bLevel = levelMap[b.interactivityLevel || 'Moderate'] || 3;
        return aLevel - bLevel;
      case 'popular':
        // Popular would be handled by a separate API endpoint, so this is a fallback
        // The views+searches metrics impact popularity
        const aPopularity = ((a as any).views || 0) * 2 + ((a as any).searches || 0);
        const bPopularity = ((b as any).views || 0) * 2 + ((b as any).searches || 0);
        return bPopularity - aPopularity; // Higher popularity first
      case 'overall-rating':
        return b.overallRating - a.overallRating;
      default:
        return 0;
    }
  });
}
</file>

<file path="client/src/lib/utils.ts">
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
</file>

<file path="client/src/pages/admin-page.tsx">
import { useState, useEffect } from 'react';
import { useToast } from '@/hooks/use-toast';
import { useAuth } from '@/hooks/use-auth';
import { useLocation, Link } from 'wouter';
import { Button } from '@/components/ui/button';
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
  CardFooter,
} from '@/components/ui/card';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from '@/components/ui/table';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from '@/components/ui/dialog';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { 
  Select, 
  SelectContent, 
  SelectItem, 
  SelectTrigger, 
  SelectValue 
} from '@/components/ui/select';
import { Textarea } from '@/components/ui/textarea';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { ThemeSelector } from '@/components/ThemeSelector';
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';
import { 
  Loader2, 
  Search, 
  Edit, 
  RefreshCw, 
  ImageIcon, 
  User, 
  CheckCircle,
  Trash,
  Database, 
  XCircle, 
  Clock,
  Shield,
  Check,
  FileText,
  X,
  PlusCircle,
  Upload,
  Image,
  Trash2,
  Info,
  Video,
  Key,
  Copy
} from 'lucide-react';
import { ImageUpload } from '@/components/image-upload';
import { TvShow, User as UserType } from '@shared/schema';
import { apiRequest, queryClient } from '@/lib/queryClient';

export default function AdminPage() {
  const { user, isAdmin } = useAuth();
  const { toast } = useToast();
  const [, setLocation] = useLocation();
  const [shows, setShows] = useState<TvShow[]>([]);
  const [filteredShows, setFilteredShows] = useState<TvShow[]>([]);
  const [searchTerm, setSearchTerm] = useState('');
  const [isLoading, setIsLoading] = useState(true);
  const [isUpdating, setIsUpdating] = useState(false);
  const [selectedShow, setSelectedShow] = useState<TvShow | null>(null);
  const [isDialogOpen, setIsDialogOpen] = useState(false);
  const [isRefreshing, setIsRefreshing] = useState(false);
  const [isUpdatingMetadata, setIsUpdatingMetadata] = useState(false);
  const [isUpdatingYouTubeMetadata, setIsUpdatingYouTubeMetadata] = useState(false);
  const [isAddDialogOpen, setIsAddDialogOpen] = useState(false);
  const [isAddingShow, setIsAddingShow] = useState(false);
  const [isDeleting, setIsDeleting] = useState(false);
  const [showDeleteConfirm, setShowDeleteConfirm] = useState(false);
  const [isLookingUp, setIsLookingUp] = useState(false);
  const [lookupResults, setLookupResults] = useState<{omdb: any | null, youtube: any | null}>({omdb: null, youtube: null});
  const [showLookupOptions, setShowLookupOptions] = useState(false);
  const [newShowFormState, setNewShowFormState] = useState({
    name: '',
    description: '',
    ageRange: '',
    stimulationScore: 3,
    interactivityLevel: 'Medium',
    dialogueIntensity: 'Medium',
    soundEffectsLevel: 'Medium',
    sceneFrequency: 'Medium',
    musicTempo: 'Medium',
    totalMusicLevel: 'Medium',
    totalSoundEffectTimeLevel: 'Medium',
    animationStyle: '',
    themes: [] as string[],
    imageUrl: '',
    // Adding required database fields with default values to avoid null constraints
    episodeLength: 15, // Default episode length in minutes
    seasons: 1, // Default number of seasons
    releaseYear: new Date().getFullYear(), // Current year
    endYear: null as number | null, // Null is acceptable for endYear
    isOngoing: true, // Default to ongoing
    creator: '', // Empty string for creator
    availableOn: [] as string[], // Empty array for available platforms
    // YouTube-specific fields
    subscriberCount: '',
    videoCount: '',
    isYouTubeChannel: false,
    publishedAt: '',
    channelId: '',
    // API data tracking flags
    hasOmdbData: false,
    hasYoutubeData: false
    // Note: we use stimulationScore for overallRating in the backend
  });
  
  // Redirect if user is not an admin
  useEffect(() => {
    if (user && !isAdmin) {
      toast({
        title: "Access Denied",
        description: "You do not have admin privileges to access this page.",
        variant: "destructive",
      });
      setLocation("/home");
    }
  }, [user, isAdmin, toast, setLocation]);
  const [isOptimizingImages, setIsOptimizingImages] = useState(false);
  const [users, setUsers] = useState<Array<Omit<UserType, 'password'>>>([]);
  const [userSearchTerm, setUserSearchTerm] = useState('');
  const [filteredUsers, setFilteredUsers] = useState<Array<Omit<UserType, 'password'>>>([]);
  const [isLoadingUsers, setIsLoadingUsers] = useState(true);
  
  // Research management state
  const [researchEntries, setResearchEntries] = useState<any[]>([]);
  const [filteredResearch, setFilteredResearch] = useState<any[]>([]);
  const [researchSearchTerm, setResearchSearchTerm] = useState('');
  const [isLoadingResearch, setIsLoadingResearch] = useState(true);
  const [isApprovingUser, setIsApprovingUser] = useState(false);
  const [isResettingPassword, setIsResettingPassword] = useState(false);
  const [resetPasswordUserId, setResetPasswordUserId] = useState<number | null>(null);
  const [tempPassword, setTempPassword] = useState<string>('');



  // Form state
  const [formState, setFormState] = useState({
    name: '',
    description: '',
    ageRange: '',
    stimulationScore: 3, // Default stimulation score - always a whole number
    interactivityLevel: 'Medium',
    dialogueIntensity: 'Medium',
    soundEffectsLevel: 'Medium',
    sceneFrequency: 'Medium',
    musicTempo: 'Medium',
    totalMusicLevel: 'Medium',
    totalSoundEffectTimeLevel: 'Medium',
    animationStyle: '',
    themes: [] as string[],
    imageUrl: '',
    // Additional fields for API data
    creator: '',
    releaseYear: null as number | null,
    endYear: null as number | null,
    episodeLength: 30,
    isOngoing: true,
    // YouTube-specific fields
    subscriberCount: '',
    videoCount: '',
    isYouTubeChannel: false,
    publishedAt: '',
    channelId: '',
    availableOn: [] as string[],
    // API data tracking flags
    hasOmdbData: false,
    hasYoutubeData: false
  });

  // Check if user is admin
  useEffect(() => {
    if (!isLoading && !isAdmin) {
      toast({
        title: "Access Denied",
        description: "You need admin privileges to access this page.",
        variant: "destructive"
      });
      setLocation('/');
    }
  }, [isLoading, isAdmin, setLocation, toast]);

  // Function to fetch users (used in both effect and manual refresh)
  const fetchUsers = async () => {
    if (!isAdmin) return;
    
    setIsLoadingUsers(true);
    try {
      // First make sure we're authenticated and have the latest session
      const userCheckResponse = await apiRequest('GET', '/api/user');
      if (!userCheckResponse.ok) {
        console.warn('User authentication required');
        // Redirect to login if not authenticated
        setLocation('/auth');
        return;
      }
      
      // Now fetch users with the authenticated session, adding debug flag for development
      // This is a temporary solution to bypass authentication checks during development
      const isDev = process.env.NODE_ENV === 'development' || window.location.hostname.includes('replit');
      const endpoint = isDev ? '/api/users?debug=true' : '/api/users';
      
      console.log('Attempting to fetch users from:', endpoint);
      const response = await apiRequest('GET', endpoint);
      
      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Failed to fetch users: ${errorText || response.statusText} (Status: ${response.status})`);
      }
      
      const data = await response.json();
      console.log('Successfully fetched users:', data.length);
      setUsers(data);
      setFilteredUsers(data);
    } catch (error) {
      console.error('Error fetching users:', error);
      toast({
        title: "Error",
        description: "Failed to load users. Please try again.",
        variant: "destructive"
      });
    } finally {
      setIsLoadingUsers(false);
    }
  };
    
  // Load all users and research entries (admin only)
  useEffect(() => {
    // Only attempt to fetch users when we know for sure the user is an admin
    if (isAdmin && user?.id) {
      console.log("Admin user detected, fetching all users and research entries...");
      setTimeout(() => {
        fetchUsers();
        fetchResearch();
      }, 500); // Small delay to ensure session is fully established
    }
  }, [isAdmin, user?.id]);

  // Filter users based on search term
  useEffect(() => {
    if (userSearchTerm.trim() === '') {
      setFilteredUsers(users);
    } else {
      const term = userSearchTerm.toLowerCase();
      const filtered = users.filter(user => 
        user.username?.toLowerCase().includes(term) || 
        user.email.toLowerCase().includes(term)
      );
      setFilteredUsers(filtered);
    }
  }, [userSearchTerm, users]);
  
  // Filter research entries based on search term
  useEffect(() => {
    if (researchSearchTerm.trim() === '') {
      setFilteredResearch(researchEntries);
    } else {
      const term = researchSearchTerm.toLowerCase();
      const filtered = researchEntries.filter(entry => 
        entry.title?.toLowerCase().includes(term) || 
        entry.category?.toLowerCase().includes(term) ||
        entry.source?.toLowerCase().includes(term) ||
        entry.summary?.toLowerCase().includes(term)
      );
      setFilteredResearch(filtered);
    }
  }, [researchSearchTerm, researchEntries]);
  
  // Function to fetch research entries
  const fetchResearch = async () => {
    console.log("Fetching all research entries...");
    setIsLoadingResearch(true);
    try {
      const response = await fetch('/api/research');
      if (!response.ok) {
        throw new Error(`Error ${response.status}: ${response.statusText}`);
      }
      const data = await response.json();
      console.log(`Successfully fetched ${data.length} research entries from database`);
      setResearchEntries(data);
      setFilteredResearch(data);
      return data;
    } catch (error) {
      console.error('Error fetching research entries:', error);
      toast({
        title: "Error",
        description: "Failed to load research entries. Please try again.",
        variant: "destructive"
      });
      return [];
    } finally {
      setIsLoadingResearch(false);
    }
  };
  
  // Handle editing a research entry
  const handleEditResearch = (id: number) => {
    console.log('Editing research entry with ID:', id);
    // Navigate to the research editor page with the ID parameter
    // This approach ensures we don't have routing issues with React
    localStorage.setItem('editResearchId', id.toString());
    setLocation('/admin/research');
  };
  
  // Handle deleting a research entry
  const handleDeleteResearch = (id: number, title: string) => {
    // Show confirmation dialog
    if (window.confirm(`Are you sure you want to delete the research entry "${title}"? This action cannot be undone.`)) {
      // Perform the delete operation
      fetch(`/api/research/${id}`, {
        method: 'DELETE',
      })
      .then(response => {
        if (!response.ok) {
          throw new Error('Failed to delete research entry');
        }
        // Update the research entries list
        setResearchEntries(prev => prev.filter(entry => entry.id !== id));
        setFilteredResearch(prev => prev.filter(entry => entry.id !== id));
        
        // Invalidate queries to ensure data consistency
        queryClient.invalidateQueries({ queryKey: ['/api/research'] });
        
        toast({
          title: "Research Entry Deleted",
          description: `Successfully deleted "${title}"`,
        });
      })
      .catch(error => {
        console.error('Error deleting research entry:', error);
        toast({
          title: "Error",
          description: "Failed to delete research entry. Please try again.",
          variant: "destructive"
        });
      });
    }
  };



  // Load all shows
  useEffect(() => {
    const loadInitialShows = async () => {
      try {
        const data = await fetch('/api/tv-shows').then(res => res.json());
        setShows(data);
        setFilteredShows(data);
        setIsLoading(false);
      } catch (error) {
        console.error('Error fetching shows:', error);
        toast({
          title: "Error",
          description: "Failed to load shows. Please try again.",
          variant: "destructive"
        });
        setIsLoading(false);
      }
    };

    loadInitialShows();
  }, [toast]);



  // Handle search
  useEffect(() => {
    if (searchTerm.trim() === '') {
      setFilteredShows(shows);
    } else {
      const term = searchTerm.toLowerCase();
      const filtered = shows.filter(show => 
        show.name.toLowerCase().includes(term) || 
        (show.description && show.description.toLowerCase().includes(term))
      );
      setFilteredShows(filtered);
    }
  }, [searchTerm, shows]);

  // Refresh data from GitHub
  const handleRefreshData = async () => {
    setIsRefreshing(true);
    try {
      const response = await apiRequest('POST', '/api/refresh-data');
      const data = await response.json();
      
      toast({
        title: "Data Refreshed",
        description: `Successfully refreshed ${data.count} shows from GitHub.`,
      });
      
      // Reload shows
      const updatedShows = await fetch('/api/shows').then(res => res.json());
      setShows(updatedShows);
      setFilteredShows(updatedShows);
    } catch (error) {
      console.error('Error refreshing data:', error);
      toast({
        title: "Error",
        description: "Failed to refresh data from GitHub.",
        variant: "destructive"
      });
    } finally {
      setIsRefreshing(false);
    }
  };
  
  // Optimize show images using OMDB posters
  const handleOptimizeImages = async () => {
    setIsOptimizingImages(true);
    try {
      const response = await apiRequest('POST', '/api/optimize-images');
      const data = await response.json();
      
      toast({
        title: "Images Optimized",
        description: `Processed ${data.total} shows. Successfully updated ${data.successful} images.`,
      });
      
      // Reload shows to get the updated image URLs
      const updatedShows = await fetch('/api/shows').then(res => res.json());
      setShows(updatedShows);
      setFilteredShows(updatedShows);
    } catch (error) {
      console.error('Error optimizing images:', error);
      toast({
        title: "Error",
        description: "Failed to optimize images. Please try again.",
        variant: "destructive"
      });
    } finally {
      setIsOptimizingImages(false);
    }
  };
  
  // Optimize all custom images for SEO performance
  const handleOptimizeCustomImages = async () => {
    setIsOptimizingImages(true);
    try {
      const response = await apiRequest('POST', '/api/admin/optimize-custom-images');
      const data = await response.json();
      
      toast({
        title: "SEO Image Optimization",
        description: `Successfully optimized ${data.optimized} custom images for better performance. (${data.skipped} skipped, ${data.errors} errors)`,
      });
      
      // Reload shows to display updated images
      const updatedShows = await fetch('/api/shows').then(res => res.json());
      setShows(updatedShows);
      setFilteredShows(updatedShows);
    } catch (error) {
      console.error('Error optimizing custom images:', error);
      toast({
        title: "Error",
        description: "Failed to optimize custom images for SEO. Please try again.",
        variant: "destructive"
      });
    } finally {
      setIsOptimizingImages(false);
    }
  };
  
  
  
  // Function to fetch TV shows from API
  const fetchShows = async () => {
    try {
      const response = await fetch('/api/tv-shows');
      const data = await response.json() as TvShow[];
      
      // Log the API data for debugging
      console.log('TV Shows API data:', data.slice(0, 3));
      
      setShows(data);
      setFilteredShows(data);
      return data;
    } catch (error) {
      console.error('Error fetching shows:', error);
      toast({
        title: "Error",
        description: "Failed to load TV shows",
        variant: "destructive"
      });
      return [];
    }
  };
  
  // Update show metadata (creator, release_year, end_year) with OMDb data
  const handleUpdateMetadata = async () => {
    if (isUpdatingMetadata) return;
    
    // Confirm the update with the user
    if (!window.confirm("This will update all TV shows with data from OMDb and YouTube APIs. Continue?")) {
      return;
    }
    
    setIsUpdatingMetadata(true);
    try {
      toast({
        title: "Update Started",
        description: "Updating TV show data from APIs. This may take a few minutes.",
      });
      
      const response = await apiRequest('POST', '/api/update-metadata');
      const result = await response.json();
      
      toast({
        title: "Show Metadata Update Complete",
        description: `Processed ${result.total} shows. Updated ${result.successful.length} successfully!`,
      });
      
      // Refresh the show list to get updated metadata
      await fetchShows();
      
    } catch (error) {
      console.error('Error updating show metadata:', error);
      toast({
        title: "Error",
        description: "Failed to update show metadata. Please try again later.",
        variant: "destructive"
      });
    } finally {
      setIsUpdatingMetadata(false);
    }
  };
  
  // Update YouTube-specific metadata (subscriber_count, video_count, etc.)
  const handleUpdateYouTubeMetadata = async () => {
    if (isUpdatingYouTubeMetadata) return;
    
    setIsUpdatingYouTubeMetadata(true);
    try {
      const response = await apiRequest('POST', '/api/update-youtube-metadata');
      const result = await response.json();
      
      toast({
        title: "YouTube Data Update Complete",
        description: `${result.updated} YouTube channels updated with subscriber counts and video information.`,
      });
      
      // Refresh the show list to get updated metadata
      await fetchShows();
      
    } catch (error) {
      console.error('Error updating YouTube metadata:', error);
      toast({
        title: "Error",
        description: "Failed to update YouTube data. Please try again later.",
        variant: "destructive"
      });
    } finally {
      setIsUpdatingYouTubeMetadata(false);
    }
  };

  // Normalize stimulation metrics between different naming conventions
  const normalizeMetrics = (value: string | null | undefined): string => {
    if (!value) return 'Medium';
    
    // Trim and convert to lowercase for consistent comparison
    const normalizedValue = value.trim().toLowerCase();
    
    // Map various formats to standard values
    if (normalizedValue.includes('low-moderate') || normalizedValue.includes('low to moderate')) {
      return 'Low-Moderate';
    } else if (normalizedValue.includes('moderate-low')) {
      return 'Low-Moderate';
    } else if (normalizedValue.includes('moderate-high') || normalizedValue.includes('moderate to high')) {
      return 'Moderate-High';
    } else if (normalizedValue.includes('high-moderate')) {
      return 'Moderate-High';
    } else if (normalizedValue === 'low') {
      return 'Low';
    } else if (normalizedValue === 'high') {
      return 'High';
    } else if (normalizedValue.includes('moderate')) {
      return 'Medium'; // Convert 'Moderate' to 'Medium' for consistency
    }
    
    return 'Medium'; // Default fallback
  };

  // Helper function to ensure we always have a valid string value
  const ensureValue = (value: string | null | undefined, defaultValue: string = 'Medium'): string => {
    // Return the value if it exists and is not an empty string, otherwise return the default
    return value && value.trim() !== '' ? value : defaultValue;
  };

  // Handler for adding a new show
  const handleAddNewShow = () => {
    // Reset the form state to default values
    setNewShowFormState({
      name: '',
      description: '',
      ageRange: '3-5 years',
      stimulationScore: 3,
      interactivityLevel: 'Medium',
      dialogueIntensity: 'Medium',
      soundEffectsLevel: 'Medium',
      sceneFrequency: 'Medium',
      musicTempo: 'Medium',
      totalMusicLevel: 'Medium',
      totalSoundEffectTimeLevel: 'Medium',
      animationStyle: '',
      themes: [],
      imageUrl: '',
      // Database required fields with default values
      episodeLength: 15,
      seasons: 1,
      releaseYear: new Date().getFullYear(),
      endYear: null,
      isOngoing: true,
      creator: '',
      availableOn: []
      // Note: we now use stimulationScore for overallRating in the backend
    });
    
    // Reset lookup results when opening a new form
    setLookupResults({omdb: null, youtube: null});
    setShowLookupOptions(false);
    
    // Open the add show dialog
    setIsAddDialogOpen(true);
  };
  
  // Submit handler for adding a new show
  const handleSubmitNewShow = async () => {
    setIsAddingShow(true);
    
    try {
      // Ensure stimulation score is a whole number
      const formDataWithWholeScore = {
        ...newShowFormState,
        stimulationScore: Math.round(newShowFormState.stimulationScore)
      };
      
      // Convert form values to API format
      const apiFormData = convertFormValuesToApi(formDataWithWholeScore);
      
      // Submit to API using fetch directly
      const response = await fetch('/api/shows', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(apiFormData),
        credentials: 'include'
      });
      
      if (!response.ok) {
        let errorMessage = 'Failed to add new show';
        try {
          const errorText = await response.text();
          if (errorText) errorMessage = errorText;
        } catch (e) {
          console.error('Error reading error response:', e);
        }
        throw new Error(errorMessage);
      }
      
      // Parse the JSON response
      const newShow = await response.json();
      
      console.log('New show added successfully:', newShow);
      
      // Add the new show to the state
      setShows(prev => [...prev, newShow]);
      setFilteredShows(prev => [...prev, newShow]);
      
      // Close the dialog
      setIsAddDialogOpen(false);
      
      // Show success message
      toast({
        title: "Show Added",
        description: `Successfully added "${newShow.name}" to the database.`,
      });
    } catch (error) {
      console.error('Error adding new show:', error);
      toast({
        title: "Error",
        description: error instanceof Error ? error.message : "Failed to add new show",
        variant: "destructive"
      });
    } finally {
      setIsAddingShow(false);
    }
  };
  
  // Handler for uploading image for a show
  const handleUploadImage = async (showId: number, imageUrl: string) => {
    try {
      if (!imageUrl.trim()) {
        toast({
          title: "Error",
          description: "Please provide a valid image URL",
          variant: "destructive"
        });
        return;
      }
      
      const response = await apiRequest('POST', `/api/shows/${showId}/update-with-local-image`, { imageUrl });
      
      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(errorText || 'Failed to update image');
      }
      
      const updatedShow = await response.json();
      
      // Update the show in state
      setShows(prev => prev.map(show => 
        show.id === showId ? { ...show, imageUrl: updatedShow.show.imageUrl } : show
      ));
      setFilteredShows(prev => prev.map(show => 
        show.id === showId ? { ...show, imageUrl: updatedShow.show.imageUrl } : show
      ));
      
      // If the show being edited is the currently selected show, update it
      if (selectedShow && selectedShow.id === showId) {
        setSelectedShow({ ...selectedShow, imageUrl: updatedShow.show.imageUrl });
      }
      
      // Show success message
      toast({
        title: "Image Updated",
        description: `Successfully updated image for "${updatedShow.show.name}".`,
      });
    } catch (error) {
      console.error('Error updating image:', error);
      toast({
        title: "Error",
        description: error instanceof Error ? error.message : "Failed to update image",
        variant: "destructive"
      });
    }
  };
  
  // Open edit dialog
  const handleEditShow = (show: TvShow) => {
    // Log the show object to debug what values we're getting from the API
    console.log("Show data for editing:", JSON.stringify(show, null, 2));
    
    // Reset the lookup results when opening a new show's edit form
    setLookupResults({omdb: null, youtube: null});
    setShowLookupOptions(false);

    // Force a fresh fetch of the specific show to ensure we have the latest data
    const fetchCurrentShowData = async () => {
      try {
        const response = await fetch(`/api/shows/${show.id}`);
        if (!response.ok) {
          throw new Error(`Failed to fetch show: ${response.statusText}`);
        }
        
        const currentShowData = await response.json();
        console.log("Fresh show data:", JSON.stringify(currentShowData, null, 2));
        
        // Map display values to form values - converting from "Moderate" to correct form values
        // This ensures the edit form and details page values match
        const mappedInteractivityLevel = normalizeMetrics(currentShowData.interactivityLevel);
        const mappedDialogueIntensity = normalizeMetrics(currentShowData.dialogueIntensity);
        const mappedSoundEffectsLevel = normalizeMetrics(currentShowData.soundEffectsLevel);
        const mappedSceneFrequency = normalizeMetrics(currentShowData.sceneFrequency);
        const mappedMusicTempo = normalizeMetrics(currentShowData.musicTempo);
        const mappedTotalMusicLevel = normalizeMetrics(currentShowData.totalMusicLevel);
        const mappedTotalSoundEffectTimeLevel = normalizeMetrics(currentShowData.totalSoundEffectTimeLevel);
        
        console.log("Mapped values:", {
          interactivityLevel: mappedInteractivityLevel,
          dialogueIntensity: mappedDialogueIntensity,
          soundEffectsLevel: mappedSoundEffectsLevel,
          sceneFrequency: mappedSceneFrequency,
          musicTempo: mappedMusicTempo,
          totalMusicLevel: mappedTotalMusicLevel,
          totalSoundEffectTimeLevel: mappedTotalSoundEffectTimeLevel
        });
        
        // Use the freshly fetched show data with normalized values
        setSelectedShow(currentShowData);
        setFormState({
          name: currentShowData.name,
          description: ensureValue(currentShowData.description, ''),
          ageRange: ensureValue(currentShowData.ageRange, ''),
          stimulationScore: currentShowData.stimulationScore,
          interactivityLevel: mappedInteractivityLevel,
          dialogueIntensity: mappedDialogueIntensity,
          soundEffectsLevel: mappedSoundEffectsLevel,
          sceneFrequency: mappedSceneFrequency,
          musicTempo: mappedMusicTempo,
          totalMusicLevel: mappedTotalMusicLevel,
          totalSoundEffectTimeLevel: mappedTotalSoundEffectTimeLevel,
          animationStyle: ensureValue(currentShowData.animationStyle, ''),
          themes: currentShowData.themes || [],
          imageUrl: ensureValue(currentShowData.imageUrl, '')
        });
        
        setIsDialogOpen(true);
      } catch (error) {
        console.error("Error fetching fresh show data:", error);
        // Fall back to using the original show data if the fetch fails
        setSelectedShow(show);
        
        // Apply the same normalization to the original show data
        const mappedInteractivityLevel = normalizeMetrics(show.interactivityLevel);
        const mappedDialogueIntensity = normalizeMetrics(show.dialogueIntensity);
        const mappedSoundEffectsLevel = normalizeMetrics(show.soundEffectsLevel);
        const mappedSceneFrequency = normalizeMetrics(show.sceneFrequency);
        const mappedMusicTempo = normalizeMetrics(show.musicTempo);
        const mappedTotalMusicLevel = normalizeMetrics(show.totalMusicLevel);
        const mappedTotalSoundEffectTimeLevel = normalizeMetrics(show.totalSoundEffectTimeLevel);
        
        setFormState({
          name: show.name,
          description: ensureValue(show.description, ''),
          ageRange: ensureValue(show.ageRange, ''),
          stimulationScore: show.stimulationScore,
          interactivityLevel: mappedInteractivityLevel,
          dialogueIntensity: mappedDialogueIntensity,
          soundEffectsLevel: mappedSoundEffectsLevel,
          sceneFrequency: mappedSceneFrequency,
          musicTempo: mappedMusicTempo,
          totalMusicLevel: mappedTotalMusicLevel,
          totalSoundEffectTimeLevel: mappedTotalSoundEffectTimeLevel,
          animationStyle: ensureValue(show.animationStyle, ''),
          themes: show.themes || [],
          imageUrl: ensureValue(show.imageUrl, '')
        });
        
        setIsDialogOpen(true);
      }
    };
    
    // Call the fetch function
    fetchCurrentShowData();
  };

  // Convert form values back to API format
  const convertFormValuesToApi = (formValues: any) => {
    // Helper function to convert "Medium" back to "Moderate" for API
    const convertMetricValueForApi = (value: string | null | undefined): string | null => {
      if (!value) return null;
      
      // Convert form values back to API format
      if (value === 'Medium') {
        return 'Moderate';
      }
      
      return value;
    };
    
    // Ensure stimulation score is a whole number
    const wholeStimulationScore = Math.round(formValues.stimulationScore);
    console.log(`Rounded stimulation score: ${formValues.stimulationScore} → ${wholeStimulationScore}`);
    
    // Create a new object with converted values
    return {
      ...formValues,
      // Ensure stimulation score is a whole number
      stimulationScore: wholeStimulationScore,
      // Ensure themes is an array
      themes: Array.isArray(formValues.themes) ? formValues.themes : [],
      // Convert form field values back to API format
      interactivityLevel: formValues.interactivityLevel === 'Medium' ? 'Moderate' : formValues.interactivityLevel,
      dialogueIntensity: formValues.dialogueIntensity === 'Medium' ? 'Moderate' : formValues.dialogueIntensity,
      sceneFrequency: formValues.sceneFrequency === 'Medium' ? 'Moderate' : formValues.sceneFrequency,
      musicTempo: formValues.musicTempo === 'Medium' ? 'Moderate' : formValues.musicTempo,
      totalMusicLevel: formValues.totalMusicLevel === 'Medium' ? 'Moderate' : formValues.totalMusicLevel,
      totalSoundEffectTimeLevel: formValues.totalSoundEffectTimeLevel === 'Medium' ? 'Moderate' : formValues.totalSoundEffectTimeLevel,
    };
  };
  
  // Handle user approval/rejection
  const handleUserApproval = async (userId: number, approve: boolean) => {
    setIsApprovingUser(true);
    try {
      const response = await apiRequest('PATCH', `/api/users/${userId}/approve`, { isApproved: approve });
      
      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(errorText || 'Failed to update user approval status');
      }
      
      const updatedUser = await response.json();
      
      // Update the users list
      setUsers(prev => prev.map(user => 
        user.id === userId ? { ...user, isApproved: approve } : user
      ));
      
      setFilteredUsers(prev => prev.map(user => 
        user.id === userId ? { ...user, isApproved: approve } : user
      ));
      
      toast({
        title: approve ? "User Approved" : "User Rejected",
        description: `Successfully ${approve ? 'approved' : 'rejected'} user ${updatedUser.username || updatedUser.email}`,
      });
    } catch (error) {
      console.error('Error updating user approval status:', error);
      toast({
        title: "Error",
        description: error instanceof Error ? error.message : "Failed to update user approval status",
        variant: "destructive"
      });
    } finally {
      setIsApprovingUser(false);
    }
  };

  // Handle password reset
  const handlePasswordReset = async (userId: number) => {
    console.log('Reset password button clicked for user ID:', userId); // Debug log
    setIsResettingPassword(true);
    setResetPasswordUserId(userId);
    try {
      const response = await fetch('/api/admin/reset-password', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'include',
        body: JSON.stringify({ userId }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Failed to reset password');
      }

      const data = await response.json();
      console.log('Password reset response:', data); // Debug log
      console.log('Setting tempPassword to:', data.temporaryPassword); // Debug log
      setTempPassword(data.temporaryPassword);
      console.log('tempPassword state after setting:', data.temporaryPassword); // Debug log
      
      // Temporary alert to show the password until popup is fixed
      alert(`Password reset successful!\n\nTemporary password: ${data.temporaryPassword}\n\nPlease copy this password and share it with the user securely.`);
      
      toast({
        title: "Password Reset Successfully",
        description: "A temporary password has been generated. Click to view and copy it.",
      });
    } catch (error) {
      console.error('Error resetting password:', error);
      toast({
        title: "Error",
        description: "Failed to reset password. Please try again.",
        variant: "destructive"
      });
    } finally {
      setIsResettingPassword(false);
    }
  };
  
  // Delete show handler - defined below

  // Update show
  const handleUpdateShow = async () => {
    if (!selectedShow) return;
    
    setIsUpdating(true);
    try {
      // Convert form values back to API format
      const apiFormData = convertFormValuesToApi(formState);
      
      console.log('Submitting data to API:', apiFormData);
      
      // Make the API request with the converted data
      const updatedShow = await apiRequest('PATCH', `/api/shows/${selectedShow.id}`, apiFormData);
      
      // Update shows in state
      setShows(prev => prev.map(show => 
        show.id === updatedShow.id ? updatedShow : show
      ));
      setFilteredShows(prev => prev.map(show => 
        show.id === updatedShow.id ? updatedShow : show
      ));
      
      // Invalidate any queries that might have stale data
      console.log('Invalidating query cache for:', `/api/shows/${selectedShow.id}`);
      queryClient.invalidateQueries({ queryKey: [`/api/shows/${selectedShow.id}`] });
      queryClient.invalidateQueries({ queryKey: ['/api/shows'] });
      
      toast({
        title: "Show Updated",
        description: `Successfully updated ${updatedShow.name}.`,
      });
      
      setIsDialogOpen(false);
    } catch (error) {
      console.error('Error updating show:', error);
      toast({
        title: "Error",
        description: "Failed to update show. Please try again.",
        variant: "destructive"
      });
    } finally {
      setIsUpdating(false);
    }
  };
  
  // Handle featured toggle
  const handleFeaturedToggle = async (showId: number, isFeatured: boolean) => {
    try {
      const response = await apiRequest('PATCH', `/api/shows/${showId}/featured`, { 
        is_featured: isFeatured 
      });
      
      // Update shows in state
      setShows(prev => prev.map(show => 
        show.id === showId ? { ...show, is_featured: isFeatured } : { ...show, is_featured: false }
      ));
      setFilteredShows(prev => prev.map(show => 
        show.id === showId ? { ...show, is_featured: isFeatured } : { ...show, is_featured: false }
      ));
      
      // Invalidate queries to refresh data
      queryClient.invalidateQueries({ queryKey: ['/api/shows'] });
      queryClient.invalidateQueries({ queryKey: ['/api/tv-shows'] });
      
      toast({
        title: isFeatured ? "Show Featured" : "Show Unfeatured",
        description: isFeatured ? "This show is now featured on the homepage." : "This show is no longer featured.",
      });
    } catch (error) {
      console.error('Error updating featured status:', error);
      toast({
        title: "Error",
        description: "Failed to update featured status. Please try again.",
        variant: "destructive"
      });
    }
  };

  const handleDeleteShow = async () => {
    if (!selectedShow) return;
    
    setIsDeleting(true);
    try {
      // Make DELETE request to the API using apiRequest
      await apiRequest('DELETE', `/api/shows/${selectedShow.id}`);
      
      // Update shows in state to remove the deleted show
      setShows(prev => prev.filter(show => show.id !== selectedShow.id));
      setFilteredShows(prev => prev.filter(show => show.id !== selectedShow.id));
      
      // Invalidate queries to ensure data consistency
      queryClient.invalidateQueries({ queryKey: ['/api/shows'] });
      
      toast({
        title: "Show Deleted",
        description: `Successfully deleted ${selectedShow.name}.`,
      });
      
      // Close dialogs
      setShowDeleteConfirm(false);
      setIsDialogOpen(false);
    } catch (error) {
      console.error('Error deleting show:', error);
      toast({
        title: "Error",
        description: error instanceof Error ? error.message : "Failed to delete show",
        variant: "destructive"
      });
    } finally {
      setIsDeleting(false);
    }
  };

  if (isLoading) {
    return (
      <div className="flex justify-center items-center min-h-screen">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
      </div>
    );
  }

  return (
    <main className="container mx-auto py-8 px-4">
      <Card className="mb-8">
        <CardHeader>
          <div className="flex justify-between items-center">
            <div>
              <CardTitle>Admin Dashboard</CardTitle>
              <CardDescription>Manage TV shows, research, and settings</CardDescription>
            </div>

          </div>
        </CardHeader>
      </Card>

      <Tabs defaultValue="shows">
        <TabsList className="mb-4">
          <TabsTrigger value="shows">TV Shows</TabsTrigger>
          <TabsTrigger value="research">Research</TabsTrigger>
          <TabsTrigger value="users">Users</TabsTrigger>
          <TabsTrigger value="submissions">Show Submissions</TabsTrigger>
          <TabsTrigger value="settings">Settings</TabsTrigger>
        </TabsList>
        
        <TabsContent value="research">
          <Card>
            <CardHeader>
              <div className="flex justify-between items-center">
                <div>
                  <CardTitle>Research Manager</CardTitle>
                  <CardDescription>
                    Manage research summaries and original study links
                  </CardDescription>
                </div>
                <div className="flex space-x-2">
                  <Button 
                    onClick={() => setLocation('/admin/research')}
                    className="flex items-center"
                  >
                    <PlusCircle className="h-4 w-4 mr-2" />
                    Add Research
                  </Button>
                  <Button 
                    onClick={() => setLocation('/admin/research-link-updater')}
                    variant="outline"
                    className="flex items-center"
                  >
                    <FileText className="h-4 w-4 mr-2" />
                    Update Links
                  </Button>
                </div>
              </div>
              <div className="relative mt-4">
                <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400" size={18} />
                <Input
                  placeholder="Search research..."
                  className="pl-10"
                  value={researchSearchTerm}
                  onChange={(e) => setResearchSearchTerm(e.target.value)}
                />
              </div>
            </CardHeader>
            <CardContent>
              {isLoadingResearch ? (
                <div className="flex justify-center py-8">
                  <Loader2 className="h-8 w-8 animate-spin text-primary" />
                </div>
              ) : researchEntries.length === 0 ? (
                <Alert>
                  <FileText className="h-4 w-4" />
                  <AlertTitle>No research entries</AlertTitle>
                  <AlertDescription>
                    There are currently no research entries in the database. Click the "Add Research" button to create your first entry.
                  </AlertDescription>
                </Alert>
              ) : (
                <div className="rounded-md border">
                  <Table>
                    <TableHeader>
                      <TableRow>
                        <TableHead className="w-[50px]">ID</TableHead>
                        <TableHead>Title</TableHead>
                        <TableHead>Category</TableHead>
                        <TableHead>Source</TableHead>
                        <TableHead>Date</TableHead>
                        <TableHead className="text-right">Actions</TableHead>
                      </TableRow>
                    </TableHeader>
                    <TableBody>
                      {filteredResearch.map((entry) => (
                        <TableRow key={entry.id}>
                          <TableCell>{entry.id}</TableCell>
                          <TableCell className="font-medium">{entry.title}</TableCell>
                          <TableCell>{entry.category || 'Uncategorized'}</TableCell>
                          <TableCell>{entry.source || 'N/A'}</TableCell>
                          <TableCell>{entry.publishedDate || 'N/A'}</TableCell>
                          <TableCell className="text-right">
                            <div className="flex justify-end space-x-1">
                              <Button 
                                variant="ghost" 
                                size="sm"
                                onClick={() => handleEditResearch(entry.id)}
                              >
                                <Edit className="h-4 w-4" />
                              </Button>
                              <Button 
                                variant="ghost" 
                                size="sm"
                                onClick={() => handleDeleteResearch(entry.id, entry.title)}
                                className="text-red-500 hover:text-red-700 hover:bg-red-100"
                              >
                                <Trash className="h-4 w-4" />
                              </Button>
                            </div>
                          </TableCell>
                        </TableRow>
                      ))}
                    </TableBody>
                  </Table>
                </div>
              )}
            </CardContent>
          </Card>
        </TabsContent>
        
        <TabsContent value="shows">
          <Card>
            <CardHeader>
              <div className="flex justify-between items-center">
                <div>
                  <CardTitle>TV Shows</CardTitle>
                  <CardDescription>
                    View and manage all TV shows in the database
                  </CardDescription>
                </div>
                <Button 
                  onClick={() => handleAddNewShow()}
                  className="flex items-center"
                >
                  <PlusCircle className="h-4 w-4 mr-2" />
                  Add Show
                </Button>
              </div>
              <div className="relative mt-4">
                <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400" size={18} />
                <Input
                  placeholder="Search shows..."
                  className="pl-10"
                  value={searchTerm}
                  onChange={(e) => setSearchTerm(e.target.value)}
                />
              </div>
            </CardHeader>
            <CardContent>
              <div className="rounded-md border">
                <Table>
                  <TableHeader>
                    <TableRow>
                      <TableHead className="w-[50px]">ID</TableHead>
                      <TableHead>Name</TableHead>
                      <TableHead>Age Range</TableHead>
                      <TableHead>Stimulation</TableHead>
                      <TableHead>Featured</TableHead>
                      <TableHead>OMDb</TableHead>
                      <TableHead>YouTube</TableHead>
                      <TableHead className="text-right">Actions</TableHead>
                    </TableRow>
                  </TableHeader>
                  <TableBody>
                    {filteredShows.length === 0 ? (
                      <TableRow>
                        <TableCell colSpan={8} className="text-center py-8 text-gray-500">
                          No shows found
                        </TableCell>
                      </TableRow>
                    ) : (
                      filteredShows.map((show) => (
                        <TableRow key={show.id}>
                          <TableCell>{show.id}</TableCell>
                          <TableCell className="font-medium">{show.name}</TableCell>
                          <TableCell>{show.ageRange || 'N/A'}</TableCell>
                          <TableCell>{show.stimulationScore}/5</TableCell>
                          <TableCell>
                            <Button
                              variant={show.is_featured ? "default" : "outline"}
                              size="sm"
                              onClick={() => handleFeaturedToggle(show.id, !show.is_featured)}
                              className={show.is_featured ? "bg-yellow-600 hover:bg-yellow-700" : ""}
                            >
                              {show.is_featured ? "★ Featured" : "☆ Set Featured"}
                            </Button>
                          </TableCell>
                          <TableCell>
                            {show.hasOmdbData ? (
                              <span className="text-green-600 font-medium flex items-center">
                                <Check className="h-4 w-4 mr-1" /> Yes
                              </span>
                            ) : (
                              <span className="text-gray-500">–</span>
                            )}
                          </TableCell>
                          <TableCell>
                            {/* Log value for debugging */}

                            {show.hasYoutubeData === true ? (
                              <span className="text-red-600 font-medium flex items-center">
                                <Check className="h-4 w-4 mr-1" /> Yes
                              </span>
                            ) : (
                              <span className="text-gray-500">–</span>
                            )}
                          </TableCell>
                          <TableCell className="text-right">
                            <Button 
                              variant="ghost" 
                              size="sm"
                              onClick={() => handleEditShow(show)}
                            >
                              <Edit className="h-4 w-4 mr-2" />
                              Edit
                            </Button>
                          </TableCell>
                        </TableRow>
                      ))
                    )}
                  </TableBody>
                </Table>
              </div>
            </CardContent>
            <CardFooter>
              <div className="text-sm text-muted-foreground">
                Showing {filteredShows.length} of {shows.length} shows
              </div>
            </CardFooter>
          </Card>
        </TabsContent>
        
        <TabsContent value="users">
          <Card>
            <CardHeader>
              <div className="flex justify-between items-center">
                <div>
                  <CardTitle>User Management</CardTitle>
                  <CardDescription>
                    Manage users and approve early access requests
                  </CardDescription>
                </div>
                <div className="flex gap-2">
                  <Button 
                    onClick={() => {
                      console.log('Test Dialog button clicked!');
                      setTempPassword('test123');
                      console.log('After setting test password');
                    }} 
                    variant="outline" 
                    size="sm"
                    className="text-purple-600"
                  >
                    Test Dialog
                  </Button>
                  <Button 
                    variant="outline" 
                    size="sm"
                    onClick={fetchUsers}
                    disabled={isLoadingUsers}
                  >
                    {isLoadingUsers ? (
                      <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                    ) : (
                      <RefreshCw className="h-4 w-4 mr-2" />
                    )}
                    Refresh Users
                  </Button>
                </div>
              </div>
              <div className="relative mt-4">
                <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400" size={18} />
                <Input
                  placeholder="Search users..."
                  className="pl-10"
                  value={userSearchTerm}
                  onChange={(e) => setUserSearchTerm(e.target.value)}
                />
              </div>
            </CardHeader>
            <CardContent>
              {isLoadingUsers ? (
                <div className="flex justify-center items-center py-6">
                  <Loader2 className="h-8 w-8 animate-spin text-primary" />
                </div>
              ) : filteredUsers.length === 0 ? (
                <div className="py-6 text-center text-muted-foreground">
                  No users found
                </div>
              ) : (
                <div className="rounded-md border">
                  <Table>
                    <TableHeader>
                      <TableRow>
                        <TableHead>ID</TableHead>
                        <TableHead>Username</TableHead>
                        <TableHead>Email</TableHead>
                        <TableHead>Country</TableHead>
                        <TableHead>Status</TableHead>
                        <TableHead>Created</TableHead>
                        <TableHead>Actions</TableHead>
                      </TableRow>
                    </TableHeader>
                    <TableBody>
                      {filteredUsers.map((user) => (
                        <TableRow key={user.id}>
                          <TableCell>{user.id}</TableCell>
                          <TableCell>
                            {user.username ? (
                              <Link href={`/user/${user.id}`}>
                                <span className="text-blue-600 hover:text-blue-800 cursor-pointer underline">
                                  {user.username}
                                </span>
                              </Link>
                            ) : (
                              '-'
                            )}
                          </TableCell>
                          <TableCell>{user.email}</TableCell>
                          <TableCell>{user.country || '-'}</TableCell>
                          <TableCell>
                            {user.isAdmin ? (
                              <div className="flex items-center space-x-1 text-blue-600">
                                <Shield size={16} />
                                <span>Admin</span>
                              </div>
                            ) : user.isApproved ? (
                              <div className="flex items-center space-x-1 text-green-600">
                                <CheckCircle size={16} />
                                <span>Approved</span>
                              </div>
                            ) : (
                              <div className="flex items-center space-x-1 text-orange-600">
                                <Clock size={16} />
                                <span>Pending</span>
                              </div>
                            )}
                          </TableCell>
                          <TableCell>
                            {new Date(user.createdAt).toLocaleDateString()}
                          </TableCell>
                          <TableCell>
                            <div className="flex space-x-2">
                              {!user.isAdmin && (
                                <>
                                  {!user.isApproved ? (
                                    <Button 
                                      variant="outline" 
                                      size="sm"
                                      className="h-8 px-2 text-green-600"
                                      onClick={() => handleUserApproval(user.id, true)}
                                      disabled={isApprovingUser}
                                    >
                                      <Check className="h-4 w-4" />
                                      <span className="ml-1">Approve</span>
                                    </Button>
                                  ) : (
                                    <Button 
                                      variant="outline" 
                                      size="sm"
                                      className="h-8 px-2 text-red-600"
                                      onClick={() => handleUserApproval(user.id, false)}
                                      disabled={isApprovingUser}
                                    >
                                      <X className="h-4 w-4" />
                                      <span className="ml-1">Revoke</span>
                                    </Button>
                                  )}
                                </>
                              )}
                              <Button 
                                variant="outline" 
                                size="sm"
                                className="h-8 px-2 text-blue-600"
                                onClick={() => handlePasswordReset(user.id)}
                                disabled={isResettingPassword && resetPasswordUserId === user.id}
                              >
                                {isResettingPassword && resetPasswordUserId === user.id ? (
                                  <Loader2 className="h-4 w-4 animate-spin" />
                                ) : (
                                  <Key className="h-4 w-4" />
                                )}
                                <span className="ml-1">Reset Password</span>
                              </Button>
                            </div>
                          </TableCell>
                        </TableRow>
                      ))}
                    </TableBody>
                  </Table>
                </div>
              )}
            </CardContent>
          </Card>
        </TabsContent>
        
        <TabsContent value="submissions">
          <Card>
            <CardHeader>
              <CardTitle>Show Submissions</CardTitle>
              <CardDescription>
                Review and approve show submissions from users (sorted by popularity)
              </CardDescription>
            </CardHeader>
            <CardContent>
              <ShowSubmissionsSection />
            </CardContent>
          </Card>
        </TabsContent>
        
        <TabsContent value="settings">
          <Card>
            <CardHeader>
              <CardTitle>Settings</CardTitle>
              <CardDescription>
                Configure system-wide settings and options
              </CardDescription>
            </CardHeader>
            <CardContent className="space-y-6">
              <div>
                <h3 className="text-lg font-medium mb-2">Image Optimization</h3>
                <p className="text-muted-foreground mb-4">
                  Replace landscape-oriented images with portrait-style images from OMDB to ensure 
                  consistent portrait layout across the application.
                </p>
                <Button 
                  onClick={handleOptimizeImages} 
                  disabled={isOptimizingImages}
                  className="flex items-center"
                >
                  {isOptimizingImages ? (
                    <>
                      <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                      Optimizing Images...
                    </>
                  ) : (
                    <>
                      <ImageIcon className="h-4 w-4 mr-2" />
                      Optimize Show Images
                    </>
                  )}
                </Button>
              </div>
              
              <div className="pt-6 border-t">
                <h3 className="text-lg font-medium mb-2">SEO Image Optimization</h3>
                <p className="text-muted-foreground mb-4">
                  Optimize all custom images for better SEO performance. This process resizes images 
                  to portrait format (3:4 ratio), compresses them for faster loading, and ensures 
                  consistent quality throughout the site.
                </p>
                <Button 
                  onClick={handleOptimizeCustomImages} 
                  disabled={isOptimizingImages}
                  className="flex items-center"
                  variant="outline"
                >
                  {isOptimizingImages ? (
                    <>
                      <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                      Optimizing for SEO...
                    </>
                  ) : (
                    <>
                      <ImageIcon className="h-4 w-4 mr-2" />
                      Optimize Custom Images for SEO
                    </>
                  )}
                </Button>
              </div>
              


              <div className="pt-6 border-t">
                <h3 className="text-lg font-medium mb-2">TV Show API Data</h3>
                <p className="text-muted-foreground mb-4">
                  Update all TV shows with data from OMDb and YouTube APIs. This will enhance shows with descriptions, release years, and other metadata.
                </p>
                <Button 
                  onClick={handleUpdateMetadata}
                  disabled={isUpdatingMetadata}
                  className="flex items-center"
                  variant="secondary"
                >
                  {isUpdatingMetadata ? (
                    <>
                      <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                      Updating Metadata...
                    </>
                  ) : (
                    <>
                      <RefreshCw className="h-4 w-4 mr-2" />
                      Update API Data
                    </>
                  )}
                </Button>
              </div>

              <div className="pt-4 border-t">
                <p className="text-muted-foreground">More settings options will be available in future updates.</p>
              </div>
            </CardContent>
          </Card>
        </TabsContent>
      </Tabs>

      {/* Edit Show Dialog */}
      <Dialog open={isDialogOpen} onOpenChange={setIsDialogOpen}>
        <DialogContent className="sm:max-w-[600px] max-h-[90vh] overflow-y-auto">
          <DialogHeader>
            <DialogTitle>Edit TV Show</DialogTitle>
            <DialogDescription>
              Update the details for {selectedShow?.name}
            </DialogDescription>
          </DialogHeader>
          
          <div className="grid gap-4 py-4">
            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="name" className="text-right">
                Name
              </Label>
              <div className="col-span-3 flex gap-2">
                <Input
                  id="name"
                  value={formState.name}
                  onChange={(e) => setFormState({...formState, name: e.target.value})}
                  className="flex-1"
                />
                <Button 
                  type="button" 
                  variant="outline" 
                  size="sm"
                  onClick={async () => {
                    if (!formState.name) {
                      toast({
                        title: "Show name required",
                        description: "Please enter a show name to search",
                        variant: "destructive"
                      });
                      return;
                    }
                    
                    setIsLookingUp(true);
                    try {
                      const response = await fetch(`/api/lookup-show?name=${encodeURIComponent(formState.name)}`);
                      const data = await response.json();
                      setLookupResults(data);
                      setShowLookupOptions(true);
                    } catch (error) {
                      console.error('Error looking up show:', error);
                      toast({
                        title: "Lookup failed",
                        description: "Could not find information for this show",
                        variant: "destructive"
                      });
                    } finally {
                      setIsLookingUp(false);
                    }
                  }}
                  disabled={isLookingUp}
                >
                  {isLookingUp ? (
                    <Loader2 className="h-4 w-4 animate-spin" />
                  ) : (
                    <Search className="h-4 w-4" />
                  )}
                  <span className="ml-2">Lookup</span>
                </Button>
              </div>
            </div>
            
            {showLookupOptions && (lookupResults.omdb || lookupResults.youtube) && (
              <div className="grid grid-cols-4 gap-4">
                <div className="col-start-2 col-span-3">
                  <Alert className={lookupResults.omdb ? "border-green-500" : lookupResults.youtube ? "border-red-500" : ""}>
                    <AlertTitle className="flex items-center gap-2">
                      <CheckCircle className="h-5 w-5 text-green-500" />
                      API Data Found Successfully!
                    </AlertTitle>
                    <AlertDescription className="mt-3">
                      {lookupResults.omdb && (
                        <div className="mb-4 p-3 border rounded bg-muted/30">
                          <h4 className="font-medium mb-2 flex items-center">
                            <FileText className="h-4 w-4 mr-2 text-blue-500" />
                            <span className="text-blue-500 font-semibold">OMDb Data Found:</span>
                          </h4>
                          <p className="text-sm text-muted-foreground mb-3">
                            <strong>Title:</strong> {lookupResults.omdb.title}<br />
                            <strong>Year:</strong> {lookupResults.omdb.year}<br />
                            <strong>Director:</strong> {lookupResults.omdb.director || "Not available"}<br />
                            <strong>Plot:</strong> {lookupResults.omdb.plot?.substring(0, 100)}...
                          </p>
                          <Button 
                            type="button"
                            size="sm"
                            className="bg-blue-500 hover:bg-blue-600 text-white"
                            onClick={async () => {
                              // Extract year information
                              const releaseYear = lookupResults.omdb.year ? 
                                parseInt(lookupResults.omdb.year.split('–')[0]) : null;
                              const endYear = lookupResults.omdb.year && lookupResults.omdb.year.includes('–') ?
                                parseInt(lookupResults.omdb.year.split('–')[1]) || null : null;
                              
                              // Set a reference to the current button using event target
                              const button = document.activeElement as HTMLButtonElement;
                              const originalText = button.innerText;
                              
                              setFormState(prev => ({
                                ...prev,
                                description: lookupResults.omdb.plot || prev.description,
                                creator: lookupResults.omdb.director || prev.creator,
                                releaseYear: releaseYear || prev.releaseYear,
                                endYear: endYear || prev.endYear,
                                episodeLength: prev.episodeLength || 30,
                                isOngoing: !endYear,
                                imageUrl: lookupResults.omdb.poster || prev.imageUrl,
                                hasOmdbData: true // Set the flag that OMDb data was used
                              }));
                              
                              // Change button appearance to show success
                              if (button) {
                                // Update with checkmark icon and success text
                                button.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4 mr-2"><polyline points="20 6 9 17 4 12"></polyline></svg>Added Successfully';
                                
                                // Change to success styling
                                button.classList.add("bg-green-600");
                                button.classList.remove("bg-blue-500", "hover:bg-blue-600");
                                
                                // Disable the button to prevent multiple clicks
                                button.disabled = true;
                              }
                              
                              // Show notification but keep the lookup panel open
                              toast({
                                title: "OMDb Data Added",
                                description: "Official TV show data has been applied to the form"
                              });
                            }}
                          >
                            <FileText className="h-4 w-4 mr-2" />
                            Add API Data
                          </Button>
                        </div>
                      )}
                      
                      {lookupResults.youtube && (
                        <div className="p-3 border rounded bg-muted/30">
                          <h4 className="font-medium mb-2 flex items-center">
                            <Video className="h-4 w-4 mr-2 text-red-500" />
                            <span className="text-red-500 font-semibold">YouTube Data Found:</span>
                          </h4>
                          <p className="text-sm text-muted-foreground mb-3">
                            <strong>Channel:</strong> {lookupResults.youtube.title}<br />
                            <strong>Subscribers:</strong> {parseInt(lookupResults.youtube.subscriberCount).toLocaleString()}<br />
                            <strong>Videos:</strong> {parseInt(lookupResults.youtube.videoCount).toLocaleString()}<br />
                            <strong>Created:</strong> {new Date(lookupResults.youtube.publishedAt).toLocaleDateString()}
                          </p>
                          <Button 
                            type="button"
                            size="sm" 
                            className="bg-red-500 hover:bg-red-600 text-white"
                            onClick={() => {
                              const releaseYear = lookupResults.youtube.publishedAt ?
                                new Date(lookupResults.youtube.publishedAt).getFullYear() : null;
                              
                              // Set a reference to the current button using event target
                              const button = document.activeElement as HTMLButtonElement;
                              
                              // Properly handle the availableOn field as an array
                              let updatedAvailableOn;
                              if (Array.isArray(formState.availableOn)) {
                                // If it's already an array, add YouTube if not present
                                updatedAvailableOn = formState.availableOn.includes('YouTube') 
                                  ? formState.availableOn 
                                  : [...formState.availableOn, 'YouTube'];
                              } else if (typeof formState.availableOn === 'string') {
                                // If it's a string, split by comma and add YouTube if not present
                                const platforms = (formState.availableOn as string).split(',').map((p: string) => p.trim());
                                updatedAvailableOn = platforms.includes('YouTube') 
                                  ? platforms 
                                  : [...platforms, 'YouTube'];
                              } else {
                                // Default to an array with just YouTube
                                updatedAvailableOn = ['YouTube'];
                              }
                              
                              setFormState(prev => ({
                                ...prev,
                                description: lookupResults.youtube.description || prev.description,
                                releaseYear: releaseYear || prev.releaseYear,
                                isOngoing: true,
                                subscriberCount: lookupResults.youtube.subscriberCount || (prev as any).subscriberCount || '',
                                videoCount: lookupResults.youtube.videoCount || (prev as any).videoCount || '',
                                isYouTubeChannel: true,
                                publishedAt: lookupResults.youtube.publishedAt || (prev as any).publishedAt || '',
                                channelId: lookupResults.youtube.channelId || (prev as any).channelId || '',
                                availableOn: updatedAvailableOn,
                                hasYoutubeData: true // Set the flag that YouTube data was used
                              }));
                              
                              // Change button appearance to show success
                              if (button) {
                                // Update button with checkmark icon and success text
                                button.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4 mr-2"><polyline points="20 6 9 17 4 12"></polyline></svg>Added Successfully';
                                
                                // Change styling to red success state (keeping YouTube branding)
                                button.classList.add("bg-rose-600");
                                button.classList.remove("bg-red-500", "hover:bg-red-600");
                                
                                // Disable the button to prevent multiple clicks
                                button.disabled = true;
                              }
                              
                              // Show notification but keep the lookup panel open
                              toast({
                                title: "YouTube Data Added",
                                description: "Official YouTube channel data has been applied to the form"
                              });
                            }}
                          >
                            <Video className="h-4 w-4 mr-2" />
                            Add API Data
                          </Button>
                        </div>
                      )}
                      
                      <Button 
                        type="button"
                        size="sm"
                        variant="ghost"
                        className="mt-3"
                        onClick={() => setShowLookupOptions(false)}
                      >
                        <X className="h-4 w-4 mr-2" />
                        Cancel
                      </Button>
                    </AlertDescription>
                  </Alert>
                </div>
              </div>
            )}
            
            
            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="description" className="text-right">
                Description
              </Label>
              <Textarea
                id="description"
                value={formState.description}
                onChange={(e) => setFormState({...formState, description: e.target.value})}
                className="col-span-3"
                rows={3}
              />
            </div>
            
            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="ageRange" className="text-right">
                Age Range
              </Label>
              <Input
                id="ageRange"
                value={formState.ageRange}
                onChange={(e) => setFormState({...formState, ageRange: e.target.value})}
                className="col-span-3"
                placeholder="e.g. 3-5"
              />
            </div>
            
            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="stimulationScore" className="text-right">
                Stimulation Score
              </Label>
              <Select 
                value={String(Math.round(formState.stimulationScore))}
                onValueChange={(value) => setFormState({...formState, stimulationScore: Math.round(parseInt(value))})}
              >
                <SelectTrigger className="col-span-3">
                  <SelectValue placeholder="Select stimulation score" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="1">1 - Very Low</SelectItem>
                  <SelectItem value="2">2 - Low</SelectItem>
                  <SelectItem value="3">3 - Medium</SelectItem>
                  <SelectItem value="4">4 - High</SelectItem>
                  <SelectItem value="5">5 - Very High</SelectItem>
                </SelectContent>
              </Select>
            </div>
            
            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="interactivityLevel" className="text-right">
                Interactivity
              </Label>
              <Select 
                value={formState.interactivityLevel}
                onValueChange={(value) => setFormState({...formState, interactivityLevel: value})}
              >
                <SelectTrigger className="col-span-3">
                  <SelectValue placeholder="Select interactivity level" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="Low">Low</SelectItem>
                  <SelectItem value="Low-Moderate">Low-Moderate</SelectItem>
                  <SelectItem value="Medium">Medium</SelectItem>
                  <SelectItem value="Moderate-High">Moderate-High</SelectItem>
                  <SelectItem value="High">High</SelectItem>
                </SelectContent>
              </Select>
            </div>
            
            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="dialogueIntensity" className="text-right">
                Dialogue Intensity
              </Label>
              <Select 
                value={formState.dialogueIntensity}
                onValueChange={(value) => setFormState({...formState, dialogueIntensity: value})}
              >
                <SelectTrigger className="col-span-3">
                  <SelectValue placeholder="Select dialogue intensity" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="Low">Low</SelectItem>
                  <SelectItem value="Low-Moderate">Low-Moderate</SelectItem>
                  <SelectItem value="Medium">Medium</SelectItem>
                  <SelectItem value="Moderate-High">Moderate-High</SelectItem>
                  <SelectItem value="High">High</SelectItem>
                </SelectContent>
              </Select>
            </div>
            
            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="soundEffectsLevel" className="text-right">
                Sound Effects
              </Label>
              <Select 
                value={formState.soundEffectsLevel}
                onValueChange={(value) => setFormState({...formState, soundEffectsLevel: value})}
              >
                <SelectTrigger className="col-span-3">
                  <SelectValue placeholder="Select sound effects level" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="Low">Low</SelectItem>
                  <SelectItem value="Low-Moderate">Low-Moderate</SelectItem>
                  <SelectItem value="Medium">Medium</SelectItem>
                  <SelectItem value="Moderate-High">Moderate-High</SelectItem>
                  <SelectItem value="High">High</SelectItem>
                </SelectContent>
              </Select>
            </div>
            
            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="totalSoundEffectTimeLevel" className="text-right">
                Total Sound Effect Time
              </Label>
              <Select 
                value={formState.totalSoundEffectTimeLevel}
                onValueChange={(value) => setFormState({...formState, totalSoundEffectTimeLevel: value})}
              >
                <SelectTrigger className="col-span-3">
                  <SelectValue placeholder="Select total sound effect time level" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="Low">Low</SelectItem>
                  <SelectItem value="Low-Moderate">Low-Moderate</SelectItem>
                  <SelectItem value="Medium">Medium</SelectItem>
                  <SelectItem value="Moderate-High">Moderate-High</SelectItem>
                  <SelectItem value="High">High</SelectItem>
                </SelectContent>
              </Select>
            </div>
            
            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="sceneFrequency" className="text-right">
                Scene Frequency
              </Label>
              <Select 
                value={formState.sceneFrequency}
                onValueChange={(value) => setFormState({...formState, sceneFrequency: value})}
              >
                <SelectTrigger className="col-span-3">
                  <SelectValue placeholder="Select scene frequency" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="Low">Low</SelectItem>
                  <SelectItem value="Low-Moderate">Low-Moderate</SelectItem>
                  <SelectItem value="Medium">Medium</SelectItem>
                  <SelectItem value="Moderate-High">Moderate-High</SelectItem>
                  <SelectItem value="High">High</SelectItem>
                </SelectContent>
              </Select>
            </div>
            
            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="musicTempo" className="text-right">
                Music Tempo
              </Label>
              <Select 
                value={formState.musicTempo}
                onValueChange={(value) => setFormState({...formState, musicTempo: value})}
              >
                <SelectTrigger className="col-span-3">
                  <SelectValue placeholder="Select music tempo" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="Low">Low</SelectItem>
                  <SelectItem value="Low-Moderate">Low-Moderate</SelectItem>
                  <SelectItem value="Medium">Medium</SelectItem>
                  <SelectItem value="Moderate-High">Moderate-High</SelectItem>
                  <SelectItem value="High">High</SelectItem>
                </SelectContent>
              </Select>
            </div>
            
            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="totalMusicLevel" className="text-right">
                Total Music Level
              </Label>
              <Select 
                value={formState.totalMusicLevel}
                onValueChange={(value) => setFormState({...formState, totalMusicLevel: value})}
              >
                <SelectTrigger className="col-span-3">
                  <SelectValue placeholder="Select total music level" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="Low">Low</SelectItem>
                  <SelectItem value="Low-Moderate">Low-Moderate</SelectItem>
                  <SelectItem value="Medium">Medium</SelectItem>
                  <SelectItem value="Moderate-High">Moderate-High</SelectItem>
                  <SelectItem value="High">High</SelectItem>
                </SelectContent>
              </Select>
            </div>
            
            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="themes" className="text-right">
                Themes
              </Label>
              <div className="col-span-3">
                <ThemeSelector
                  selectedThemes={Array.isArray(formState.themes) ? formState.themes : []}
                  onThemesChange={(themes) => setFormState({...formState, themes})}
                  placeholder="Select or add themes..."
                />
              </div>
            </div>
            
            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="animationStyle" className="text-right">
                Animation Style
              </Label>
              <Textarea
                id="animationStyle"
                value={formState.animationStyle}
                onChange={(e) => setFormState({...formState, animationStyle: e.target.value})}
                className="col-span-3"
                placeholder="Describe the animation style (e.g., '3D Animation', 'Stop-motion with hand-crafted models')"
                rows={3}
              />
            </div>
            
            {/* Image Management Section */}
            <div className="border-t pt-4 mt-4">
              <h3 className="text-lg font-medium mb-2">Image Management</h3>
              
              <div className="flex flex-col gap-4">
                {/* Image Upload Component */}
                <ImageUpload 
                  imageUrl={formState.imageUrl} 
                  onImageChange={(imageUrl) => setFormState({...formState, imageUrl})}
                />
                
                {/* OMDB Image Lookup Button */}
                <div>
                  <p className="text-sm mb-2">Or fetch image from OMDB:</p>
                  <Button 
                    type="button" 
                    variant="outline" 
                    className="flex items-center justify-center"
                    onClick={() => {
                      if (selectedShow) {
                        // Call the API to fetch and update the image from OMDB
                        apiRequest('POST', `/api/shows/${selectedShow.id}/update-image`)
                          .then(resp => resp.json())
                          .then(data => {
                            if (data.success) {
                              setFormState(prev => ({...prev, imageUrl: data.show.imageUrl}));
                              toast({
                                title: "Success",
                                description: data.message,
                              });
                            } else {
                              throw new Error(data.message || "Failed to find OMDB image");
                            }
                          })
                          .catch(err => {
                            toast({
                              title: "Error",
                              description: err.message || "Failed to update image from OMDB",
                              variant: "destructive"
                            });
                          });
                      }
                    }}
                  >
                    <Image className="h-4 w-4 mr-2" />
                    Find OMDB Image
                  </Button>
                </div>
              </div>
            </div>
          </div>
          
          <DialogFooter className="sticky bottom-0 bg-white pb-2 pt-2 flex flex-col sm:flex-row justify-between w-full gap-4">
            <div>
              {/* Delete button with confirmation */}
              {showDeleteConfirm ? (
                <div className="flex items-center gap-2">
                  <span className="text-sm text-red-500">Are you sure?</span>
                  <Button 
                    variant="destructive" 
                    size="sm" 
                    onClick={handleDeleteShow} 
                    disabled={isDeleting}
                  >
                    {isDeleting ? (
                      <>
                        <Loader2 className="h-3 w-3 mr-1 animate-spin" />
                        Deleting...
                      </>
                    ) : 'Yes, Delete'}
                  </Button>
                  <Button 
                    variant="outline" 
                    size="sm"
                    onClick={() => setShowDeleteConfirm(false)}
                  >
                    Cancel
                  </Button>
                </div>
              ) : (
                <Button 
                  variant="destructive" 
                  onClick={() => setShowDeleteConfirm(true)}
                >
                  <Trash2 className="h-4 w-4 mr-2" />
                  Delete Show
                </Button>
              )}
            </div>
            <div className="flex gap-2">
              <Button variant="outline" onClick={() => setIsDialogOpen(false)}>
                Cancel
              </Button>
              <Button onClick={handleUpdateShow} disabled={isUpdating}>
                {isUpdating ? (
                  <>
                    <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                    Saving...
                  </>
                ) : 'Save Changes'}
              </Button>
            </div>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Add Show Dialog */}
      <Dialog open={isAddDialogOpen} onOpenChange={setIsAddDialogOpen}>
        <DialogContent className="sm:max-w-[800px] max-h-[90vh] overflow-y-auto">
          <DialogHeader>
            <DialogTitle>Add New TV Show</DialogTitle>
            <DialogDescription>
              Create a new TV show entry in the database.
            </DialogDescription>
          </DialogHeader>
          
          <div className="space-y-6 py-4">
            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="name" className="text-right">
                Show Name
              </Label>
              <div className="col-span-3 flex gap-2">
                <Input
                  id="name"
                  value={newShowFormState.name}
                  onChange={(e) => setNewShowFormState({...newShowFormState, name: e.target.value})}
                  className="flex-1"
                  placeholder="Official TV show name"
                  required
                />
                <Button 
                  type="button" 
                  variant="outline" 
                  className="flex-shrink-0"
                  onClick={() => {
                    if (!newShowFormState.name) {
                      toast({
                        title: "Error",
                        description: "Please enter a show name before searching",
                        variant: "destructive"
                      });
                      return;
                    }
                    
                    setIsLookingUp(true);
                    setLookupResults({omdb: null, youtube: null});
                    
                    // Call the lookup API
                    apiRequest('GET', `/api/lookup-show?name=${encodeURIComponent(newShowFormState.name)}`)
                      .then(resp => resp.json())
                      .then(data => {
                        setLookupResults(data);
                        setShowLookupOptions(true);
                        setIsLookingUp(false);
                      })
                      .catch(err => {
                        console.error("Lookup error:", err);
                        toast({
                          title: "Error",
                          description: err.message || "Failed to look up show data",
                          variant: "destructive"
                        });
                        setIsLookingUp(false);
                      });
                  }}
                  disabled={isLookingUp}
                >
                  {isLookingUp ? (
                    <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                  ) : (
                    <Search className="h-4 w-4 mr-2" />
                  )}
                  Smart Lookup
                </Button>
              </div>
            </div>
            
            {/* Display lookup results when available */}
            {showLookupOptions && (lookupResults.omdb || lookupResults.youtube) && (
              <div className="grid grid-cols-4 gap-4 mt-4">
                <div className="col-start-2 col-span-3">
                  <Alert className={lookupResults.omdb ? "border-green-500" : lookupResults.youtube ? "border-red-500" : ""}>
                    <AlertTitle className="flex items-center gap-2">
                      <CheckCircle className="h-5 w-5 text-green-500" />
                      API Data Found Successfully!
                    </AlertTitle>
                    <AlertDescription className="mt-3">
                      {lookupResults.omdb && (
                        <div className="mb-4 p-3 border rounded bg-muted/30">
                          <h4 className="font-medium mb-2 flex items-center">
                            <FileText className="h-4 w-4 mr-2 text-blue-500" />
                            <span className="text-blue-500 font-semibold">OMDb Data Found:</span>
                          </h4>
                          <p className="text-sm text-muted-foreground mb-3">
                            <strong>Title:</strong> {lookupResults.omdb.title}<br />
                            <strong>Year:</strong> {lookupResults.omdb.year}<br />
                            <strong>Director:</strong> {lookupResults.omdb.director || "Not available"}<br />
                            <strong>Plot:</strong> {lookupResults.omdb.plot?.substring(0, 100)}...
                          </p>
                          <Button 
                            type="button"
                            size="sm"
                            className="bg-blue-500 hover:bg-blue-600 text-white"
                            onClick={() => {
                              // Extract year information
                              const releaseYear = lookupResults.omdb.year ? 
                                parseInt(lookupResults.omdb.year.split('–')[0]) : null;
                              const endYear = lookupResults.omdb.year && lookupResults.omdb.year.includes('–') ?
                                parseInt(lookupResults.omdb.year.split('–')[1]) || null : null;
                              
                              // Set a reference to the current button using event target
                              const button = document.activeElement as HTMLButtonElement;
                              
                              setNewShowFormState(prev => ({
                                ...prev,
                                description: lookupResults.omdb.plot || prev.description,
                                creator: lookupResults.omdb.director || prev.creator,
                                releaseYear: releaseYear || prev.releaseYear,
                                endYear: endYear || prev.endYear,
                                episodeLength: prev.episodeLength || 30,
                                isOngoing: !endYear,
                                imageUrl: lookupResults.omdb.poster || prev.imageUrl,
                                hasOmdbData: true // Set the flag that OMDb data was used
                              }));
                              
                              // Change button text
                              if (button) {
                                button.innerText = "Added Successfully";
                                
                                // Optional: Disable the button to prevent multiple clicks
                                button.disabled = true;
                              }
                              
                              // Keep the lookup options panel open
                              toast({
                                title: "OMDb Data Added",
                                description: "Official TV show data has been applied to the form"
                              });
                            }}
                          >
                            <FileText className="h-4 w-4 mr-2" />
                            Add API Data
                          </Button>
                        </div>
                      )}
                      
                      {lookupResults.youtube && (
                        <div className="p-3 border rounded bg-muted/30">
                          <h4 className="font-medium mb-2 flex items-center">
                            <Video className="h-4 w-4 mr-2 text-red-500" />
                            <span className="text-red-500 font-semibold">YouTube Data Found:</span>
                          </h4>
                          <p className="text-sm text-muted-foreground mb-3">
                            <strong>Channel:</strong> {lookupResults.youtube.title}<br />
                            <strong>Subscribers:</strong> {parseInt(lookupResults.youtube.subscriberCount).toLocaleString()}<br />
                            <strong>Videos:</strong> {parseInt(lookupResults.youtube.videoCount).toLocaleString()}<br />
                            <strong>Created:</strong> {new Date(lookupResults.youtube.publishedAt).toLocaleDateString()}
                          </p>
                          <Button 
                            type="button"
                            size="sm" 
                            className="bg-red-500 hover:bg-red-600 text-white"
                            onClick={() => {
                              const releaseYear = lookupResults.youtube.publishedAt ?
                                new Date(lookupResults.youtube.publishedAt).getFullYear() : null;
                              
                              // Set a reference to the current button using event target
                              const button = document.activeElement as HTMLButtonElement;
                              
                              // Properly handle the availableOn field as an array
                              let updatedAvailableOn;
                              if (Array.isArray(newShowFormState.availableOn)) {
                                // If it's already an array, add YouTube if not present
                                updatedAvailableOn = newShowFormState.availableOn.includes('YouTube') 
                                  ? newShowFormState.availableOn 
                                  : [...newShowFormState.availableOn, 'YouTube'];
                              } else if (typeof newShowFormState.availableOn === 'string') {
                                // If it's a string, split by comma and add YouTube if not present
                                const platforms = (newShowFormState.availableOn as string).split(',').map((p: string) => p.trim());
                                updatedAvailableOn = platforms.includes('YouTube') 
                                  ? platforms 
                                  : [...platforms, 'YouTube'];
                              } else {
                                // Default to an array with just YouTube
                                updatedAvailableOn = ['YouTube'];
                              }
                              
                              setNewShowFormState(prev => ({
                                ...prev,
                                description: lookupResults.youtube.description || prev.description,
                                releaseYear: releaseYear || prev.releaseYear,
                                isOngoing: true,
                                subscriberCount: lookupResults.youtube.subscriberCount || prev.subscriberCount,
                                videoCount: lookupResults.youtube.videoCount || prev.videoCount,
                                isYouTubeChannel: true,
                                publishedAt: lookupResults.youtube.publishedAt || prev.publishedAt,
                                channelId: lookupResults.youtube.channelId || prev.channelId,
                                availableOn: updatedAvailableOn,
                                hasYoutubeData: true // Set the flag that YouTube data was used
                              }));
                              
                              // Change button text
                              if (button) {
                                button.innerText = "Added Successfully";
                                
                                // Optional: Disable the button to prevent multiple clicks
                                button.disabled = true;
                              }
                              
                              // Keep the lookup options panel open
                              toast({
                                title: "YouTube Data Added",
                                description: "Official YouTube channel data has been applied to the form"
                              });
                            }}
                          >
                            <Video className="h-4 w-4 mr-2" />
                            Add API Data
                          </Button>
                        </div>
                      )}
                      
                      <Button 
                        type="button"
                        size="sm"
                        variant="ghost"
                        className="mt-3"
                        onClick={() => setShowLookupOptions(false)}
                      >
                        <X className="h-4 w-4 mr-2" />
                        Cancel
                      </Button>
                    </AlertDescription>
                  </Alert>
                </div>
              </div>
            )}
            
            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="description" className="text-right">
                Description
              </Label>
              <Textarea
                id="description"
                value={newShowFormState.description}
                onChange={(e) => setNewShowFormState({...newShowFormState, description: e.target.value})}
                className="col-span-3"
                placeholder="Brief description of the show"
                rows={3}
              />
            </div>
            
            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="ageRange" className="text-right">
                Age Range
              </Label>
              <Input
                id="ageRange"
                value={newShowFormState.ageRange}
                onChange={(e) => setNewShowFormState({...newShowFormState, ageRange: e.target.value})}
                className="col-span-3"
                placeholder="e.g., '3-5 years' or '8-12 years'"
              />
            </div>
            
            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="stimulationScore" className="text-right">
                Stimulation Score (1-5)
              </Label>
              <Input
                id="stimulationScore"
                type="number"
                min={1}
                max={5}
                step={1}
                value={newShowFormState.stimulationScore}
                onChange={(e) => setNewShowFormState({
                  ...newShowFormState, 
                  stimulationScore: Math.round(Number(e.target.value))
                })}
                className="col-span-3"
                placeholder="Enter a whole number from 1-5"
                required
              />
            </div>
            
            {/* 
              Removed "Overall Rating" field since we're using 
              stimulation score for both (they are the same thing) 
            */}
            
            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="interactivityLevel" className="text-right">
                Interactivity Level
              </Label>
              <Select 
                value={newShowFormState.interactivityLevel}
                onValueChange={(value) => setNewShowFormState({...newShowFormState, interactivityLevel: value})}
              >
                <SelectTrigger className="col-span-3">
                  <SelectValue placeholder="Select interactivity level" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="Low">Low</SelectItem>
                  <SelectItem value="Low-Moderate">Low-Moderate</SelectItem>
                  <SelectItem value="Medium">Medium</SelectItem>
                  <SelectItem value="Moderate-High">Moderate-High</SelectItem>
                  <SelectItem value="High">High</SelectItem>
                </SelectContent>
              </Select>
            </div>
            
            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="dialogueIntensity" className="text-right">
                Dialogue Intensity
              </Label>
              <Select 
                value={newShowFormState.dialogueIntensity}
                onValueChange={(value) => setNewShowFormState({...newShowFormState, dialogueIntensity: value})}
              >
                <SelectTrigger className="col-span-3">
                  <SelectValue placeholder="Select dialogue intensity" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="Low">Low</SelectItem>
                  <SelectItem value="Low-Moderate">Low-Moderate</SelectItem>
                  <SelectItem value="Medium">Medium</SelectItem>
                  <SelectItem value="Moderate-High">Moderate-High</SelectItem>
                  <SelectItem value="High">High</SelectItem>
                </SelectContent>
              </Select>
            </div>
            
            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="soundEffectsLevel" className="text-right">
                Sound Effects Level
              </Label>
              <Select 
                value={newShowFormState.soundEffectsLevel}
                onValueChange={(value) => setNewShowFormState({...newShowFormState, soundEffectsLevel: value})}
              >
                <SelectTrigger className="col-span-3">
                  <SelectValue placeholder="Select sound effects level" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="Low">Low</SelectItem>
                  <SelectItem value="Low-Moderate">Low-Moderate</SelectItem>
                  <SelectItem value="Medium">Medium</SelectItem>
                  <SelectItem value="Moderate-High">Moderate-High</SelectItem>
                  <SelectItem value="High">High</SelectItem>
                </SelectContent>
              </Select>
            </div>
            
            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="sceneFrequency" className="text-right">
                Scene Frequency
              </Label>
              <Select 
                value={newShowFormState.sceneFrequency}
                onValueChange={(value) => setNewShowFormState({...newShowFormState, sceneFrequency: value})}
              >
                <SelectTrigger className="col-span-3">
                  <SelectValue placeholder="Select scene frequency" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="Low">Low</SelectItem>
                  <SelectItem value="Low-Moderate">Low-Moderate</SelectItem>
                  <SelectItem value="Medium">Medium</SelectItem>
                  <SelectItem value="Moderate-High">Moderate-High</SelectItem>
                  <SelectItem value="High">High</SelectItem>
                </SelectContent>
              </Select>
            </div>
            
            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="musicTempo" className="text-right">
                Music Tempo
              </Label>
              <Select 
                value={newShowFormState.musicTempo}
                onValueChange={(value) => setNewShowFormState({...newShowFormState, musicTempo: value})}
              >
                <SelectTrigger className="col-span-3">
                  <SelectValue placeholder="Select music tempo" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="Low">Low</SelectItem>
                  <SelectItem value="Low-Moderate">Low-Moderate</SelectItem>
                  <SelectItem value="Medium">Medium</SelectItem>
                  <SelectItem value="Moderate-High">Moderate-High</SelectItem>
                  <SelectItem value="High">High</SelectItem>
                </SelectContent>
              </Select>
            </div>
            
            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="totalMusicLevel" className="text-right">
                Total Music Level
              </Label>
              <Select 
                value={newShowFormState.totalMusicLevel}
                onValueChange={(value) => setNewShowFormState({...newShowFormState, totalMusicLevel: value})}
              >
                <SelectTrigger className="col-span-3">
                  <SelectValue placeholder="Select total music level" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="Low">Low</SelectItem>
                  <SelectItem value="Low-Moderate">Low-Moderate</SelectItem>
                  <SelectItem value="Medium">Medium</SelectItem>
                  <SelectItem value="Moderate-High">Moderate-High</SelectItem>
                  <SelectItem value="High">High</SelectItem>
                </SelectContent>
              </Select>
            </div>
            
            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="totalSoundEffectTimeLevel" className="text-right">
                Total Sound Effect Time
              </Label>
              <Select 
                value={newShowFormState.totalSoundEffectTimeLevel}
                onValueChange={(value) => setNewShowFormState({...newShowFormState, totalSoundEffectTimeLevel: value})}
              >
                <SelectTrigger className="col-span-3">
                  <SelectValue placeholder="Select total sound effect time level" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="Low">Low</SelectItem>
                  <SelectItem value="Low-Moderate">Low-Moderate</SelectItem>
                  <SelectItem value="Medium">Medium</SelectItem>
                  <SelectItem value="Moderate-High">Moderate-High</SelectItem>
                  <SelectItem value="High">High</SelectItem>
                </SelectContent>
              </Select>
            </div>
            
            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="themes" className="text-right">
                Themes
              </Label>
              <div className="col-span-3">
                <ThemeSelector
                  selectedThemes={Array.isArray(newShowFormState.themes) ? newShowFormState.themes : []}
                  onThemesChange={(themes) => setNewShowFormState({...newShowFormState, themes})}
                  placeholder="Select or add themes..."
                />
              </div>
            </div>
            
            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="animationStyle" className="text-right">
                Animation Style
              </Label>
              <Textarea
                id="animationStyle"
                value={newShowFormState.animationStyle}
                onChange={(e) => setNewShowFormState({...newShowFormState, animationStyle: e.target.value})}
                className="col-span-3"
                placeholder="Describe the animation style (e.g., '3D Animation', 'Stop-motion with hand-crafted models')"
                rows={3}
              />
            </div>
            
            {/* Additional required fields for database */}
            <div className="border-t pt-4 mt-4 mb-4">
              <h3 className="text-md font-medium mb-2">Additional Information</h3>
            </div>
            
            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="episodeLength" className="text-right">
                Episode Length (min)
              </Label>
              <Input
                id="episodeLength"
                type="number"
                value={newShowFormState.episodeLength}
                onChange={(e) => setNewShowFormState({...newShowFormState, episodeLength: Number(e.target.value)})}
                className="col-span-3"
                placeholder="Episode length in minutes"
                required
              />
            </div>
            
            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="seasons" className="text-right">
                Seasons
              </Label>
              <Input
                id="seasons"
                type="number"
                value={newShowFormState.seasons}
                onChange={(e) => setNewShowFormState({...newShowFormState, seasons: Number(e.target.value)})}
                className="col-span-3"
                placeholder="Number of seasons"
                required
              />
            </div>
            
            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="releaseYear" className="text-right">
                Release Year
              </Label>
              <Input
                id="releaseYear"
                type="number"
                value={newShowFormState.releaseYear}
                onChange={(e) => setNewShowFormState({...newShowFormState, releaseYear: Number(e.target.value)})}
                className="col-span-3"
                placeholder="Year the show was released"
                required
              />
            </div>
            
            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="creator" className="text-right">
                Creator/Studio
              </Label>
              <Input
                id="creator"
                value={newShowFormState.creator}
                onChange={(e) => setNewShowFormState({...newShowFormState, creator: e.target.value})}
                className="col-span-3"
                placeholder="Creator or studio name"
              />
            </div>
            
            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="availableOn" className="text-right">
                Available On
              </Label>
              <Textarea
                id="availableOn"
                value={Array.isArray(newShowFormState.availableOn) ? newShowFormState.availableOn.join(', ') : ''}
                onChange={(e) => {
                  const platformsArray = e.target.value
                    .split(',')
                    .map(platform => platform.trim())
                    .filter(platform => platform !== '');
                  setNewShowFormState({...newShowFormState, availableOn: platformsArray});
                }}
                className="col-span-3"
                placeholder="Enter platforms separated by commas (e.g., 'Netflix, Disney+, YouTube')"
                rows={2}
              />
            </div>
            
            <div className="grid grid-cols-4 items-center gap-4">
              <div className="text-right col-span-1">
                <Label>Show Image</Label>
              </div>
              <div className="col-span-3">
                <ImageUpload 
                  imageUrl={newShowFormState.imageUrl} 
                  onImageChange={(imageUrl) => setNewShowFormState({...newShowFormState, imageUrl})}
                />
              </div>
            </div>
          </div>
          
          <DialogFooter>
            <Button variant="outline" onClick={() => setIsAddDialogOpen(false)}>
              Cancel
            </Button>
            <Button onClick={handleSubmitNewShow} disabled={isAddingShow}>
              {isAddingShow ? (
                <>
                  <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                  Adding Show...
                </>
              ) : 'Add Show'}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </main>
  );
}

// Show Submissions Management Component
function ShowSubmissionsSection() {
  const [submissions, setSubmissions] = useState<any[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [rejectDialogOpen, setRejectDialogOpen] = useState(false);
  const [rejectionReason, setRejectionReason] = useState('');
  const [selectedSubmission, setSelectedSubmission] = useState<any>(null);
  const [isRejecting, setIsRejecting] = useState(false);
  const { toast } = useToast();

  // Fetch pending submissions grouped by popularity
  const fetchSubmissions = async () => {
    try {
      setIsLoading(true);
      
      // First make sure we're authenticated and have the latest session
      const userCheckResponse = await apiRequest('GET', '/api/user');
      if (!userCheckResponse.ok) {
        console.warn('User authentication required for show submissions');
        // Don't redirect here since this is a component within the admin page
        toast({
          title: "Authentication Required",
          description: "Please refresh the page and log in again",
          variant: "destructive",
        });
        return;
      }
      
      // Use debug mode pattern that works for other admin endpoints
      const isDev = process.env.NODE_ENV === 'development' || window.location.hostname.includes('replit');
      const endpoint = isDev ? '/api/show-submissions/pending?debug=true' : '/api/show-submissions/pending';
      
      console.log('Attempting to fetch show submissions from:', endpoint);
      const response = await apiRequest('GET', endpoint);
      
      if (response.ok) {
        const data = await response.json();
        console.log('Successfully fetched show submissions:', data.length);
        setSubmissions(data);
      } else {
        const errorText = await response.text();
        console.error('Failed to fetch submissions:', errorText);
        toast({
          title: "Error",
          description: "Failed to load show submissions",
          variant: "destructive",
        });
      }
    } catch (error) {
      console.error('Error fetching submissions:', error);
      toast({
        title: "Error",
        description: "Failed to load show submissions",
        variant: "destructive",
      });
    } finally {
      setIsLoading(false);
    }
  };

  // Load submissions on component mount
  useEffect(() => {
    fetchSubmissions();
  }, []);

  const handleApproveSubmission = async (submission: any) => {
    try {
      console.log('Approving submission:', submission);
      
      // Use fetch directly instead of apiRequest to avoid any interference
      const response = await fetch('/api/show-submissions/approve', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'include', // Include cookies for authentication
        body: JSON.stringify({
          normalizedName: submission.normalized_name,
          linkedShowId: null
        })
      });

      console.log('Response status:', response.status, response.ok);
      
      if (!response.ok) {
        const errorText = await response.text();
        console.error('Error response:', errorText);
        throw new Error(`Failed to approve submission: ${errorText}`);
      }

      const result = await response.json();
      console.log('Parsed result:', result);
      
      toast({
        title: "Show Approved Successfully!",
        description: `"${submission.show_name}" approved! ${result.usersRewarded} users earned ${result.pointsAwarded} points each.`,
      });

      // Refresh the submissions list to remove the approved item
      await fetchSubmissions();
      
    } catch (error) {
      console.error('Error approving submission:', error);
      toast({
        title: "Error",
        description: error instanceof Error ? error.message : "Failed to approve submission",
        variant: "destructive",
      });
    }
  };

  const handleRejectSubmission = async () => {
    if (!selectedSubmission) return;
    
    try {
      setIsRejecting(true);
      
      const response = await fetch('/api/show-submissions/reject', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'include',
        body: JSON.stringify({
          normalizedName: selectedSubmission.normalized_name,
          rejectionReason: rejectionReason.trim() || undefined
        })
      });

      if (response.ok) {
        const result = await response.json();
        toast({
          title: "Show Request Rejected",
          description: `Successfully rejected "${selectedSubmission.show_name}" and notified ${result.notifiedUsers} user(s).`,
        });
        
        // Reset dialog state
        setRejectDialogOpen(false);
        setRejectionReason('');
        setSelectedSubmission(null);
        
        // Refresh submissions list
        fetchSubmissions();
      } else {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Failed to reject submission');
      }
    } catch (error) {
      console.error('Error rejecting submission:', error);
      toast({
        title: "Error",
        description: `Failed to reject show request: ${error.message}`,
        variant: "destructive",
      });
    } finally {
      setIsRejecting(false);
    }
  };

  const openRejectDialog = (submission: any) => {
    setSelectedSubmission(submission);
    setRejectionReason('');
    setRejectDialogOpen(true);
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center p-8">
        <Loader2 className="h-8 w-8 animate-spin" />
        <span className="ml-2">Loading submissions...</span>
      </div>
    );
  }

  if (submissions.length === 0) {
    return (
      <div className="text-center p-8">
        <Clock className="h-12 w-12 mx-auto text-gray-400 mb-4" />
        <h3 className="text-lg font-medium text-gray-900 mb-2">No Pending Submissions</h3>
        <p className="text-gray-500">All show submissions have been processed.</p>
      </div>
    );
  }

  return (
    <div className="space-y-4">
      <div className="flex items-center justify-between">
        <h3 className="text-lg font-medium">Pending Show Submissions ({submissions.length})</h3>
        <Button onClick={fetchSubmissions} variant="outline" size="sm">
          <RefreshCw className="h-4 w-4 mr-2" />
          Refresh
        </Button>
      </div>

      <div className="space-y-3">
        {submissions.map((submission, index) => (
          <Card key={submission.normalized_name} className="border-l-4 border-l-blue-500">
            <CardContent className="p-4">
              <div className="flex items-start justify-between">
                <div className="flex-1">
                  <div className="flex items-center gap-3 mb-2">
                    <h4 className="font-semibold text-lg">{submission.show_name}</h4>
                    <div className="flex items-center gap-2">
                      <span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-blue-100 text-blue-800">
                        <User className="h-3 w-3 mr-1" />
                        {submission.request_count} request{submission.request_count !== 1 ? 's' : ''}
                      </span>
                      <span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-yellow-100 text-yellow-800">
                        <Clock className="h-3 w-3 mr-1" />
                        Pending
                      </span>
                    </div>
                  </div>
                  
                  <div className="text-sm text-gray-600 space-y-1">
                    <p><strong>Requested by:</strong> {submission.requested_by_users.join(', ')}</p>
                    <p><strong>Platforms:</strong> {submission.platforms.filter((p: string) => p).join(', ')}</p>
                    <p><strong>First requested:</strong> {new Date(submission.first_requested).toLocaleDateString()}</p>
                    <p><strong>Last requested:</strong> {new Date(submission.last_requested).toLocaleDateString()}</p>
                  </div>
                </div>
                
                <div className="flex gap-2 ml-4">
                  <Button
                    onClick={() => handleApproveSubmission(submission)}
                    size="sm"
                    className="bg-green-600 hover:bg-green-700"
                  >
                    <CheckCircle className="h-4 w-4 mr-2" />
                    Approve
                  </Button>
                  <Button
                    onClick={() => openRejectDialog(submission)}
                    variant="outline"
                    size="sm"
                    className="border-red-300 text-red-600 hover:bg-red-50"
                  >
                    <X className="h-4 w-4 mr-2" />
                    Reject
                  </Button>
                </div>
              </div>
            </CardContent>
          </Card>
        ))}
      </div>

      {/* Rejection Reason Dialog */}
      <Dialog open={rejectDialogOpen} onOpenChange={setRejectDialogOpen}>
        <DialogContent className="sm:max-w-md">
          <DialogHeader>
            <DialogTitle>Reject Show Request</DialogTitle>
            <DialogDescription>
              Are you sure you want to reject the request for "{selectedSubmission?.show_name}"? 
              You can optionally provide a reason that will be sent to the users who requested this show.
            </DialogDescription>
          </DialogHeader>
          
          <div className="space-y-4">
            <div>
              <Label htmlFor="rejection-reason">Rejection Reason (Optional)</Label>
              <Textarea
                id="rejection-reason"
                placeholder="e.g., Show not suitable for platform, duplicate content, etc."
                value={rejectionReason}
                onChange={(e) => setRejectionReason(e.target.value)}
                rows={3}
                className="mt-1"
              />
              <p className="text-xs text-gray-500 mt-1">
                This reason will be included in the notification to users who requested this show.
              </p>
            </div>
          </div>

          <DialogFooter>
            <Button 
              variant="outline" 
              onClick={() => setRejectDialogOpen(false)}
              disabled={isRejecting}
            >
              Cancel
            </Button>
            <Button 
              variant="destructive" 
              onClick={handleRejectSubmission}
              disabled={isRejecting}
            >
              {isRejecting ? (
                <>
                  <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                  Rejecting...
                </>
              ) : (
                <>
                  <X className="h-4 w-4 mr-2" />
                  Reject Request
                </>
              )}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  );
}
</file>

<file path="client/src/pages/admin-research-links.tsx">
import React, { useState } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import * as z from "zod";
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card";
import { Separator } from "@/components/ui/separator";
import { toast } from "@/hooks/use-toast";
import { ExternalLink, Search } from "lucide-react";

const linkUpdateSchema = z.object({
  url: z.string().url("Please enter a valid URL"),
});

type ResearchSummary = {
  id: number;
  title: string;
  summary: string;
  category: string;
  originalUrl?: string;
};

const AdminResearchLinks = () => {
  const [selectedResearch, setSelectedResearch] = useState<number | null>(null);
  const [searchTerm, setSearchTerm] = useState("");
  const queryClient = useQueryClient();

  const { data: researchList, isLoading: isLoadingResearch } = useQuery<ResearchSummary[]>({
    queryKey: ["/api/research"],
  });

  const form = useForm({
    resolver: zodResolver(linkUpdateSchema),
    defaultValues: {
      url: "",
    },
  });

  const updateResearchMutation = useMutation({
    mutationFn: async (data: { id: number; url: string }) => {
      const response = await fetch(`/api/research/${data.id}/update-link`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ originalUrl: data.url }),
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || "Failed to update research link");
      }
      
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/research"] });
      toast({
        title: "Link updated",
        description: "The research link has been updated successfully",
      });
      form.reset();
      setSelectedResearch(null);
    },
    onError: (error: Error) => {
      toast({
        title: "Error",
        description: error.message || "Failed to update the research link",
        variant: "destructive",
      });
    },
  });

  const onSubmit = (data: z.infer<typeof linkUpdateSchema>) => {
    if (selectedResearch) {
      updateResearchMutation.mutate({ id: selectedResearch, url: data.url });
    }
  };

  const handleSelect = (id: number) => {
    setSelectedResearch(id);
    // Find if research already has a link
    const research = researchList?.find((r) => r.id === id);
    if (research?.originalUrl) {
      form.setValue("url", research.originalUrl);
    } else {
      form.reset();
    }
  };

  const filteredResearch = researchList?.filter(research => 
    searchTerm === "" || 
    research.title.toLowerCase().includes(searchTerm.toLowerCase()) ||
    research.category.toLowerCase().includes(searchTerm.toLowerCase())
  );

  return (
    <div className="container mx-auto py-8">
      <div className="flex flex-col mb-6">
        <h1 className="text-3xl font-bold mb-2">Research Original Links</h1>
        <p className="text-gray-600 mb-6">
          Update the original source links for research articles. These links should point to the actual published papers.
        </p>
        
        <div className="relative w-full max-w-md mb-6">
          <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400" size={18} />
          <Input
            className="pl-10"
            placeholder="Search by title or category..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
          />
        </div>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-12 gap-8">
        <div className="lg:col-span-8">
          <Card>
            <CardHeader>
              <CardTitle>Research Articles</CardTitle>
              <CardDescription>
                Select a research article to update its original source link
              </CardDescription>
            </CardHeader>
            <CardContent>
              {isLoadingResearch ? (
                <div className="p-8 text-center">Loading research articles...</div>
              ) : (
                <div className="space-y-4">
                  {filteredResearch?.map((research) => (
                    <div 
                      key={research.id} 
                      className={`p-4 border rounded-md cursor-pointer ${
                        selectedResearch === research.id 
                          ? "border-blue-500 bg-blue-50" 
                          : "hover:border-gray-400"
                      }`}
                      onClick={() => handleSelect(research.id)}
                    >
                      <div className="font-medium">{research.title}</div>
                      <div className="text-sm text-gray-500 mt-1">Category: {research.category}</div>
                      {research.originalUrl && (
                        <div className="text-xs text-green-600 mt-2 flex items-center">
                          <ExternalLink size={12} className="mr-1" />
                          Has link: {research.originalUrl}
                        </div>
                      )}
                    </div>
                  ))}
                  
                  {filteredResearch?.length === 0 && (
                    <div className="p-8 text-center text-gray-500">
                      No research articles match your search.
                    </div>
                  )}
                </div>
              )}
            </CardContent>
          </Card>
        </div>

        <div className="lg:col-span-4">
          <Card>
            <CardHeader>
              <CardTitle>Update Link</CardTitle>
              <CardDescription>
                {selectedResearch 
                  ? "Enter the original research URL" 
                  : "Select a research article first"}
              </CardDescription>
            </CardHeader>
            <CardContent>
              <Form {...form}>
                <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
                  <FormField
                    control={form.control}
                    name="url"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Original Research URL</FormLabel>
                        <FormControl>
                          <Input 
                            {...field} 
                            placeholder="https://..." 
                            disabled={!selectedResearch}
                          />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />
                  <Button 
                    type="submit" 
                    disabled={!selectedResearch || updateResearchMutation.isPending}
                    className="w-full"
                  >
                    {updateResearchMutation.isPending ? "Updating..." : "Update Link"}
                  </Button>
                </form>
              </Form>
            </CardContent>
          </Card>
        </div>
      </div>
    </div>
  );
};

export default AdminResearchLinks;
</file>

<file path="client/src/pages/admin-research-manager.tsx">
import { useState, useEffect } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import * as z from 'zod';
import { ArrowLeft, FileText, Loader2, Save } from 'lucide-react';
import { useLocation } from 'wouter';
import { useMutation } from '@tanstack/react-query';
import { queryClient } from '@/lib/queryClient';

import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from '@/components/ui/card';
import {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from '@/components/ui/form';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';
import { useToast } from '@/hooks/use-toast';
import FileUploader from '@/components/FileUploader';

// Define the schema for research entry
const researchFormSchema = z.object({
  title: z.string().min(3, {
    message: 'Research title must be at least 3 characters.',
  }),
  category: z.string({
    required_error: 'Please select a category.',
  }),
  source: z.string().optional(),
  originalUrl: z.string().url({
    message: 'Please enter a valid URL for the original study.',
  }).optional(),
  publishedDate: z.string().optional(),
  summary: z.string().optional(),
  fullText: z.string().optional(),
  headline: z.string().optional(),
  subHeadline: z.string().optional(),
  keyFindings: z.string().optional(),
  imageUrl: z.string().optional(),
});

type ResearchFormValues = z.infer<typeof researchFormSchema>;

export default function AdminResearchManager() {
  const [isUploading, setIsUploading] = useState(false);
  const [uploadedImageUrl, setUploadedImageUrl] = useState<string | null>(null);
  const { toast } = useToast();
  const [location, setLocation] = useLocation();
  const [isLoading, setIsLoading] = useState(false);
  const [isEditMode, setIsEditMode] = useState(false);
  const [editId, setEditId] = useState<number | null>(null);

  // Default values for form
  const defaultValues: Partial<ResearchFormValues> = {
    title: '',
    category: '',
    source: '',
    originalUrl: '',
    publishedDate: '',
    summary: '',
    fullText: '',
    headline: '',
    subHeadline: '',
    keyFindings: '',
    imageUrl: '',
  };

  const form = useForm<ResearchFormValues>({
    resolver: zodResolver(researchFormSchema),
    defaultValues,
    mode: 'onChange',
  });
  
  // Check if we're in edit mode by checking localStorage
  useEffect(() => {
    console.log("Current location: ", location);
    
    // Get the edit ID from localStorage if it exists
    const storedEditId = localStorage.getItem('editResearchId');
    console.log("Stored edit ID from localStorage: ", storedEditId);
    
    if (storedEditId) {
      const id = parseInt(storedEditId, 10);
      console.log("Parsed ID: ", id);
      
      if (!isNaN(id)) {
        console.log("Setting edit mode for ID: ", id);
        setIsEditMode(true);
        setEditId(id);
        fetchResearchEntry(id);
        
        // Clear the localStorage item after we've used it
        localStorage.removeItem('editResearchId');
      }
    }
    // Also check URL parameters for backward compatibility
    else if (location.includes('?')) {
      const searchParams = new URLSearchParams(location.split('?')[1]);
      const editParam = searchParams.get('edit');
      
      console.log("Edit parameter from URL: ", editParam);
      
      if (editParam) {
        const id = parseInt(editParam, 10);
        if (!isNaN(id)) {
          console.log("Setting edit mode for ID from URL: ", id);
          setIsEditMode(true);
          setEditId(id);
          fetchResearchEntry(id);
        }
      }
    }
  }, [location]);
  
  // Fetch research entry data for editing
  const fetchResearchEntry = async (id: number) => {
    setIsLoading(true);
    try {
      const response = await fetch(`/api/research/${id}`);
      if (!response.ok) {
        throw new Error('Failed to fetch research entry');
      }
      
      const data = await response.json();
      console.log('Fetched research entry:', data);
      
      // Make sure we have a valid date format for the published date field
      let formattedDate = '';
      if (data.publishedDate) {
        try {
          // If it's a valid date string, format it as YYYY-MM-DD for the input field
          const date = new Date(data.publishedDate);
          if (!isNaN(date.getTime())) {
            formattedDate = date.toISOString().split('T')[0];
          }
        } catch (e) {
          console.error('Error formatting date:', e);
        }
      }
      
      // Pre-fill the form with the fetched data - ensure all fields are properly populated
      const formData = {
        title: data.title || '',
        category: data.category || '',
        source: data.source || '',
        originalUrl: data.originalUrl || '',
        publishedDate: formattedDate,
        summary: data.summary || '',
        fullText: data.fullText || '',
        headline: data.headline || '',
        subHeadline: data.subHeadline || '',
        keyFindings: data.keyFindings || '',
        imageUrl: data.imageUrl || ''
      };
      
      console.log('Setting form data:', formData);
      
      // Update form values and trigger validation
      form.reset(formData);
      
      // Set each field value individually to ensure the form is updated
      Object.entries(formData).forEach(([key, value]) => {
        form.setValue(key as keyof ResearchFormValues, value);
      });
      
      // If there's an image URL, set it in state
      if (data.imageUrl) {
        setUploadedImageUrl(data.imageUrl);
      }
      
      toast({
        title: 'Research entry loaded',
        description: 'You are now editing an existing research entry.',
      });
    } catch (error) {
      console.error('Error fetching research entry:', error);
      toast({
        title: 'Error',
        description: 'Failed to load research entry data.',
        variant: 'destructive'
      });
    } finally {
      setIsLoading(false);
    }
  };
  
  const { mutate: submitResearch, isPending } = useMutation({
    mutationFn: async (data: ResearchFormValues) => {
      // Include the uploaded image URL if available
      if (uploadedImageUrl) {
        data.imageUrl = uploadedImageUrl;
      }
      
      let url = '/api/research';
      let method = 'POST';
      
      // If in edit mode, use PATCH method with the edit ID
      if (isEditMode && editId) {
        url = `/api/research/${editId}`;
        method = 'PATCH';
      }
      
      console.log(`${isEditMode ? 'Updating' : 'Creating'} research entry:`, data);
      
      const response = await fetch(url, {
        method,
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(data),
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || `Failed to ${isEditMode ? 'update' : 'create'} research entry`);
      }
      
      return response.json();
    },
    onSuccess: () => {
      toast({
        title: isEditMode ? 'Research updated' : 'Research created',
        description: `The research entry has been ${isEditMode ? 'updated' : 'created'} successfully.`,
      });
      // Invalidate research query cache
      queryClient.invalidateQueries({ queryKey: ['/api/research'] });
      // Navigate back to admin dashboard
      setLocation('/admin');
    },
    onError: (error: Error) => {
      toast({
        title: 'Error',
        description: error.message,
        variant: 'destructive',
      });
    },
  });

  function onSubmit(data: ResearchFormValues) {
    submitResearch(data);
  }

  // Handle image upload
  const handleImageUpload = (url: string) => {
    setUploadedImageUrl(url);
    form.setValue('imageUrl', url);
  };

  const researchCategories = [
    'Screen Time',
    'Cognitive Development',
    'Learning Outcomes',
    'Parental Guidance',
    'Media Effects',
    'Content Analysis',
    'Child Psychology',
    'Educational Impact',
    'Social Development',
    'Digital Literacy',
    'Other'
  ];

  return (
    <main className="container mx-auto py-8 px-4">
      <Card className="mb-8">
        <CardHeader>
          <div className="flex items-center mb-2">
            <Button
              variant="ghost"
              size="sm"
              className="mr-2"
              onClick={() => setLocation('/admin')}
            >
              <ArrowLeft className="h-4 w-4 mr-1" />
              Back
            </Button>
          </div>
          <CardTitle>Add Research Summary</CardTitle>
          <CardDescription>
            Create a new research summary to share insights with your audience
          </CardDescription>
        </CardHeader>
      </Card>

      <div className="grid md:grid-cols-3 gap-6">
        <div className="md:col-span-2">
          <Card>
            <CardHeader>
              <CardTitle>Research Details</CardTitle>
              <CardDescription>
                Enter the details of the research summary
              </CardDescription>
            </CardHeader>
            <CardContent>
              <Form {...form}>
                <form
                  onSubmit={form.handleSubmit(onSubmit)}
                  className="space-y-6"
                >
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <FormField
                      control={form.control}
                      name="title"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Title *</FormLabel>
                          <FormControl>
                            <Input placeholder="Research title" {...field} />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />

                    <FormField
                      control={form.control}
                      name="category"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Category *</FormLabel>
                          <Select
                            onValueChange={field.onChange}
                            value={field.value}
                          >
                            <FormControl>
                              <SelectTrigger>
                                <SelectValue placeholder="Select a category" />
                              </SelectTrigger>
                            </FormControl>
                            <SelectContent>
                              {researchCategories.map((category) => (
                                <SelectItem key={category} value={category}>
                                  {category}
                                </SelectItem>
                              ))}
                            </SelectContent>
                          </Select>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                  </div>

                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <FormField
                      control={form.control}
                      name="source"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Source</FormLabel>
                          <FormControl>
                            <Input
                              placeholder="Research source (e.g., Journal name, University)"
                              {...field}
                            />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />

                    <FormField
                      control={form.control}
                      name="publishedDate"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Published Date</FormLabel>
                          <FormControl>
                            <Input
                              type="date"
                              placeholder="YYYY-MM-DD"
                              {...field}
                            />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                  </div>

                  <FormField
                    control={form.control}
                    name="originalUrl"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Original Study URL</FormLabel>
                        <FormControl>
                          <Input
                            placeholder="https://example.com/research-study"
                            {...field}
                          />
                        </FormControl>
                        <FormDescription>
                          Direct link to the original study or research paper
                        </FormDescription>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={form.control}
                    name="headline"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Headline</FormLabel>
                        <FormControl>
                          <Input
                            placeholder="Main headline for the research"
                            {...field}
                          />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={form.control}
                    name="subHeadline"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Sub-headline</FormLabel>
                        <FormControl>
                          <Input
                            placeholder="Supporting subheadline"
                            {...field}
                          />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={form.control}
                    name="summary"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Summary</FormLabel>
                        <FormControl>
                          <Textarea
                            placeholder="Brief summary of the research findings"
                            className="min-h-[100px]"
                            {...field}
                          />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={form.control}
                    name="keyFindings"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Key Findings</FormLabel>
                        <FormControl>
                          <Textarea
                            placeholder="Bullet-point list of key findings (separate with new lines)"
                            className="min-h-[100px]"
                            {...field}
                          />
                        </FormControl>
                        <FormDescription>
                          Enter each key finding on a new line. They will be formatted as bullet points.
                        </FormDescription>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={form.control}
                    name="fullText"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Full Text</FormLabel>
                        <FormControl>
                          <Textarea
                            placeholder="Complete text of the research summary (separate paragraphs with new lines)"
                            className="min-h-[200px]"
                            {...field}
                          />
                        </FormControl>
                        <FormDescription>
                          Enter each paragraph on a separate line. Your text will be properly formatted when displayed.
                        </FormDescription>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <CardFooter className="flex justify-end px-0 pb-0">
                    <Button
                      type="submit"
                      disabled={isPending}
                      className="flex items-center"
                    >
                      {isPending ? (
                        <>
                          <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                          Saving...
                        </>
                      ) : (
                        <>
                          <Save className="mr-2 h-4 w-4" />
                          Save Research
                        </>
                      )}
                    </Button>
                  </CardFooter>
                </form>
              </Form>
            </CardContent>
          </Card>
        </div>

        <div>
          <Card className="mb-6">
            <CardHeader>
              <CardTitle>Featured Image</CardTitle>
              <CardDescription>
                Upload an image to accompany the research summary
              </CardDescription>
            </CardHeader>
            <CardContent>
              <FileUploader
                onUploadComplete={handleImageUpload}
                onUploadStart={() => setIsUploading(true)}
                onUploadError={(error) => {
                  setIsUploading(false);
                  toast({
                    title: 'Upload failed',
                    description: error,
                    variant: 'destructive',
                  });
                }}
                folder="research-images"
              />
              {uploadedImageUrl && (
                <div className="mt-4">
                  <p className="text-sm font-medium mb-2">Preview:</p>
                  <img
                    src={uploadedImageUrl}
                    alt="Uploaded preview"
                    className="rounded-md w-full max-h-[200px] object-cover"
                  />
                </div>
              )}
            </CardContent>
          </Card>

          <Card>
            <CardHeader>
              <CardTitle>Help</CardTitle>
            </CardHeader>
            <CardContent>
              <Alert>
                <FileText className="h-4 w-4" />
                <AlertTitle>Tips for Research Entries</AlertTitle>
                <AlertDescription>
                  <ul className="list-disc pl-4 mt-2 text-sm space-y-1">
                    <li>Fields marked with * are required</li>
                    <li>Use clear, descriptive titles that explain the research</li>
                    <li>Include original study links when available</li>
                    <li>Format key findings as short, actionable insights</li>
                    <li>Choose relevant categories to help users find content</li>
                  </ul>
                </AlertDescription>
              </Alert>
            </CardContent>
          </Card>
        </div>
      </div>
    </main>
  );
}
</file>

<file path="client/src/pages/auth-page.tsx">
import { useState, useEffect } from "react";
import { useLocation, useRoute } from "wouter";
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { useAuth } from "@/hooks/use-auth";
import { useToast } from "@/hooks/use-toast";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { Form, FormControl, FormDescription, FormField, FormItem, FormLabel, FormMessage } from "@/components/ui/form";
import { CheckCircle2, XCircle } from "lucide-react";

// Schema for login form
const loginSchema = z.object({
  identifier: z.string().min(3, "Please enter a valid email or username"),
  password: z.string().min(6, "Password must be at least 6 characters"),
});

// Schema for registration form with additional fields
const registerSchema = z.object({
  email: z.string().email("Please enter a valid email address"),
  username: z.string().min(3, "Username must be at least 3 characters"),
  password: z.string().min(6, "Password must be at least 6 characters"),
  confirmPassword: z.string().min(6, "Confirm password must be at least 6 characters"),
}).refine(data => data.password === data.confirmPassword, {
  message: "Passwords do not match",
  path: ["confirmPassword"],
});

type LoginFormValues = z.infer<typeof loginSchema>;
type RegisterFormValues = z.infer<typeof registerSchema>;

export default function AuthPage() {
  const [activeTab, setActiveTab] = useState<string>("login");
  const [, navigate] = useLocation();
  const { toast } = useToast();
  const { user, loginMutation, registerMutation } = useAuth();
  const [usernameStatus, setUsernameStatus] = useState<'checking' | 'available' | 'taken' | null>(null);
  const [usernameValue, setUsernameValue] = useState("");
  const [isCheckingStoredAuth, setIsCheckingStoredAuth] = useState(true);
  const [earlyAccessToken, setEarlyAccessToken] = useState<string | null>(null);
  
  // Check authentication on page load - rely on server session only
  useEffect(() => {
    // Skip localStorage checking, rely on server session
    setIsCheckingStoredAuth(false);
  }, []);
  
  // Check for early access token in localStorage or URL
  useEffect(() => {
    // First check localStorage for token (preferred method)
    const storedToken = localStorage.getItem("earlyAccessToken");
    if (storedToken) {
      console.log("Found token in localStorage:", storedToken);
      setEarlyAccessToken(storedToken);
      
      // Switch to register tab when valid token is present
      if (storedToken === "2025") {
        setActiveTab("register");
      }
      return;
    }
    
    // If not in localStorage, check URL (fallback)
    const params = new URLSearchParams(window.location.search);
    const urlToken = params.get('token');
    
    if (urlToken) {
      console.log("Found token in URL:", urlToken);
      setEarlyAccessToken(urlToken);
      localStorage.setItem("earlyAccessToken", urlToken);
      
      // Switch to register tab when token is present
      if (urlToken === "2025") {
        setActiveTab("register");
      }
    }
  }, []);

  // Username availability check
  useEffect(() => {
    // Don't check if username is less than 3 characters
    if (!usernameValue || usernameValue.length < 3) {
      setUsernameStatus(null);
      return;
    }
    
    // Set status to checking before API call
    setUsernameStatus('checking');
    
    // Debounce the API call - only make it after user stops typing
    const timeoutId = setTimeout(async () => {
      try {
        const response = await fetch(`/api/check-username?username=${encodeURIComponent(usernameValue)}`);
        const data = await response.json();
        setUsernameStatus(data.available ? 'available' : 'taken');
      } catch (error) {
        console.error('Failed to check username availability:', error);
        setUsernameStatus(null);
      }
    }, 500);
    
    return () => clearTimeout(timeoutId);
  }, [usernameValue]);
  
  // Helper function to get the redirect path from URL if available
  const getRedirectPath = () => {
    const params = new URLSearchParams(window.location.search);
    const redirect = params.get('redirect');
    return redirect ? decodeURIComponent(redirect) : '/';
  };

  // Display a loading state while checking authentication
  if (isCheckingStoredAuth) {
    return (
      <div className="container mx-auto flex items-center justify-center h-screen">
        <div className="text-center">
          <div className="animate-spin rounded-full h-10 w-10 border-b-2 border-primary mx-auto mb-4"></div>
          <p className="text-muted-foreground">Checking authentication...</p>
        </div>
      </div>
    );
  }
  
  // Redirect if user is already logged in
  if (user) {
    navigate(getRedirectPath());
    return null;
  }

  // Login and register forms - initialize outside conditional rendering to avoid hook issues
  const loginFormMethods = useForm<LoginFormValues>({
    resolver: zodResolver(loginSchema),
    defaultValues: {
      identifier: "",
      password: "",
    },
  });

  const registerFormMethods = useForm<RegisterFormValues>({
    resolver: zodResolver(registerSchema),
    defaultValues: {
      username: "",
      email: "",
      password: "",
      confirmPassword: "",
    },
  });

  // Handle login submission

  function onLoginSubmit(data: LoginFormValues) {
    loginMutation.mutate(data, {
      onSuccess: () => {
        toast({
          title: "Login successful",
          description: "Welcome back!",
        });
        navigate(getRedirectPath());
      },
      onError: (error: any) => {
        // Debug the error
        console.log('Login error in auth-page:', error.message, error);
        
        // Check if the error is about pending approval by looking at our custom property
        if (error.isPendingApproval || error.message.includes("pending approval")) {
          console.log('Detected pending approval, redirecting...');
          toast({
            title: "Account Pending Approval",
            description: "Your account has been created but requires admin approval.",
          });
          navigate("/registration-pending");
        } else {
          toast({
            title: "Login failed",
            description: error.message || "Please check your credentials and try again",
            variant: "destructive",
          });
        }
      },
    });
  }

  // Handle registration submission
  function onRegisterSubmit(data: RegisterFormValues) {
    // Check username availability before submitting
    if (usernameStatus === 'taken') {
      toast({
        title: "Username already taken",
        description: "Please choose a different username.",
        variant: "destructive",
      });
      return;
    }
    
    // If username is still being checked, wait for the check to complete
    if (usernameStatus === 'checking') {
      toast({
        title: "Please wait",
        description: "We're still checking if your username is available.",
      });
      return;
    }
    
    // Make sure we have a valid early access token
    if (!earlyAccessToken || earlyAccessToken !== "2025") {
      toast({
        title: "Early access token missing",
        description: "You need a valid early access token to register.",
        variant: "destructive",
      });
      return;
    }
    
    // Remove confirmPassword as it's not needed for the API
    const { confirmPassword, ...registerData } = data;
    
    registerMutation.mutate(registerData, {
      onSuccess: () => {
        toast({
          title: "Registration successful",
          description: "Your account has been created and is pending approval.",
        });
        navigate("/registration-pending");
      },
      onError: (error) => {
        // If the error is about username already taken, update the usernameStatus
        if (error.message?.includes("Username already taken")) {
          setUsernameStatus('taken');
          toast({
            title: "Username already taken",
            description: "Please choose a different username.",
            variant: "destructive",
          });
        } else {
          toast({
            title: "Registration failed",
            description: error.message || "Please try again",
            variant: "destructive",
          });
        }
      },
    });
  }

  return (
    <div className="container mx-auto py-10">
      <div className="flex flex-col md:flex-row gap-6 max-w-6xl mx-auto">
        {/* Authentication Forms */}
        <div className="w-full md:w-1/2">
          <Tabs defaultValue="login" value={activeTab} onValueChange={setActiveTab} className="w-full">
            <TabsList className="grid w-full grid-cols-2">
              <TabsTrigger value="login">Login</TabsTrigger>
              <TabsTrigger value="register">Register</TabsTrigger>
            </TabsList>
            
            {/* Login Tab */}
            <TabsContent value="login">
              <Card>
                <CardHeader>
                  <CardTitle>Login to your account</CardTitle>
                  <CardDescription>
                    Enter your credentials to access your account
                  </CardDescription>
                </CardHeader>
                <CardContent className="space-y-4">
                  <Form {...loginFormMethods}>
                    <form onSubmit={loginFormMethods.handleSubmit(onLoginSubmit)} className="space-y-4">
                      <FormField
                        control={loginFormMethods.control}
                        name="identifier"
                        render={({ field }) => (
                          <FormItem>
                            <FormLabel>Email or Username</FormLabel>
                            <FormControl>
                              <Input 
                                type="text"
                                placeholder="Enter your email or username"
                                {...field}
                                disabled={loginMutation.isPending}
                              />
                            </FormControl>
                            <FormMessage />
                          </FormItem>
                        )}
                      />
                      
                      <FormField
                        control={loginFormMethods.control}
                        name="password"
                        render={({ field }) => (
                          <FormItem>
                            <FormLabel>Password</FormLabel>
                            <FormControl>
                              <Input 
                                type="password" 
                                placeholder="Enter your password"
                                {...field}
                                disabled={loginMutation.isPending}
                              />
                            </FormControl>
                            <FormMessage />
                          </FormItem>
                        )}
                      />
                      
                      <Button 
                        type="submit" 
                        className="w-full"
                        disabled={loginMutation.isPending}
                      >
                        {loginMutation.isPending ? "Logging in..." : "Login"}
                      </Button>
                    </form>
                  </Form>
                </CardContent>
                <CardFooter className="flex flex-col">
                  <div className="text-sm text-muted-foreground mt-2">
                    Don't have an account?{" "}
                    <Button 
                      variant="link" 
                      className="p-0 h-auto" 
                      onClick={() => setActiveTab("register")}
                    >
                      Register
                    </Button>
                  </div>
                </CardFooter>
              </Card>
            </TabsContent>
            
            {/* Register Tab */}
            <TabsContent value="register">
              <Card>
                <CardHeader>
                  <CardTitle>Create an account</CardTitle>
                  <CardDescription>
                    Register to save your favorite shows and more
                  </CardDescription>
                </CardHeader>
                <CardContent className="space-y-4">
                  <Form {...registerFormMethods}>
                    <form onSubmit={registerFormMethods.handleSubmit(onRegisterSubmit)} className="space-y-4">
                      <FormField
                        control={registerFormMethods.control}
                        name="username"
                        render={({ field }) => (
                          <FormItem>
                            <FormLabel>Username</FormLabel>
                            <div className="relative">
                              <FormControl>
                                <Input 
                                  placeholder="Choose a display name"
                                  {...field}
                                  onChange={(e) => {
                                    field.onChange(e);
                                    setUsernameValue(e.target.value);
                                  }}
                                  disabled={registerMutation.isPending}
                                  className={usernameStatus === 'taken' ? "pr-10 border-red-500 focus-visible:ring-red-500" : 
                                            usernameStatus === 'available' ? "pr-10 border-green-500 focus-visible:ring-green-500" : 
                                            "pr-10"}
                                />
                              </FormControl>
                              {usernameStatus === 'checking' && (
                                <div className="absolute right-3 top-1/2 -translate-y-1/2">
                                  <svg className="animate-spin h-5 w-5 text-muted-foreground" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                  </svg>
                                </div>
                              )}
                              {usernameStatus === 'available' && field.value.length >= 3 && (
                                <div className="absolute right-3 top-1/2 -translate-y-1/2">
                                  <CheckCircle2 className="h-5 w-5 text-green-500" />
                                </div>
                              )}
                              {usernameStatus === 'taken' && (
                                <div className="absolute right-3 top-1/2 -translate-y-1/2">
                                  <XCircle className="h-5 w-5 text-red-500" />
                                </div>
                              )}
                            </div>
                            {usernameStatus === 'taken' && (
                              <p className="text-sm font-medium text-red-500">
                                Username is already taken
                              </p>
                            )}
                            {usernameStatus === 'available' && field.value.length >= 3 && (
                              <p className="text-sm font-medium text-green-500">
                                Username is available
                              </p>
                            )}
                            <FormDescription>
                              This will be used for your reviews and comments
                            </FormDescription>
                            <FormMessage />
                          </FormItem>
                        )}
                      />
                      
                      <FormField
                        control={registerFormMethods.control}
                        name="email"
                        render={({ field }) => (
                          <FormItem>
                            <FormLabel>Email</FormLabel>
                            <FormControl>
                              <Input 
                                type="email" 
                                placeholder="Enter your email address"
                                {...field}
                                disabled={registerMutation.isPending}
                              />
                            </FormControl>
                            <FormDescription>
                              We'll never share your email with anyone else
                            </FormDescription>
                            <FormMessage />
                          </FormItem>
                        )}
                      />
                      
                      <FormField
                        control={registerFormMethods.control}
                        name="password"
                        render={({ field }) => (
                          <FormItem>
                            <FormLabel>Password</FormLabel>
                            <FormControl>
                              <Input 
                                type="password" 
                                placeholder="Create a password"
                                {...field}
                                disabled={registerMutation.isPending}
                              />
                            </FormControl>
                            <FormMessage />
                          </FormItem>
                        )}
                      />
                      
                      <FormField
                        control={registerFormMethods.control}
                        name="confirmPassword"
                        render={({ field }) => (
                          <FormItem>
                            <FormLabel>Confirm Password</FormLabel>
                            <FormControl>
                              <Input 
                                type="password" 
                                placeholder="Confirm your password"
                                {...field}
                                disabled={registerMutation.isPending}
                              />
                            </FormControl>
                            <FormMessage />
                          </FormItem>
                        )}
                      />
                      
                      <Button 
                        type="submit" 
                        className="w-full"
                        disabled={registerMutation.isPending}
                      >
                        {registerMutation.isPending ? "Creating account..." : "Register"}
                      </Button>
                    </form>
                  </Form>
                </CardContent>
                <CardFooter className="flex flex-col">
                  <div className="text-sm text-muted-foreground mt-2">
                    Already have an account?{" "}
                    <Button 
                      variant="link" 
                      className="p-0 h-auto" 
                      onClick={() => setActiveTab("login")}
                    >
                      Login
                    </Button>
                  </div>
                </CardFooter>
              </Card>
            </TabsContent>
          </Tabs>
        </div>
        
        {/* Hero Section */}
        <div className="w-full md:w-1/2 bg-gradient-to-br from-primary/90 to-primary/50 rounded-xl p-8 text-primary-foreground flex flex-col justify-center">
          <div>
            <h1 className="text-3xl font-bold mb-4">Welcome to the TV tantrum community</h1>
            <p className="mb-6 text-lg opacity-90">
              Join the revolution to transform the culture of children's TV
            </p>
            <div className="space-y-4">
              <div className="flex items-start gap-2">
                <div className="bg-white/20 rounded-full p-1 mt-1">
                  <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                    <polyline points="20 6 9 17 4 12"></polyline>
                  </svg>
                </div>
                <div>
                  <h3 className="font-medium">Save Your Favorites</h3>
                  <p className="opacity-75 text-sm">Create an account to bookmark and save your favorite shows for quick access later.</p>
                </div>
              </div>
              
              <div className="flex items-start gap-2">
                <div className="bg-white/20 rounded-full p-1 mt-1">
                  <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                    <polyline points="20 6 9 17 4 12"></polyline>
                  </svg>
                </div>
                <div>
                  <h3 className="font-medium">Get Personalized Recommendations</h3>
                  <p className="opacity-75 text-sm">We analyze your preferences to suggest shows that match your child's sensory profile.</p>
                </div>
              </div>
              
              <div className="flex items-start gap-2">
                <div className="bg-white/20 rounded-full p-1 mt-1">
                  <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                    <polyline points="20 6 9 17 4 12"></polyline>
                  </svg>
                </div>
                <div>
                  <h3 className="font-medium">Leave Reviews</h3>
                  <p className="opacity-75 text-sm">Share your experiences and help other parents by rating and reviewing shows you've watched.</p>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="client/src/pages/early-access.tsx">
import { useState, useEffect } from "react";
import { useLocation } from "wouter";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { LoginForm } from "@/components/LoginForm";
import { RegistrationForm } from "@/components/RegistrationForm";
import { useAuth } from "@/hooks/use-auth";

export default function EarlyAccessPage() {
  const [activeTab, setActiveTab] = useState("login");
  const { user } = useAuth();
  const [, setLocation] = useLocation();

  useEffect(() => {
    // If user is already logged in, don't do token check
    if (user) return;
    
    // Check if user has the early access token - redirect to token entry page if not
    const token = localStorage.getItem("earlyAccessToken");
    const expectedToken = "2025";
    
    if (!token || token !== expectedToken) {
      setLocation("/token-entry");
    }
  }, [setLocation, user]);

  // Redirect if user is already logged in
  useEffect(() => {
    if (user) {
      setLocation("/home");
    }
  }, [user, setLocation]);

  return (
    <div className="min-h-screen flex flex-col md:flex-row">
      {/* Left Column - Forms */}
      <div className="w-full md:w-1/2 flex items-center justify-center bg-gray-50 p-4">
        <div className="max-w-md w-full">
          <Card>
            <CardHeader className="space-y-1">
              <CardTitle className="text-2xl text-center font-bold">Early Access</CardTitle>
              <CardDescription className="text-center">
                Welcome to TV Tantrum's exclusive early access. Login or create an account to get started.
              </CardDescription>
            </CardHeader>
            <CardContent>
              <Tabs defaultValue="login" value={activeTab} onValueChange={setActiveTab}>
                <TabsList className="grid w-full grid-cols-2">
                  <TabsTrigger value="login">Login</TabsTrigger>
                  <TabsTrigger value="register">Register</TabsTrigger>
                </TabsList>
                <TabsContent value="login">
                  <LoginForm onSuccess={() => setLocation("/home")} />
                  <div className="mt-4 text-center text-sm">
                    <span className="text-muted-foreground">Don't have an account?</span>{" "}
                    <button 
                      className="text-primary hover:underline"
                      onClick={() => setActiveTab("register")}
                    >
                      Register here
                    </button>
                  </div>
                </TabsContent>
                <TabsContent value="register">
                  <RegistrationForm onSuccess={() => setLocation("/registration-pending")} />
                  <div className="mt-4 text-center text-sm">
                    <span className="text-muted-foreground">Already have an account?</span>{" "}
                    <button 
                      className="text-primary hover:underline"
                      onClick={() => setActiveTab("login")}
                    >
                      Login here
                    </button>
                  </div>
                </TabsContent>
              </Tabs>
            </CardContent>
          </Card>
          <div className="mt-4 text-center">
            <button 
              className="text-sm text-muted-foreground hover:underline"
              onClick={() => {
                localStorage.removeItem("earlyAccessToken");
                setLocation("/token-entry");
              }}
            >
              ← Back to token entry
            </button>
          </div>
        </div>
      </div>

      {/* Right Column - Hero Image & Info */}
      <div className="w-full md:w-1/2 bg-primary p-8 flex items-center justify-center">
        <div className="max-w-md text-white">
          <h1 className="text-3xl md:text-4xl font-bold mb-6">
            Making Children's TV Viewing a Better Experience
          </h1>
          <p className="text-lg mb-6">
            TV Tantrum helps parents navigate children's media by providing detailed sensory scores and 
            comparative analytics of popular shows.
          </p>
          <div className="space-y-4">
            <div className="flex items-start">
              <div className="bg-white/20 rounded-full p-1 mr-3 mt-1">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                  <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path>
                  <polyline points="22 4 12 14.01 9 11.01"></polyline>
                </svg>
              </div>
              <div>
                <h3 className="font-semibold">Sensory Impact Analysis</h3>
                <p className="text-sm text-white/80">Understand the stimulation level of each show</p>
              </div>
            </div>
            <div className="flex items-start">
              <div className="bg-white/20 rounded-full p-1 mr-3 mt-1">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                  <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path>
                  <polyline points="22 4 12 14.01 9 11.01"></polyline>
                </svg>
              </div>
              <div>
                <h3 className="font-semibold">Age-Appropriate Filtering</h3>
                <p className="text-sm text-white/80">Find shows that match your child's developmental stage</p>
              </div>
            </div>
            <div className="flex items-start">
              <div className="bg-white/20 rounded-full p-1 mr-3 mt-1">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                  <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path>
                  <polyline points="22 4 12 14.01 9 11.01"></polyline>
                </svg>
              </div>
              <div>
                <h3 className="font-semibold">Compare Shows</h3>
                <p className="text-sm text-white/80">Direct comparisons to make informed choices</p>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="client/src/pages/landing-page.tsx">
import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";
import { useToast } from "@/hooks/use-toast";
import { Link } from "wouter";
import { useEffect } from "react";
import GhlScriptLoader from "@/components/GhlScriptLoader";
// Import the preview image to ensure it's properly bundled
import previewImage from "../assets/tv-tantrum-preview.png";

export default function LandingPage() {
  const { toast } = useToast();
  
  // Clear authentication data whenever landing page loads
  useEffect(() => {
    // This will ensure no authentication check happens when on the landing page
    localStorage.removeItem("tvtantrum_auth");
    
    // Keep early access token for future use (but not auth data)
    if (!localStorage.getItem("earlyAccessToken")) {
      localStorage.removeItem("earlyAccessShown");
    }
    
    console.log("Landing page loaded, cleared authentication data from localStorage");
  }, []);

  return (
    <div className="min-h-screen bg-gradient-to-b from-background to-muted">
      <GhlScriptLoader />
      {/* Header */}
      <header className="container mx-auto py-6 px-4 sm:px-6 flex justify-between items-center">
        <Link href="/">
          <div className="text-3xl font-bold text-primary cursor-pointer">TV Tantrum</div>
        </Link>
        <div className="flex space-x-2 sm:space-x-4">
          <Button variant="ghost" asChild>
            <Link href="/about">About</Link>
          </Button>
          <Button variant="ghost" asChild>
            <Link href="/faq">FAQ</Link>
          </Button>
          <Button variant="outline" className="text-primary border-primary hover:bg-primary/10" asChild>
            <Link href="/token-entry">Early Access</Link>
          </Button>
        </div>
      </header>

      {/* Hero Section */}
      <section className="container mx-auto py-20 px-4 sm:px-6 grid grid-cols-1 lg:grid-cols-2 gap-12 items-center">
        <div>
          <h1 className="text-4xl md:text-5xl lg:text-6xl font-bold leading-tight">
            <span className="text-primary">Discover</span> children's TV shows based on sensory impact
          </h1>
          <p className="mt-6 text-lg text-muted-foreground max-w-md">
            TV Tantrum helps parents understand how stimulating different TV shows are, 
            so you can make informed choices about what your children watch.
          </p>
          
          <div className="mt-6 flex justify-start">
            <Button className="text-lg px-8 py-6" size="lg">
              <a href="#register">Join the Waitlist</a>
            </Button>
          </div>
          
          <p className="mt-4 text-lg text-primary font-medium">
            Sign up now to secure early access!
          </p>
        </div>
        
        <div className="relative">
          <Card className="bg-card/50 backdrop-blur shadow-xl transform rotate-1">
            <CardContent className="p-6">
              <img 
                src={previewImage} 
                alt="TV Tantrum Preview" 
                className="rounded-lg shadow-md w-full"
                onError={(e) => {
                  e.currentTarget.src = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='600' height='400' viewBox='0 0 600 400'%3E%3Crect width='600' height='400' fill='%23F1F5F9' /%3E%3Cg fill='%2364748b'%3E%3Ctext x='300' y='180' font-family='Arial, sans-serif' font-size='24' text-anchor='middle'%3ETV Tantrum Preview%3C/text%3E%3Ctext x='300' y='220' font-family='Arial, sans-serif' font-size='16' text-anchor='middle'%3EComing Soon%3C/text%3E%3C/g%3E%3C/svg%3E";
                }}
              />
            </CardContent>
          </Card>
          <div className="absolute -bottom-4 -right-4 bg-primary text-primary-foreground px-4 py-2 rounded-full shadow-lg transform rotate-3">
            Coming Soon!
          </div>
        </div>
      </section>

      {/* Features Section */}
      <section className="container mx-auto py-16 px-4 sm:px-6 text-center">
        <h2 className="text-3xl font-bold mb-12">Why Parents Choose TV Tantrum</h2>
        
        <div className="grid grid-cols-1 md:grid-cols-3 gap-8">
          <div className="p-6 bg-card rounded-xl shadow-sm hover:shadow-md transition-shadow">
            <div className="w-12 h-12 bg-primary/10 text-primary rounded-full flex items-center justify-center mx-auto mb-4">
              <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M9.5 2A2.5 2.5 0 0 1 12 4.5v15a2.5 2.5 0 0 1-4.96.44 2.5 2.5 0 0 1-2.96-3.08 3 3 0 0 1-.34-5.58 2.5 2.5 0 0 1 1.32-4.24 2.5 2.5 0 0 1 4.44-4.04Z"/><path d="M14.5 2A2.5 2.5 0 0 0 12 4.5v15a2.5 2.5 0 0 0 4.96.44 2.5 2.5 0 0 0 2.96-3.08 3 3 0 0 0 .34-5.58 2.5 2.5 0 0 0-1.32-4.24 2.5 2.5 0 0 0-4.44-4.04Z"/></svg>
            </div>
            <h3 className="text-xl font-medium mb-2">Sensory Impact Analysis</h3>
            <p className="text-muted-foreground">Understand exactly how stimulating each show is based on detailed sensory metrics.</p>
          </div>
          
          <div className="p-6 bg-card rounded-xl shadow-sm hover:shadow-md transition-shadow">
            <div className="w-12 h-12 bg-primary/10 text-primary rounded-full flex items-center justify-center mx-auto mb-4">
              <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><path d="M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20"/><path d="M2 12h20"/></svg>
            </div>
            <h3 className="text-xl font-medium mb-2">Personalized Recommendations</h3>
            <p className="text-muted-foreground">Discover shows that match your child's sensory preferences and developmental stage.</p>
          </div>
          
          <div className="p-6 bg-card rounded-xl shadow-sm hover:shadow-md transition-shadow">
            <div className="w-12 h-12 bg-primary/10 text-primary rounded-full flex items-center justify-center mx-auto mb-4">
              <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><path d="m9 12 2 2 4-4"/></svg>
            </div>
            <h3 className="text-xl font-medium mb-2">Parent Reviews</h3>
            <p className="text-muted-foreground">Read what other parents have to say about each show's impact on their children.</p>
          </div>
        </div>
      </section>

      {/* Registration Form */}
      <section id="register" className="container mx-auto py-16 px-4 sm:px-6">
        <div className="max-w-3xl mx-auto bg-card rounded-xl shadow-lg overflow-hidden">
          <div className="p-8">
            <h2 className="text-3xl font-bold mb-6 text-center">Join the Waitlist</h2>
            <p className="text-center text-muted-foreground mb-6">
              Be the first to know when TV Tantrum launches. Get early access and exclusive updates!
            </p>
            
            <div className="h-[500px]">
              <iframe
                src="https://api.leadconnectorhq.com/widget/form/8RE4HTUpZosOwqlmcA6g"
                style={{ width: "100%", height: "100%", border: "none", borderRadius: "3px" }}
                id="inline-8RE4HTUpZosOwqlmcA6g" 
                data-layout={`{'id':'INLINE'}`}
                data-trigger-type="alwaysShow"
                data-trigger-value=""
                data-activation-type="alwaysActivated"
                data-activation-value=""
                data-deactivation-type="neverDeactivate"
                data-deactivation-value=""
                data-form-name="TV Tantrum Pre-reg"
                data-height="492"
                data-layout-iframe-id="inline-8RE4HTUpZosOwqlmcA6g"
                data-form-id="8RE4HTUpZosOwqlmcA6g"
                title="TV Tantrum Pre-reg"
              />
              <script src="https://link.msgsndr.com/js/form_embed.js" async></script>
            </div>
            
            <p className="text-center text-primary font-medium mt-4">
              Only pre-registered users will be invited to use the platform before public launch!
            </p>
            <p className="text-center text-muted-foreground text-sm mt-2">
              Already have an early access token? <Link href="/token-entry" className="text-primary hover:underline">Click here</Link>
            </p>
          </div>
        </div>
      </section>

      {/* Simple Copyright Footer */}
      <div className="container mx-auto py-8 px-4 sm:px-6 text-center text-muted-foreground">
        <p>© {new Date().getFullYear()} TV Tantrum. All rights reserved.</p>
      </div>
    </div>
  );
}
</file>

<file path="client/src/pages/not-found.tsx">
import { Card, CardContent } from "@/components/ui/card";
import { AlertCircle } from "lucide-react";

export default function NotFound() {
  return (
    <div className="min-h-screen w-full flex items-center justify-center bg-gray-50">
      <Card className="w-full max-w-md mx-4">
        <CardContent className="pt-6">
          <div className="flex mb-4 gap-2">
            <AlertCircle className="h-8 w-8 text-red-500" />
            <h1 className="text-2xl font-bold text-gray-900">404 Page Not Found</h1>
          </div>

          <p className="mt-4 text-sm text-gray-600">
            Did you forget to add the page to the router?
          </p>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="client/src/pages/pre-launch-about.tsx">
import { Button } from "@/components/ui/button";
import { Link } from "wouter";
import { useEffect } from "react";

export default function PreLaunchAbout() {
  // Clear authentication data whenever about page loads
  useEffect(() => {
    // This will ensure no authentication check happens
    localStorage.removeItem("tvtantrum_auth");
    
    // Keep early access token for future use (but not auth data)
    if (!localStorage.getItem("earlyAccessToken")) {
      localStorage.removeItem("earlyAccessShown");
    }
    
    console.log("Pre-launch about page loaded, cleared authentication data from localStorage");
  }, []);
  return (
    <div className="min-h-screen bg-gradient-to-b from-background to-muted">
      {/* Header */}
      <header className="container mx-auto py-6 px-4 sm:px-6 flex justify-between items-center">
        <Link href="/">
          <div className="text-3xl font-bold text-primary cursor-pointer">TV Tantrum</div>
        </Link>
        <div className="flex space-x-2 sm:space-x-4">
          <Button variant="ghost" asChild>
            <Link href="/">Home</Link>
          </Button>
          <Button variant="ghost" asChild>
            <Link href="/faq">FAQ</Link>
          </Button>
          <Button variant="outline" className="text-primary border-primary hover:bg-primary/10" asChild>
            <Link href="/token-entry">Early Access</Link>
          </Button>
        </div>
      </header>

      {/* Main Content */}
      <div className="container mx-auto py-12 px-4 max-w-4xl">
        <h1 className="text-4xl font-bold mb-8 text-center">About TV Tantrum</h1>
        
        <div className="prose prose-lg max-w-none">
          <h2 className="text-2xl font-semibold mt-8 mb-4">Our Mission</h2>
          <p>
            TV Tantrum was created with a simple mission: to help parents and caregivers 
            make informed decisions about the children's TV shows their little ones watch. 
            We believe that understanding the sensory and developmental impact of media is 
            crucial for creating a balanced and healthy viewing experience.
          </p>
          
          <h2 className="text-2xl font-semibold mt-8 mb-4">What Makes Us Different</h2>
          <p>
            Unlike traditional content rating systems that focus primarily on age-appropriateness 
            and content warnings, TV Tantrum analyzes shows based on their sensory impact - 
            elements like animation style, scene frequency, music tempo, dialogue intensity, 
            and overall stimulation level. These factors can significantly affect how children 
            process and respond to media.
          </p>

          <div className="bg-primary/10 p-6 rounded-lg my-8">
            <h3 className="text-xl font-medium mb-2">Our Comprehensive Analysis Includes:</h3>
            <ul className="mt-4 space-y-2">
              <li><strong>Stimulation Score:</strong> An overall rating of how stimulating a show is</li>
              <li><strong>Sensory Metrics:</strong> Detailed breakdowns of visual pacing, sound effects, and music</li>
              <li><strong>Thematic Analysis:</strong> Identification of educational themes and values</li>
              <li><strong>Age-Range Guidance:</strong> Developmentally appropriate age recommendations</li>
              <li><strong>Parent Reviews:</strong> Real feedback from other caregivers</li>
            </ul>
          </div>

          <h2 className="text-2xl font-semibold mt-8 mb-4">Our Story</h2>
          <p>
            TV Tantrum began when a group of parents, child development specialists, and media 
            experts came together with a shared concern: the lack of detailed information about 
            how children's shows affect developing minds. After countless hours of research, 
            analysis, and testing with real families, we built a platform that gives parents 
            the insights they need to make media choices aligned with their child's unique 
            sensory profile.
          </p>
          
          <h2 className="text-2xl font-semibold mt-8 mb-4">Join Our Community</h2>
          <p>
            We're building a community of thoughtful parents and caregivers who care deeply 
            about the media their children consume. By joining our pre-launch list, you'll be 
            the first to access our full platform when it launches, and you'll help shape the 
            future of how families interact with children's media.
          </p>
        </div>

        <div className="mt-12 text-center">
          <Button size="lg" className="px-8 py-6 text-lg" asChild>
            <Link href="/#register">Join the Waitlist</Link>
          </Button>
        </div>
      </div>

      {/* Footer */}
      <footer className="bg-muted py-12 mt-20">
        <div className="container mx-auto px-4">
          <div className="text-center text-muted-foreground">
            <p>© {new Date().getFullYear()} TV Tantrum. All rights reserved.</p>
            <p className="mt-2">Helping parents make informed choices about children's media.</p>
          </div>
        </div>
      </footer>
    </div>
  );
}
</file>

<file path="client/src/pages/pre-launch-faq.tsx">
import { Button } from "@/components/ui/button";
import { Link } from "wouter";
import { useEffect } from "react";
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "@/components/ui/accordion";

export default function PreLaunchFAQ() {
  // Clear authentication data whenever FAQ page loads
  useEffect(() => {
    // This will ensure no authentication check happens
    localStorage.removeItem("tvtantrum_auth");
    
    // Keep early access token for future use (but not auth data)
    if (!localStorage.getItem("earlyAccessToken")) {
      localStorage.removeItem("earlyAccessShown");
    }
    
    console.log("Pre-launch FAQ page loaded, cleared authentication data from localStorage");
  }, []);
  return (
    <div className="min-h-screen bg-gradient-to-b from-background to-muted">
      {/* Header */}
      <header className="container mx-auto py-6 px-4 sm:px-6 flex justify-between items-center">
        <Link href="/">
          <div className="text-3xl font-bold text-primary cursor-pointer">TV Tantrum</div>
        </Link>
        <div className="flex space-x-2 sm:space-x-4">
          <Button variant="ghost" asChild>
            <Link href="/">Home</Link>
          </Button>
          <Button variant="ghost" asChild>
            <Link href="/about">About</Link>
          </Button>
          <Button variant="outline" className="text-primary border-primary hover:bg-primary/10" asChild>
            <Link href="/token-entry">Early Access</Link>
          </Button>
        </div>
      </header>

      {/* Main Content */}
      <div className="container mx-auto py-12 px-4 max-w-3xl">
        <h1 className="text-4xl font-bold mb-8 text-center">Frequently Asked Questions</h1>
        
        <Accordion type="single" collapsible className="w-full">
          <AccordionItem value="item-1">
            <AccordionTrigger className="text-xl font-medium">
              What is TV Tantrum?
            </AccordionTrigger>
            <AccordionContent className="text-lg">
              TV Tantrum is a platform that analyzes children's TV shows based on their sensory impact. 
              We provide detailed information about elements like animation style, scene frequency, music tempo, 
              dialogue intensity, and overall stimulation level to help parents make informed decisions about 
              what their children watch.
            </AccordionContent>
          </AccordionItem>
          
          <AccordionItem value="item-2">
            <AccordionTrigger className="text-xl font-medium">
              When will TV Tantrum launch?
            </AccordionTrigger>
            <AccordionContent className="text-lg">
              We're currently in the final stages of development and plan to launch in the coming weeks. 
              Join our waitlist now to qualify for early access to the platform before the public launch. 
              Only users who pre-register will be able to access TV Tantrum during the early access period.
            </AccordionContent>
          </AccordionItem>

          <AccordionItem value="item-3">
            <AccordionTrigger className="text-xl font-medium">
              What is a "stimulation score"?
            </AccordionTrigger>
            <AccordionContent className="text-lg">
              A stimulation score is our proprietary rating that measures how stimulating a show is for a child's 
              developing brain. Shows with higher scores contain more fast-paced scenes, louder sound effects, 
              and more intense visual elements. This score helps parents find content that matches their child's 
              sensory preferences and needs.
            </AccordionContent>
          </AccordionItem>
          
          <AccordionItem value="item-4">
            <AccordionTrigger className="text-xl font-medium">
              How many shows does TV Tantrum analyze?
            </AccordionTrigger>
            <AccordionContent className="text-lg">
              At launch, we'll have detailed analyses of over 300 popular children's shows, with new shows 
              being added regularly. We prioritize shows based on popularity and user requests.
            </AccordionContent>
          </AccordionItem>
          
          <AccordionItem value="item-5">
            <AccordionTrigger className="text-xl font-medium">
              Will TV Tantrum be free to use?
            </AccordionTrigger>
            <AccordionContent className="text-lg">
              Yes! TV Tantrum will be completely free to use. All features, including detailed show analyses, 
              filtering tools, and personalized recommendations will be available to everyone at no cost. 
              We believe that all parents should have access to this important information regardless of 
              their financial situation.
            </AccordionContent>
          </AccordionItem>
          
          <AccordionItem value="item-6">
            <AccordionTrigger className="text-xl font-medium">
              How do I suggest a show to be analyzed?
            </AccordionTrigger>
            <AccordionContent className="text-lg">
              Once we launch, registered users will be able to suggest shows for analysis by using a simple 
              request form directly on our website. Our content team reviews all suggestions and prioritizes 
              new additions based on popularity and educational value.
            </AccordionContent>
          </AccordionItem>
          
          <AccordionItem value="item-7">
            <AccordionTrigger className="text-xl font-medium">
              What age ranges does TV Tantrum cover?
            </AccordionTrigger>
            <AccordionContent className="text-lg">
              We analyze shows suitable for children from ages 0-13+, with particular focus on the crucial 
              developmental stages from toddlerhood through elementary school years.
            </AccordionContent>
          </AccordionItem>
        </Accordion>

        <div className="mt-12 text-center">
          <Button size="lg" className="px-8 py-6 text-lg" asChild>
            <Link href="/#register">Join the Waitlist</Link>
          </Button>
        </div>
      </div>

      {/* Footer */}
      <footer className="bg-muted py-12 mt-20">
        <div className="container mx-auto px-4">
          <div className="text-center text-muted-foreground">
            <p>© {new Date().getFullYear()} TV Tantrum. All rights reserved.</p>
            <p className="mt-2">Have another question? Email us at support@tvtantrum.com</p>
          </div>
        </div>
      </footer>
    </div>
  );
}
</file>

<file path="client/src/pages/registration-pending.tsx">
import { useEffect } from "react";
import { useLocation } from "wouter";
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Link } from "wouter";
import { useAuth } from "@/hooks/use-auth";
import { useToast } from "@/hooks/use-toast";

export default function RegistrationPendingPage() {
  const { logoutMutation } = useAuth();
  const { toast } = useToast();
  const [, navigate] = useLocation();
  
  // Set early access token in localStorage when this page loads
  useEffect(() => {
    console.log("Registration pending page loaded, setting earlyAccessShown in localStorage");
    localStorage.setItem("earlyAccessShown", "true");
  }, []);
  
  // Function to handle logout and redirect to early access login page
  const handleLogoutAndRedirect = (e: React.MouseEvent) => {
    e.preventDefault();
    
    try {
      // First, make sure the early access token is set in localStorage
      localStorage.setItem("earlyAccessToken", "2025");
      localStorage.setItem("earlyAccessShown", "true");
      
      // Clean up any user data in localStorage
      localStorage.removeItem("tvtantrum_auth");
      
      // Use direct window.location.href to force a full page reload
      // This ensures all React Query state is cleared and no "checking authentication" screen
      window.location.href = "/early-access";
      
      toast({
        title: "Success",
        description: "Redirecting you to the login page...",
      });
    } catch (error) {
      console.error("Error during redirect:", error);
      toast({
        title: "Error",
        description: "There was an error redirecting you. Please try again.",
        variant: "destructive",
      });
    }
  };
  return (
    <div className="flex items-center justify-center min-h-screen bg-gradient-to-b from-background to-muted">
      <Card className="w-full max-w-md">
        <CardHeader>
          <CardTitle className="text-2xl text-center">Registration Pending</CardTitle>
          <CardDescription className="text-center">
            Your account has been created but requires admin approval.
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-5 text-center">
          <div className="bg-primary/10 rounded-lg p-6 text-primary border border-primary/20">
            <p className="font-medium mb-2">Thank you for registering!</p>
            <p>
              Your TV Tantrum account has been created successfully and is now pending approval by our administrators.
            </p>
          </div>
          
          <div className="space-y-3">
            <h3 className="font-medium">What happens next:</h3>
            <ul className="space-y-2 text-left list-disc pl-6">
              <li>Our team will review your registration request</li>
              <li>You'll receive an email notification once your account is approved</li>
              <li>After approval, you can log in with your credentials</li>
              <li>You'll have full access to all TV Tantrum features during our early access period</li>
            </ul>
          </div>
          
          <div className="bg-muted p-4 rounded-md text-muted-foreground text-sm">
            <p>
              Early access users help us improve TV Tantrum before our public launch. Your feedback will be invaluable!
            </p>
          </div>
        </CardContent>
        <CardFooter className="flex flex-col space-y-3">
          <div className="flex flex-col gap-3 w-full">
            <Button 
              variant="default" 
              className="w-full"
              onClick={(e) => {
                e.preventDefault();
                // Clear auth data from localStorage
                localStorage.removeItem("tvtantrum_auth");
                // Direct navigation to home page
                window.location.href = "/";
              }}
            >
              Return to Home
            </Button>
            <Button 
              variant="outline" 
              className="w-full"
              onClick={handleLogoutAndRedirect}
            >
              Return to Login
            </Button>
          </div>
          <p className="text-sm text-muted-foreground text-center">
            Have questions? Email us at <span className="text-primary font-medium">support@tvtantrum.com</span>
          </p>
        </CardFooter>
      </Card>
    </div>
  );
}
</file>

<file path="client/src/pages/research-detail.tsx">
import React, { useState, useEffect } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { Link, useParams } from 'wouter';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';
import { Skeleton } from '@/components/ui/skeleton';
import { Badge } from '@/components/ui/badge';
import { Separator } from '@/components/ui/separator';
import { useToast } from '@/hooks/use-toast';
import { useAuth } from '@/hooks/use-auth';
import { ArrowLeft, BookOpen, Calendar, ExternalLink, FileText, Award } from 'lucide-react';

interface ResearchDetailProps {
  id: number;
}

const ResearchDetail = ({ id }: ResearchDetailProps) => {
  const { user, isLoading: isLoadingAuth } = useAuth();
  const { toast } = useToast();
  const queryClient = useQueryClient();
  const [research, setResearch] = useState<any>(null);
  const [isLoading, setIsLoading] = useState(true);
  
  // Direct fetch approach with proper authentication
  useEffect(() => {
    async function fetchResearch() {
      if (!id) return;
      
      try {
        setIsLoading(true);
        const response = await fetch(`/api/research/${id}`, {
          credentials: 'include'
        });
        
        if (!response.ok) {
          throw new Error('Failed to fetch research');
        }
        
        const data = await response.json();
        setResearch(data);
      } catch (error) {
        console.error('Error fetching research:', error);
      } finally {
        setIsLoading(false);
      }
    }
    
    fetchResearch();
  }, [id]);

  const markAsReadMutation = useMutation({
    mutationFn: async () => {
      const response = await fetch(`/api/research/${id}/mark-read`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'include',
      });
      
      if (!response.ok) {
        throw new Error('Failed to mark research as read');
      }
      
      return response.json();
    },
    onSuccess: (data) => {
      // Update the local research state to show it's been read
      if (research) {
        setResearch({
          ...research,
          hasRead: true
        });
      }
      
      // Show success toast
      toast({
        title: "Research marked as read",
        description: "You've earned 5 points!",
        variant: "default",
      });
      
      // Invalidate queries to update UI across the app
      queryClient.invalidateQueries({ queryKey: [`/api/research/${id}`] });
      queryClient.invalidateQueries({ queryKey: ['/api/research'] });
      queryClient.invalidateQueries({ queryKey: ['/api/user/dashboard'] });
    },
    onError: () => {
      toast({
        title: "Error",
        description: "Failed to mark research as read. Please try again.",
        variant: "destructive",
      });
    }
  });

  // Format date for display
  const formatDate = (dateString: string) => {
    if (!dateString) return '';
    const date = new Date(dateString);
    return new Intl.DateTimeFormat('en-US', { 
      year: 'numeric', 
      month: 'long', 
      day: 'numeric' 
    }).format(date);
  };

  // Format category name for display
  const formatCategoryName = (category: string) => {
    if (!category) return 'General';
    return category.split(' ').map(word => 
      word.charAt(0).toUpperCase() + word.slice(1)
    ).join(' ');
  };

  // Skip auth loading check for faster rendering
  // We'll show sign in prompt only after confirmed no user is present

  if (isLoading) {
    return (
      <div className="container max-w-[1100px] py-8 px-6 md:px-8">
        <div className="space-y-4">
          <div className="flex items-center gap-2">
            <Skeleton className="h-8 w-8" />
            <Skeleton className="h-8 w-[150px]" />
          </div>
          <Skeleton className="h-10 w-[300px]" />
          <div className="flex gap-2 my-4">
            <Skeleton className="h-6 w-[100px]" />
            <Skeleton className="h-6 w-[100px]" />
          </div>
          <Skeleton className="h-[400px] w-full" />
          <Skeleton className="h-10 w-[150px]" />
        </div>
      </div>
    );
  }

  if (!research) {
    return (
      <div className="container py-8">
        <div className="flex items-center gap-2 mb-4">
          <Button variant="ghost" size="sm" asChild>
            <Link href="/research">
              <ArrowLeft className="w-4 h-4 mr-2" />
              Back to Research
            </Link>
          </Button>
        </div>
        <Card className="max-w-md mx-auto text-center">
          <CardHeader>
            <CardTitle>Research Not Found</CardTitle>
            <CardDescription>
              The research summary you're looking for doesn't exist or has been removed.
            </CardDescription>
          </CardHeader>
          <CardFooter className="flex justify-center">
            <Button asChild>
              <Link href="/research">Browse All Research</Link>
            </Button>
          </CardFooter>
        </Card>
      </div>
    );
  }

  const handleMarkAsRead = () => {
    if (!research.hasRead) {
      markAsReadMutation.mutate();
    }
  };

  // Handle authentication checks after all hooks are called
  if (isLoadingAuth) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="text-center">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto"></div>
          <p className="mt-2 text-gray-600">Loading...</p>
        </div>
      </div>
    );
  }
  
  if (!user) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="text-center">
          <h2 className="text-xl font-semibold mb-2">Authentication Required</h2>
          <p className="text-gray-600 mb-4">Please log in to view research details.</p>
          <button 
            onClick={() => window.location.href = '/early-access'}
            className="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700"
          >
            Go to Login
          </button>
        </div>
      </div>
    );
  }

  return (
    <div className="container py-8">
      <div className="flex items-center gap-2 mb-6">
        <Button variant="ghost" size="sm" asChild>
          <Link href="/research">
            <ArrowLeft className="w-4 h-4 mr-2" />
            Back to Research
          </Link>
        </Button>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-12 gap-8">
        <div className="lg:col-span-8 px-4">
          <div className="mb-6">
            {research.category && (
              <Badge variant="outline" className="mb-2">
                {formatCategoryName(research.category)}
              </Badge>
            )}
            <h1 className="text-3xl font-bold mb-3">{research.title}</h1>
            
            <div className="flex flex-wrap items-center gap-4 text-sm text-gray-500 mb-4">
              {research.publishedDate && (
                <div className="flex items-center">
                  <Calendar className="w-4 h-4 mr-2" />
                  <span>{formatDate(research.publishedDate)}</span>
                </div>
              )}
              {research.source && (
                <div className="flex items-center">
                  <FileText className="w-4 h-4 mr-2" />
                  <span>{research.source}</span>
                </div>
              )}
            </div>

            {research.hasRead ? (
              <Badge variant="secondary" className="bg-green-50 text-green-600 border-green-200">
                <BookOpen className="w-3 h-3 mr-1" /> Read
              </Badge>
            ) : (
              <Badge variant="outline" className="bg-blue-50 text-blue-500 border-blue-200">
                <Award className="w-3 h-3 mr-1" /> Earn 5 points by reading
              </Badge>
            )}
          </div>

          <div className="prose prose-p:text-base prose-headings:font-semibold max-w-none">
            {/* Display headline and sub-headline if available */}
            {(research.headline || research.subHeadline) && (
              <div className="mb-8">
                {research.headline && (
                  <h2 className="text-2xl font-bold mb-2">{research.headline}</h2>
                )}
                {research.subHeadline && (
                  <h3 className="text-xl text-gray-700 mb-4">{research.subHeadline}</h3>
                )}
              </div>
            )}
            
            {/* Display summary first */}
            <div className="bg-gray-50 p-6 rounded-lg mb-8 border border-gray-100">
              <h3 className="text-xl font-semibold mb-4">Summary</h3>
              <p>{research.summary}</p>
            </div>
            
            {/* Display key findings if available */}
            {research.keyFindings && (
              <div className="mb-8">
                <h3 className="text-xl font-semibold mb-4">Key Findings</h3>
                <div className="space-y-2">
                  {(() => {
                    // Process key findings with proper spacing
                    const processedFindings = [];
                    const sections = research.keyFindings.split('\n\n');
                    
                    sections.forEach((section, sectionIndex) => {
                      const lines = section.split('\n').filter(line => line.trim() !== '');
                      
                      lines.forEach((line, lineIndex) => {
                        if (lineIndex === 0 && line.includes(':')) {
                          // This is a heading with a colon - create a section with content
                          const [heading, ...content] = lines;
                          const headingText = heading.split(':')[0];
                          const remainingText = heading.split(':').slice(1).join(':').trim();
                          
                          processedFindings.push(
                            <div key={`section-${sectionIndex}`} className="mb-4">
                              <p>
                                <span className="font-bold">{headingText}:</span>
                                {remainingText}
                              </p>
                              {content.map((contentLine, contentIndex) => (
                                <p key={`content-${sectionIndex}-${contentIndex}`} className="mt-1">
                                  {contentLine.includes(':') ? (
                                    <>
                                      <span className="font-bold">{contentLine.split(':')[0]}:</span>
                                      {contentLine.split(':').slice(1).join(':')}
                                    </>
                                  ) : (
                                    contentLine
                                  )}
                                </p>
                              ))}
                            </div>
                          );
                          return;
                        }
                        
                        // Handle standalone lines
                        if (lines.length === 1) {
                          processedFindings.push(
                            <div key={`line-${sectionIndex}`} className="mb-2">
                              <p>
                                {line.includes(':') ? (
                                  <>
                                    <span className="font-bold">{line.split(':')[0]}:</span>
                                    {line.split(':').slice(1).join(':')}
                                  </>
                                ) : (
                                  line
                                )}
                              </p>
                            </div>
                          );
                        }
                      });
                    });
                    
                    return processedFindings;
                  })()}
                </div>
              </div>
            )}

            {/* Display image between Key Findings and Detail sections */}
            {research.imageUrl && (
              <div className="mb-8 rounded-lg overflow-hidden">
                <img
                  src={research.imageUrl}
                  alt={research.title}
                  className="w-full h-auto"
                />
              </div>
            )}

            {/* Display full text if available */}
            {research.fullText && (
              <div className="space-y-6">
                <h3 className="text-xl font-semibold mb-4">Detail</h3>
                {research.fullText.split('\n\n').map((paragraph, index) => (
                  <p key={index}>
                    {paragraph.includes(':') ? (
                      <>
                        <span className="font-bold">{paragraph.split(':')[0]}:</span>
                        {paragraph.split(':').slice(1).join(':')}
                      </>
                    ) : (
                      paragraph
                    )}
                  </p>
                ))}
              </div>
            )}
          </div>
        </div>

        <div className="lg:col-span-4 px-4">
          <div className="sticky top-8">
            <Card>
              <CardHeader>
                <CardTitle className="text-lg">About This Research</CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                {research.source && (
                  <div>
                    <h4 className="text-sm font-medium mb-1">Source</h4>
                    <p className="text-sm text-gray-600">{research.source}</p>
                  </div>
                )}
                
                {research.publishedDate && (
                  <div>
                    <h4 className="text-sm font-medium mb-1">Published</h4>
                    <p className="text-sm text-gray-600">{formatDate(research.publishedDate)}</p>
                  </div>
                )}

                {research.category && (
                  <div>
                    <h4 className="text-sm font-medium mb-1">Category</h4>
                    <p className="text-sm text-gray-600">{formatCategoryName(research.category)}</p>
                  </div>
                )}

                <div>
                  <h4 className="text-sm font-medium mb-1">Original Research</h4>
                  <a 
                    href={research.originalUrl || `https://scholar.google.com/scholar?q=${encodeURIComponent(research.title + " " + (research.source || ""))}`} 
                    target="_blank" 
                    rel="noopener noreferrer"
                    className="text-sm flex items-center text-blue-600 hover:text-blue-800 font-medium"
                  >
                    <ExternalLink className="w-3 h-3 mr-1" /> 
                    Read the full study
                  </a>
                  <p className="text-xs text-gray-500 mt-1">
                    {research.originalUrl ? "Opens original paper" : "Opens in Google Scholar"}
                  </p>
                </div>

                <Separator />

                <div className="pt-2">
                  {research.hasRead ? (
                    <div className="p-3 bg-green-50 text-green-700 rounded-md text-sm">
                      <div className="flex items-center font-medium">
                        <BookOpen className="w-4 h-4 mr-2" />
                        You've read this research
                      </div>
                      <p className="text-green-600 text-xs mt-1">+5 points have been added to your account</p>
                    </div>
                  ) : (
                    <Button 
                      onClick={handleMarkAsRead} 
                      className="w-full"
                      disabled={markAsReadMutation.isPending}
                    >
                      {markAsReadMutation.isPending ? 'Marking as read...' : 'Mark as Read'}
                    </Button>
                  )}
                </div>
              </CardContent>
            </Card>
          </div>
        </div>
      </div>
    </div>
  );
};

export default ResearchDetail;
</file>

<file path="client/src/pages/research-link-updater.tsx">
import React, { useState } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import * as z from "zod";
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card";
import { Separator } from "@/components/ui/separator";
import { toast } from "@/hooks/use-toast";
import { apiRequest } from "@/lib/queryClient";

const linkUpdateSchema = z.object({
  url: z.string().url("Please enter a valid URL"),
});

const ResearchLinkUpdater = () => {
  const [selectedResearch, setSelectedResearch] = useState<number | null>(null);
  const queryClient = useQueryClient();

  const { data: researchList, isLoading: isLoadingResearch } = useQuery({
    queryKey: ["/api/research"],
  });

  const form = useForm({
    resolver: zodResolver(linkUpdateSchema),
    defaultValues: {
      url: "",
    },
  });

  const updateResearchMutation = useMutation({
    mutationFn: async (data: { id: number; url: string }) => {
      return apiRequest(`/api/research/${data.id}/update-link`, {
        method: "POST",
        body: JSON.stringify({ originalUrl: data.url }),
      });
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/research"] });
      toast({
        title: "Link updated",
        description: "The research link has been updated successfully",
      });
      form.reset();
      setSelectedResearch(null);
    },
    onError: (error) => {
      toast({
        title: "Error",
        description: "Failed to update the research link",
        variant: "destructive",
      });
    },
  });

  const onSubmit = (data: z.infer<typeof linkUpdateSchema>) => {
    if (selectedResearch) {
      updateResearchMutation.mutate({ id: selectedResearch, url: data.url });
    }
  };

  const handleSelect = (id: number) => {
    setSelectedResearch(id);
    // Find if research already has a link
    const research = researchList?.find((r: any) => r.id === id);
    if (research?.originalUrl) {
      form.setValue("url", research.originalUrl);
    } else {
      form.reset();
    }
  };

  return (
    <div className="container mx-auto py-8">
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold">Research Link Updater</h1>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-12 gap-8">
        <div className="lg:col-span-8">
          <Card>
            <CardHeader>
              <CardTitle>Research Articles</CardTitle>
              <CardDescription>
                Select a research article to update its original source link
              </CardDescription>
            </CardHeader>
            <CardContent>
              {isLoadingResearch ? (
                <div>Loading research articles...</div>
              ) : (
                <div className="space-y-4">
                  {researchList?.map((research: any) => (
                    <div 
                      key={research.id} 
                      className={`p-4 border rounded-md cursor-pointer ${
                        selectedResearch === research.id 
                          ? "border-blue-500 bg-blue-50" 
                          : "hover:border-gray-400"
                      }`}
                      onClick={() => handleSelect(research.id)}
                    >
                      <div className="font-medium">{research.title}</div>
                      <div className="text-sm text-gray-500 mt-1">{research.category}</div>
                      {research.originalUrl && (
                        <div className="text-xs text-green-600 mt-2">
                          Has link: {research.originalUrl}
                        </div>
                      )}
                    </div>
                  ))}
                </div>
              )}
            </CardContent>
          </Card>
        </div>

        <div className="lg:col-span-4">
          <Card>
            <CardHeader>
              <CardTitle>Update Link</CardTitle>
              <CardDescription>
                {selectedResearch 
                  ? "Enter the original research URL" 
                  : "Select a research article first"}
              </CardDescription>
            </CardHeader>
            <CardContent>
              <Form {...form}>
                <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
                  <FormField
                    control={form.control}
                    name="url"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Original Research URL</FormLabel>
                        <FormControl>
                          <Input 
                            {...field} 
                            placeholder="https://..." 
                            disabled={!selectedResearch}
                          />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />
                  <Button 
                    type="submit" 
                    disabled={!selectedResearch || updateResearchMutation.isPending}
                    className="w-full"
                  >
                    {updateResearchMutation.isPending ? "Updating..." : "Update Link"}
                  </Button>
                </form>
              </Form>
            </CardContent>
          </Card>
        </div>
      </div>
    </div>
  );
};

export default ResearchLinkUpdater;
</file>

<file path="client/src/pages/research-view.tsx">
import React, { useState, useEffect } from 'react';
import { Link, useParams } from 'wouter';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Skeleton } from '@/components/ui/skeleton';
import { Badge } from '@/components/ui/badge';
import { Separator } from '@/components/ui/separator';
import { ArrowLeft, BookOpen, Calendar, FileText, Award } from 'lucide-react';

const ResearchView = () => {
  const { id } = useParams();
  const [research, setResearch] = useState(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    async function fetchResearch() {
      try {
        setIsLoading(true);
        const response = await fetch(`/api/research/${id}`);
        
        if (!response.ok) {
          throw new Error('Failed to fetch research');
        }
        
        const data = await response.json();
        setResearch(data);
      } catch (error) {
        console.error('Error fetching research:', error);
        setError(error.message);
      } finally {
        setIsLoading(false);
      }
    }
    
    fetchResearch();
  }, [id]);

  // Format date for display
  const formatDate = (dateString) => {
    if (!dateString) return '';
    const date = new Date(dateString);
    return new Intl.DateTimeFormat('en-US', { 
      year: 'numeric', 
      month: 'long', 
      day: 'numeric' 
    }).format(date);
  };

  // Format category name for display
  const formatCategoryName = (category) => {
    if (!category) return 'General';
    return category.split(' ').map(word => 
      word.charAt(0).toUpperCase() + word.slice(1)
    ).join(' ');
  };

  if (isLoading) {
    return (
      <div className="container py-8">
        <div className="space-y-4">
          <div className="flex items-center gap-2">
            <Skeleton className="h-8 w-8" />
            <Skeleton className="h-8 w-[150px]" />
          </div>
          <Skeleton className="h-10 w-[300px]" />
          <div className="flex gap-2 my-4">
            <Skeleton className="h-6 w-[100px]" />
            <Skeleton className="h-6 w-[100px]" />
          </div>
          <Skeleton className="h-[400px] w-full" />
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="container py-8">
        <Card className="max-w-md mx-auto text-center">
          <CardHeader>
            <CardTitle>Error Loading Research</CardTitle>
          </CardHeader>
          <CardContent>
            <p className="mb-4">{error}</p>
            <Button asChild>
              <Link href="/research">Back to Research</Link>
            </Button>
          </CardContent>
        </Card>
      </div>
    );
  }

  if (!research) {
    return (
      <div className="container py-8">
        <Card className="max-w-md mx-auto text-center">
          <CardHeader>
            <CardTitle>Research Not Found</CardTitle>
          </CardHeader>
          <CardContent>
            <p className="mb-4">The research summary you're looking for doesn't exist or has been removed.</p>
            <Button asChild>
              <Link href="/research">Browse All Research</Link>
            </Button>
          </CardContent>
        </Card>
      </div>
    );
  }

  return (
    <div className="container py-8">
      <div className="flex items-center gap-2 mb-6">
        <Button variant="ghost" size="sm" asChild>
          <Link href="/research">
            <ArrowLeft className="w-4 h-4 mr-2" />
            Back to Research
          </Link>
        </Button>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-12 gap-8">
        <div className="lg:col-span-8">
          <div className="mb-6">
            {research.category && (
              <Badge variant="outline" className="mb-2">
                {formatCategoryName(research.category)}
              </Badge>
            )}
            <h1 className="text-3xl font-bold mb-3">{research.title}</h1>
            
            <div className="flex flex-wrap items-center gap-4 text-sm text-gray-500 mb-4">
              {research.publishedDate && (
                <div className="flex items-center">
                  <Calendar className="w-4 h-4 mr-2" />
                  <span>{formatDate(research.publishedDate)}</span>
                </div>
              )}
              {research.source && (
                <div className="flex items-center">
                  <FileText className="w-4 h-4 mr-2" />
                  <span>{research.source}</span>
                </div>
              )}
            </div>

            <Badge variant="outline" className="bg-blue-50 text-blue-500 border-blue-200">
              <Award className="w-3 h-3 mr-1" /> Reading research earns points
            </Badge>
          </div>

          {research.imageUrl && (
            <div className="mb-6 rounded-lg overflow-hidden">
              <img
                src={research.imageUrl}
                alt={research.title}
                className="w-full h-auto"
              />
            </div>
          )}

          <div className="prose prose-p:text-base prose-headings:font-semibold max-w-none">
            {/* Display summary first */}
            <div className="bg-gray-50 p-6 rounded-lg mb-8 border border-gray-100">
              <h3 className="text-xl font-semibold mb-4">Summary</h3>
              <p>{research.summary}</p>
            </div>

            {/* Display full text if available */}
            {research.fullText && (
              <div className="space-y-6">
                {research.fullText.split('\n\n').map((paragraph, index) => (
                  <p key={index}>{paragraph}</p>
                ))}
              </div>
            )}
          </div>
        </div>

        <div className="lg:col-span-4">
          <div className="sticky top-8">
            <Card>
              <CardHeader>
                <CardTitle className="text-lg">About This Research</CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                {research.source && (
                  <div>
                    <h4 className="text-sm font-medium mb-1">Source</h4>
                    <p className="text-sm text-gray-600">{research.source}</p>
                  </div>
                )}
                
                {research.publishedDate && (
                  <div>
                    <h4 className="text-sm font-medium mb-1">Published</h4>
                    <p className="text-sm text-gray-600">{formatDate(research.publishedDate)}</p>
                  </div>
                )}

                {research.category && (
                  <div>
                    <h4 className="text-sm font-medium mb-1">Category</h4>
                    <p className="text-sm text-gray-600">{formatCategoryName(research.category)}</p>
                  </div>
                )}

                <Separator />

                <div className="pt-2">
                  <div className="p-3 bg-blue-50 text-blue-700 rounded-md text-sm">
                    <div className="flex items-center font-medium">
                      <BookOpen className="w-4 h-4 mr-2" />
                      Sign in to track your reading
                    </div>
                    <p className="text-blue-600 text-xs mt-1">Earn 5 points for each research summary you read</p>
                  </div>
                </div>
              </CardContent>
            </Card>
          </div>
        </div>
      </div>
    </div>
  );
};

export default ResearchView;
</file>

<file path="client/src/pages/share.tsx">
import { useState, useEffect } from "react";
import { useParams, useLocation } from "wouter";
import { useQuery } from "@tanstack/react-query";
import { Button } from "@/components/ui/button";
import { Skeleton } from "@/components/ui/skeleton";
import { Badge } from "@/components/ui/badge";
import { TvShow } from "@shared/schema";
import { Share2, ExternalLink } from "lucide-react";
import { useAuth } from "@/hooks/use-auth";
import { Card, CardContent } from "@/components/ui/card";

export default function SharePage() {
  const { id } = useParams<{ id: string }>();
  const [_, setLocation] = useLocation();
  const { user } = useAuth();
  const [showId] = useState(parseInt(id || "0"));
  
  // Fetch show details
  const { data: show, isLoading, error } = useQuery<TvShow>({
    queryKey: [`/api/shows/${showId}`],
    enabled: !!showId,
  });

  // Track referral in localStorage if this is the first visit from this share
  useEffect(() => {
    if (show && !localStorage.getItem(`share_visited_${showId}`)) {
      // Mark as visited to prevent duplicate referral tracking
      localStorage.setItem(`share_visited_${showId}`, Date.now().toString());
      
      // Store referral info for registration
      localStorage.setItem('referral_show_id', showId.toString());
      
      // If URL has a referrer param, store it
      const urlParams = new URLSearchParams(window.location.search);
      const referrerId = urlParams.get('ref');
      if (referrerId) {
        localStorage.setItem('referrer_id', referrerId);
      }
    }
  }, [show, showId]);

  // Get stimulation level text
  const getStimulationLevelText = (score: number) => {
    switch (score) {
      case 1: return "Low stimulation shows have a calm pace with minimal scene changes, gentle audio, and simple visuals. These are excellent choices for sensitive viewers or children who need help focusing.";
      case 2: return "Low-Medium stimulation shows feature a relaxed pace with occasional increases in action or audio. These provide a gentle viewing experience while still keeping children engaged.";
      case 3: return "Medium stimulation shows balance engaging content with moderate pacing. These shows have varied scenes and audio that won't overwhelm most viewers.";
      case 4: return "Medium-High stimulation shows contain frequent scene changes, more dramatic audio shifts, and vibrant visuals. These are engaging but may be intense for sensitive viewers.";
      case 5: return "High stimulation shows feature rapid scene changes, loud or dramatic audio, and intense visual elements. These shows are very engaging but may not be suitable for sensitive viewers or before bedtime.";
      default: return "This show's stimulation level helps you understand its intensity in terms of visual pace, audio, and overall sensory input.";
    }
  };
  
  // Get stimulation level color
  const getStimulationLevelColor = (score: number) => {
    switch (score) {
      case 1: return "bg-green-100 text-green-800";
      case 2: return "bg-lime-100 text-lime-800";
      case 3: return "bg-yellow-100 text-yellow-800";
      case 4: return "bg-orange-100 text-orange-800";
      case 5: return "bg-red-100 text-red-800";
      default: return "bg-blue-100 text-blue-800";
    }
  };
  
  // Get stimulation level name
  const getStimulationLevelName = (score: number) => {
    switch (score) {
      case 1: return "Low";
      case 2: return "Low-Medium";
      case 3: return "Medium";
      case 4: return "Medium-High";
      case 5: return "High";
      default: return "Medium";
    }
  };

  // Loading state
  if (isLoading) {
    return (
      <div className="flex min-h-screen flex-col items-center justify-center p-4 bg-gray-50">
        <Card className="w-full max-w-md">
          <CardContent className="p-6">
            <div className="flex flex-col items-center space-y-4">
              <Skeleton className="h-48 w-full rounded-md" />
              <Skeleton className="h-8 w-40" />
              <Skeleton className="h-4 w-full" />
              <Skeleton className="h-4 w-full" />
              <Skeleton className="h-4 w-2/3" />
              <Skeleton className="h-10 w-full" />
            </div>
          </CardContent>
        </Card>
      </div>
    );
  }

  // Error state
  if (error || !show) {
    return (
      <div className="flex min-h-screen flex-col items-center justify-center p-4 bg-gray-50">
        <Card className="w-full max-w-md">
          <CardContent className="p-6">
            <div className="text-center">
              <h2 className="text-xl font-bold text-gray-800 mb-4">Show Not Found</h2>
              <p className="text-gray-600 mb-6">
                We couldn't find the show you're looking for. It may have been removed or the link is invalid.
              </p>
              <Button onClick={() => setLocation("/")}>
                Go to Homepage
              </Button>
            </div>
          </CardContent>
        </Card>
      </div>
    );
  }

  return (
    <div className="flex min-h-screen flex-col items-center justify-center p-4 bg-gray-50">
      <Card className="w-full max-w-md">
        <CardContent className="p-6">
          <div className="flex flex-col space-y-4">
            <div className="flex justify-between items-start">
              <h2 className="text-xl font-bold">{show.name}</h2>
              <div className="flex items-center">
                <Share2 className="h-5 w-5 text-blue-500 mr-1" />
                <span className="text-sm text-blue-500">Shared with you</span>
              </div>
            </div>
            
            {/* Show image */}
            {show.imageUrl ? (
              <div className="flex justify-center">
                <img 
                  src={show.imageUrl} 
                  alt={show.name} 
                  className="h-48 object-contain rounded-md" 
                />
              </div>
            ) : (
              <div className="w-full h-48 bg-gray-200 flex items-center justify-center rounded-md">
                <i className="fas fa-tv text-gray-400 text-4xl"></i>
              </div>
            )}
            
            {/* Stimulation score */}
            <div className="flex flex-col items-center space-y-2">
              <Badge className={`${getStimulationLevelColor(show.stimulationScore)} px-3 py-1 text-sm`}>
                {getStimulationLevelName(show.stimulationScore)} Stimulation
              </Badge>
              
              <div className="h-2 w-full max-w-56 bg-gray-200 rounded-full overflow-hidden flex mt-1">
                {[1, 2, 3, 4, 5].map((segment) => {
                  const color = 
                    segment === 1 ? 'bg-green-500' : 
                    segment === 2 ? 'bg-lime-500' : 
                    segment === 3 ? 'bg-yellow-500' : 
                    segment === 4 ? 'bg-orange-500' : 
                    'bg-red-500';
                  
                  return (
                    <div
                      key={segment}
                      className={`h-full w-1/5 ${segment <= show.stimulationScore ? color : 'bg-gray-200'}`}
                    />
                  );
                })}
              </div>
            </div>
            
            {/* Stimulation description */}
            <p className="text-sm text-gray-600 text-center">
              {getStimulationLevelText(show.stimulationScore)}
            </p>
            
            <div className="border-t border-gray-200 pt-4 mt-2">
              <h3 className="font-medium text-gray-700 mb-2">About TV Tantrum</h3>
              <p className="text-sm text-gray-600 mb-4">
                TV Tantrum helps parents make informed decisions about children's media with
                research-backed ratings and stimulation scores.
              </p>
              
              {user ? (
                // User is logged in, show view details button
                <div className="space-y-2">
                  <Button 
                    className="w-full" 
                    onClick={() => setLocation("/")}
                  >
                    <ExternalLink className="w-4 h-4 mr-2" />
                    Browse More Shows
                  </Button>
                </div>
              ) : (
                // User is not logged in, show sign up and login buttons
                <div className="space-y-2">
                  <Button 
                    className="w-full" 
                    onClick={() => setLocation("/")}
                  >
                    Browse More Shows
                  </Button>
                  <p className="text-xs text-center text-gray-500 mt-1">
                    Already have an account?{" "}
                    <a 
                      className="text-blue-600 hover:underline" 
                      href="#" 
                      onClick={(e) => {
                        e.preventDefault();
                        setLocation("/auth?action=login");
                      }}
                    >
                      Log in
                    </a>
                  </p>
                </div>
              )}
            </div>
          </div>
        </CardContent>
      </Card>
      
      <div className="mt-4 text-center text-xs text-gray-500">
        © 2025 TV Tantrum. All rights reserved.
      </div>
    </div>
  );
}
</file>

<file path="client/src/pages/show-submission.tsx">
import React, { useState } from 'react';
import { useForm } from 'react-hook-form';
import { Link } from 'wouter';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { queryClient } from '@/lib/queryClient';
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';
import { Form, FormControl, FormDescription, FormField, FormItem, FormLabel, FormMessage } from '@/components/ui/form';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Button } from '@/components/ui/button';
import { useToast } from '@/hooks/use-toast';
import { Badge } from '@/components/ui/badge';
import { Lock, Upload, FilePlus2 } from 'lucide-react';
import { useAuth } from '@/hooks/useAuth';

// Form schema with validation rules
const formSchema = z.object({
  name: z.string().min(3, 'Show name must be at least 3 characters').max(100),
  description: z.string().min(20, 'Description must be at least 20 characters'),
  ageRange: z.string().min(1, 'Please select an age range'),
  episodeLength: z.coerce.number().min(1, 'Episode length must be at least 1 minute').max(180, 'Episode length can\'t exceed 180 minutes'),
  platform: z.string().min(1, 'Please enter at least one platform'),
  additionalNotes: z.string().optional(),
});

type FormValues = z.infer<typeof formSchema>;

const ShowSubmission = () => {
  const { user, isLoading: isLoadingAuth } = useAuth();
  const { toast } = useToast();
  // Using navigate function directly
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [imageFile, setImageFile] = useState<File | null>(null);
  const [imagePreview, setImagePreview] = useState<string | null>(null);

  const form = useForm<FormValues>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      name: '',
      description: '',
      ageRange: '',
      episodeLength: 0,
      platform: '',
      additionalNotes: '',
    },
  });

  const handleImageChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0] || null;
    if (file) {
      setImageFile(file);
      
      // Create image preview
      const reader = new FileReader();
      reader.onloadend = () => {
        setImagePreview(reader.result as string);
      };
      reader.readAsDataURL(file);
    }
  };

  const onSubmit = async (data: FormValues) => {
    if (!user) {
      toast({
        title: "Authentication required",
        description: "You must be logged in to submit a show",
        variant: "destructive",
      });
      return;
    }

    setIsSubmitting(true);

    try {
      let imageUrl = null;

      // First upload the image if one was provided
      if (imageFile) {
        const formData = new FormData();
        formData.append('image', imageFile);
        
        const uploadResponse = await fetch('/api/shows/upload-image', {
          method: 'POST',
          body: formData,
          credentials: 'include'
        });
        
        if (uploadResponse.ok) {
          const imageData = await uploadResponse.json();
          imageUrl = imageData.imageUrl;
        } else {
          throw new Error('Failed to upload image');
        }
      }

      // Then submit the show data
      const submitResponse = await fetch('/api/show-submissions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          ...data,
          imageUrl,
        }),
        credentials: 'include'
      });

      if (submitResponse.ok) {
        toast({
          title: "Show submitted successfully!",
          description: "Thank you for your submission. You've earned 15 points!",
        });
        
        // Redirect using window.location instead of wouter navigation
        window.location.href = '/user-dashboard';
      } else {
        throw new Error('Failed to submit show');
      }
    } catch (error) {
      toast({
        title: "Submission failed",
        description: error instanceof Error ? error.message : "An unexpected error occurred",
        variant: "destructive",
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  if (isLoadingAuth) {
    return (
      <div className="container py-8">
        <div className="max-w-3xl mx-auto">
          <div className="animate-pulse space-y-4">
            <div className="h-10 bg-gray-200 rounded w-2/3"></div>
            <div className="h-6 bg-gray-200 rounded w-3/4"></div>
            <div className="h-[400px] bg-gray-200 rounded w-full"></div>
          </div>
        </div>
      </div>
    );
  }

  if (!user) {
    return (
      <div className="container py-12">
        <Card className="max-w-md mx-auto text-center">
          <CardHeader>
            <Lock className="w-12 h-12 mx-auto text-gray-400 mb-2" />
            <CardTitle>Exclusive Feature</CardTitle>
            <CardDescription>
              Show submissions are available only to registered users.
            </CardDescription>
          </CardHeader>
          <CardFooter className="flex justify-center">
            <Button onClick={() => window.location.href = '/api/login'}>Sign In to Access</Button>
          </CardFooter>
        </Card>
      </div>
    );
  }

  return (
    <div className="container py-8">
      <div className="max-w-3xl mx-auto">
        <div className="flex flex-col md:flex-row justify-between items-start md:items-center gap-4 mb-8">
          <div>
            <h1 className="text-3xl font-bold mb-2">Submit a New Show</h1>
            <p className="text-gray-500">
              Help us grow our database by suggesting shows you love
            </p>
          </div>
          <Badge variant="outline" className="bg-orange-50 text-orange-500 border-orange-200">
            <FilePlus2 className="w-3 h-3 mr-1" /> Earn 15 points for each submission
          </Badge>
        </div>

        <Card>
          <CardHeader>
            <CardTitle>Show Information</CardTitle>
            <CardDescription>
              Please provide as much detail as possible about the show you're recommending
            </CardDescription>
          </CardHeader>
          <CardContent>
            <Form {...form}>
              <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                  <div className="md:col-span-2">
                    <FormField
                      control={form.control}
                      name="name"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Show Name*</FormLabel>
                          <FormControl>
                            <Input placeholder="Enter the show's full name" {...field} />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                  </div>

                  <FormField
                    control={form.control}
                    name="ageRange"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Target Age Range*</FormLabel>
                        <Select onValueChange={field.onChange} defaultValue={field.value}>
                          <FormControl>
                            <SelectTrigger>
                              <SelectValue placeholder="Select age range" />
                            </SelectTrigger>
                          </FormControl>
                          <SelectContent>
                            <SelectItem value="0-2">0-2 years (Infant)</SelectItem>
                            <SelectItem value="3-5">3-5 years (Preschool)</SelectItem>
                            <SelectItem value="6-8">6-8 years (Early Elementary)</SelectItem>
                            <SelectItem value="9-12">9-12 years (Late Elementary)</SelectItem>
                            <SelectItem value="13+">13+ years (Teen)</SelectItem>
                            <SelectItem value="All Ages">All Ages</SelectItem>
                          </SelectContent>
                        </Select>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={form.control}
                    name="episodeLength"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Episode Length (minutes)*</FormLabel>
                        <FormControl>
                          <Input type="number" min={1} max={180} {...field} />
                        </FormControl>
                        <FormDescription>
                          Typical episode duration in minutes
                        </FormDescription>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={form.control}
                    name="platform"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Available On*</FormLabel>
                        <FormControl>
                          <Input placeholder="Netflix, YouTube, PBS Kids, etc." {...field} />
                        </FormControl>
                        <FormDescription>
                          Where can this show be watched?
                        </FormDescription>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <div className="md:col-span-2">
                    <FormField
                      control={form.control}
                      name="description"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Description*</FormLabel>
                          <FormControl>
                            <Textarea 
                              placeholder="Provide a detailed description of the show, its themes, characters, and educational value." 
                              className="min-h-[120px]"
                              {...field} 
                            />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                  </div>

                  <div className="md:col-span-2">
                    <FormField
                      control={form.control}
                      name="additionalNotes"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Additional Notes</FormLabel>
                          <FormControl>
                            <Textarea 
                              placeholder="Any additional information you'd like to share about the show" 
                              className="min-h-[80px]"
                              {...field} 
                            />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                  </div>

                  <div className="md:col-span-2">
                    <FormLabel>Show Image</FormLabel>
                    <div className="mt-2 flex items-center gap-4">
                      <div className="shrink-0 h-32 w-32 rounded-md overflow-hidden bg-gray-100 border flex items-center justify-center">
                        {imagePreview ? (
                          <img 
                            src={imagePreview} 
                            alt="Show preview" 
                            className="h-full w-full object-cover"
                          />
                        ) : (
                          <Upload className="h-8 w-8 text-gray-400" />
                        )}
                      </div>
                      <div className="flex-1">
                        <Button
                          type="button"
                          variant="outline"
                          onClick={() => document.getElementById('image-upload')?.click()}
                          className="mb-2"
                        >
                          Select Image
                        </Button>
                        <Input 
                          id="image-upload"
                          type="file" 
                          accept="image/*" 
                          className="hidden"
                          onChange={handleImageChange}
                        />
                        <p className="text-xs text-gray-500">
                          Optional. Upload a poster or promotional image for the show.
                        </p>
                      </div>
                    </div>
                  </div>
                </div>

                <div className="flex justify-end gap-3 pt-4">
                  <Link href="/user-dashboard">
                    <Button
                      type="button"
                      variant="outline"
                    >
                      Cancel
                    </Button>
                  </Link>
                  <Button 
                    type="submit" 
                    disabled={isSubmitting}
                  >
                    {isSubmitting ? 'Submitting...' : 'Submit Show'}
                  </Button>
                </div>
              </form>
            </Form>
          </CardContent>
        </Card>
      </div>
    </div>
  );
};

export default ShowSubmission;
</file>

<file path="client/src/pages/submit-show.tsx">
import { useQuery } from '@tanstack/react-query';
import { ShowSubmissionForm } from '@/components/ShowSubmissionForm';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Clock, CheckCircle, XCircle, Users } from 'lucide-react';
import { format } from 'date-fns';

interface ShowSubmission {
  id: number;
  showName: string;
  whereTheyWatch: string;
  status: 'pending' | 'approved' | 'rejected';
  requestCount: number;
  createdAt: string;
  rejectionReason?: string;
}

export default function SubmitShowPage() {
  const { data: submissions = [], isLoading, error } = useQuery<ShowSubmission[]>({
    queryKey: ['/api/show-submissions/my'],
    queryFn: async () => {
      const res = await fetch('/api/show-submissions/my');
      if (!res.ok) {
        throw new Error('Failed to fetch submissions');
      }
      const data = await res.json();
      return Array.isArray(data) ? data : [];
    },
  });

  const getStatusIcon = (status: string) => {
    switch (status) {
      case 'approved':
        return <CheckCircle className="h-4 w-4 text-green-600" />;
      case 'rejected':
        return <XCircle className="h-4 w-4 text-red-600" />;
      default:
        return <Clock className="h-4 w-4 text-yellow-600" />;
    }
  };

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'approved':
        return 'bg-green-100 text-green-800';
      case 'rejected':
        return 'bg-red-100 text-red-800';
      default:
        return 'bg-yellow-100 text-yellow-800';
    }
  };

  return (
    <div className="container mx-auto px-4 py-8 max-w-4xl">
      <div className="mb-8 text-center">
        <h1 className="text-3xl font-bold text-gray-900 mb-2">
          Suggest a Show
        </h1>
        <p className="text-lg text-gray-600">
          Help us build the world's best database of children's shows
        </p>
      </div>

      <div className="grid md:grid-cols-2 gap-8">
        {/* Submission Form */}
        <div>
          <ShowSubmissionForm />
        </div>

        {/* User's Previous Submissions */}
        <div>
          <Card>
            <CardHeader>
              <CardTitle>Your Submissions</CardTitle>
              <CardDescription>
                Track the status of your show suggestions
              </CardDescription>
            </CardHeader>
            <CardContent>
              {isLoading ? (
                <div className="flex items-center justify-center py-8">
                  <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600" />
                </div>
              ) : submissions.length === 0 ? (
                <div className="text-center py-8 text-gray-500">
                  <p>You haven't submitted any shows yet.</p>
                  <p className="text-sm">Submit your first show to get started!</p>
                </div>
              ) : (
                <div className="space-y-4">
                  {submissions.map((submission) => (
                    <div
                      key={submission.id}
                      className="border rounded-lg p-4 hover:bg-gray-50 transition-colors"
                    >
                      <div className="flex items-start justify-between">
                        <div className="flex-1">
                          <h3 className="font-semibold text-gray-900">
                            {submission.showName}
                          </h3>
                          <p className="text-sm text-gray-600 mt-1">
                            {submission.whereTheyWatch}
                          </p>
                          {submission.status === 'rejected' && submission.rejectionReason && (
                            <div className="mt-2 p-2 bg-red-50 border border-red-200 rounded">
                              <p className="text-xs text-red-700 font-medium">Rejection Reason:</p>
                              <p className="text-xs text-red-600">{submission.rejectionReason}</p>
                            </div>
                          )}
                          <p className="text-xs text-gray-500 mt-2">
                            Submitted {format(new Date(submission.createdAt), 'MMM d, yyyy')}
                          </p>
                        </div>
                        <div className="flex flex-col items-end gap-2">
                          <div className="flex items-center gap-2">
                            {getStatusIcon(submission.status)}
                            <Badge className={getStatusColor(submission.status)}>
                              {submission.status.charAt(0).toUpperCase() + submission.status.slice(1)}
                            </Badge>
                          </div>
                          {submission.requestCount > 1 && (
                            <div className="flex items-center gap-1 text-xs text-gray-500">
                              <Users className="h-3 w-3" />
                              {submission.requestCount} requests
                            </div>
                          )}
                        </div>
                      </div>
                    </div>
                  ))}
                </div>
              )}
            </CardContent>
          </Card>
        </div>
      </div>

      {/* Information Section */}
      <div className="mt-12 grid md:grid-cols-3 gap-6">
        <Card>
          <CardHeader className="text-center">
            <div className="w-12 h-12 bg-blue-100 rounded-full flex items-center justify-center mx-auto mb-2">
              <CheckCircle className="h-6 w-6 text-blue-600" />
            </div>
            <CardTitle className="text-lg">Earn Points</CardTitle>
          </CardHeader>
          <CardContent className="text-center">
            <p className="text-sm text-gray-600">
              Get 20 points when your suggested show is approved and added to our database.
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="text-center">
            <div className="w-12 h-12 bg-green-100 rounded-full flex items-center justify-center mx-auto mb-2">
              <Users className="h-6 w-6 text-green-600" />
            </div>
            <CardTitle className="text-lg">Smart Detection</CardTitle>
          </CardHeader>
          <CardContent className="text-center">
            <p className="text-sm text-gray-600">
              If someone already suggested the same show, we'll increase its priority instead of creating duplicates.
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="text-center">
            <div className="w-12 h-12 bg-purple-100 rounded-full flex items-center justify-center mx-auto mb-2">
              <Clock className="h-6 w-6 text-purple-600" />
            </div>
            <CardTitle className="text-lg">Admin Review</CardTitle>
          </CardHeader>
          <CardContent className="text-center">
            <p className="text-sm text-gray-600">
              Our team reviews all submissions to ensure quality and accuracy before adding them to the database.
            </p>
          </CardContent>
        </Card>
      </div>
    </div>
  );
}
</file>

<file path="client/src/pages/user-profile.tsx">
import { useQuery } from '@tanstack/react-query';
import { useParams } from 'wouter';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Star, Calendar, Trophy, Book } from 'lucide-react';
import { getCurrentBadge } from '@/lib/badges';

function formatActivityType(type: string): string {
  switch (type) {
    case 'review':
      return 'Review';
    case 'login_reward':
      return 'Login Reward';
    case 'upvote_given':
      return 'Upvote Given';
    case 'upvote_received':
      return 'Upvote Received';
    case 'share':
      return 'Share';
    case 'referral':
      return 'Referral';
    case 'show_submission':
      return 'Show Submission';
    case 'research_read':
      return 'Research Read';
    default:
      return type.charAt(0).toUpperCase() + type.slice(1);
  }
}

export default function UserProfile() {
  const { userId } = useParams();

  const { data: profileData, isLoading } = useQuery({
    queryKey: [`/api/user/profile/${userId}`],
    enabled: !!userId,
  });

  if (isLoading) {
    return (
      <div className="container max-w-4xl py-8">
        <div className="text-center mb-6">
          <h2 className="text-2xl font-bold mb-2">Loading user profile...</h2>
        </div>
      </div>
    );
  }

  if (!profileData) {
    return (
      <div className="container max-w-4xl py-8">
        <div className="text-center mb-6">
          <h2 className="text-2xl font-bold mb-2">User not found</h2>
          <p className="text-muted-foreground">This user profile doesn't exist or has been removed.</p>
        </div>
      </div>
    );
  }

  const user = profileData.user || {};
  const totalPoints = Number(profileData.points?.total) || 0;
  const reviews = Array.isArray(profileData.reviews) ? profileData.reviews : [];
  const favorites = Array.isArray(profileData.favorites) ? profileData.favorites : [];
  const recentActivity = Array.isArray(profileData.pointsHistory) ? profileData.pointsHistory : [];

  // Get current badge based on points
  const currentBadge = getCurrentBadge(totalPoints);

  // Get user's background color preference and convert to hex
  const getHexColor = (color: string) => {
    const colorMap: { [key: string]: string } = {
      'bg-red-500': '#ef4444',
      'bg-orange-500': '#f97316',
      'bg-yellow-500': '#eab308',
      'bg-green-500': '#22c55e',
      'bg-blue-500': '#3b82f6',
      'bg-purple-500': '#a855f7',
      'bg-pink-500': '#ec4899',
      'bg-indigo-500': '#6366f1',
      'bg-cyan-500': '#06b6d4',
      'bg-teal-500': '#14b8a6',
      'bg-lime-500': '#84cc16',
      'bg-amber-500': '#f59e0b'
    };
    return colorMap[color] || color || '#a855f7';
  };
  
  const userBackgroundColor = getHexColor(user?.background_color || user?.backgroundColor || 'bg-purple-500');

  return (
    <div className="container max-w-4xl py-8">
      {/* Header */}
      <div className="text-center mb-8">
        <div className="flex items-center justify-center gap-4 mb-4">
          {/* User Badge */}
          <div 
            className="w-20 h-20 rounded-full flex items-center justify-center text-3xl"
            style={{ backgroundColor: userBackgroundColor }}
          >
            {currentBadge.emoji}
          </div>
          <div>
            <h1 className="text-3xl font-bold">{String(user.username || 'Unknown User')}'s Profile</h1>
          </div>
        </div>
        
        <div className="flex items-center justify-center gap-4">
          <Badge variant="secondary" className="text-sm">
            {currentBadge.emoji} {currentBadge.name}
          </Badge>
          <Badge variant="outline" className="text-sm">
            <Trophy className="w-4 h-4 mr-1" />
            {totalPoints || 0} Points
          </Badge>
        </div>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        {/* Reviews Section */}
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Star className="w-5 h-5" />
              Recent Reviews ({reviews.length})
            </CardTitle>
          </CardHeader>
          <CardContent>
            {reviews.length === 0 ? (
              <p className="text-muted-foreground text-center py-4">No reviews yet</p>
            ) : (
              <div className="space-y-4">
                {reviews.slice(0, 5).map((review: any) => (
                  <div key={review.id} className="border-b border-gray-200 last:border-b-0 pb-3 last:pb-0">
                    <div className="flex items-start justify-between">
                      <div className="flex-1">
                        <h4 className="font-medium text-sm">{review.showName || 'Unknown Show'}</h4>
                        <div className="flex items-center gap-1 my-1">
                          {[...Array(5)].map((_, i) => (
                            <Star
                              key={i}
                              className={`w-3 h-3 ${
                                i < review.rating ? 'fill-yellow-400 text-yellow-400' : 'text-gray-300'
                              }`}
                            />
                          ))}
                        </div>
                        {review.review && (
                          <p className="text-sm text-muted-foreground line-clamp-2">{review.review}</p>
                        )}
                      </div>
                      <div className="text-xs text-muted-foreground ml-2">
                        {new Date(review.createdAt).toLocaleDateString()}
                      </div>
                    </div>
                  </div>
                ))}
                {reviews.length > 5 && (
                  <p className="text-sm text-muted-foreground text-center">
                    And {reviews.length - 5} more reviews...
                  </p>
                )}
              </div>
            )}
          </CardContent>
        </Card>

        {/* Favorites Section */}
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Book className="w-5 h-5" />
              Favorite Shows ({favorites.length})
            </CardTitle>
          </CardHeader>
          <CardContent>
            {favorites.length === 0 ? (
              <p className="text-muted-foreground text-center py-4">No favorites yet</p>
            ) : (
              <div className="space-y-2">
                {favorites.slice(0, 8).map((show: any) => (
                  <div key={show.id} className="flex items-center gap-3 p-2 rounded-lg bg-gray-50">
                    <img
                      src={show.imageUrl}
                      alt={show.name}
                      className="w-10 h-10 rounded object-cover"
                    />
                    <div className="flex-1 min-w-0">
                      <h4 className="font-medium text-sm truncate">{show.name}</h4>
                      <p className="text-xs text-muted-foreground">{show.ageRange}</p>
                    </div>
                  </div>
                ))}
                {favorites.length > 8 && (
                  <p className="text-sm text-muted-foreground text-center">
                    And {favorites.length - 8} more favorites...
                  </p>
                )}
              </div>
            )}
          </CardContent>
        </Card>

        {/* Recent Activity Section */}
        <Card className="md:col-span-2">
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Calendar className="w-5 h-5" />
              Recent Activity
            </CardTitle>
          </CardHeader>
          <CardContent>
            {recentActivity.length === 0 ? (
              <p className="text-muted-foreground text-center py-4">No recent activity</p>
            ) : (
              <div className="space-y-3">
                {recentActivity.slice(0, 10).map((activity: any, index: number) => (
                  <div key={`${activity.id}-${index}`} className="flex items-center justify-between py-2 border-b border-gray-100 last:border-b-0">
                    <div className="flex items-center gap-3">
                      <div className="w-8 h-8 rounded-full bg-blue-100 flex items-center justify-center">
                        {activity.activityType === 'review' && <Star className="w-4 h-4 text-blue-600" />}
                        {activity.activityType === 'login_reward' && <Calendar className="w-4 h-4 text-green-600" />}
                        {activity.activityType === 'research_read' && <Book className="w-4 h-4 text-purple-600" />}
                        {!['review', 'login_reward', 'research_read'].includes(activity.activityType) && 
                          <Trophy className="w-4 h-4 text-orange-600" />}
                      </div>
                      <div>
                        <p className="text-sm font-medium">{formatActivityType(activity.activityType)}</p>
                        <p className="text-xs text-muted-foreground">{activity.description || ''}</p>
                      </div>
                    </div>
                    <div className="text-right">
                      <p className="text-sm font-medium text-green-600">+{activity.points}</p>
                      <p className="text-xs text-muted-foreground">
                        {activity.createdAt ? new Date(activity.createdAt).toLocaleDateString() : 'N/A'}
                      </p>
                    </div>
                  </div>
                ))}
              </div>
            )}
          </CardContent>
        </Card>
      </div>
    </div>
  );
}
</file>

<file path="client/src/main.tsx">
import { createRoot } from "react-dom/client";
import App from "./App";
import "./index.css";

// Load Google Fonts for matching design reference
const googleFontsLink = document.createElement('link');
googleFontsLink.href = 'https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;800&family=Open+Sans:wght@400;600&display=swap';
googleFontsLink.rel = 'stylesheet';
document.head.appendChild(googleFontsLink);

// Load Font Awesome for icons
const fontAwesomeLink = document.createElement('link');
fontAwesomeLink.href = 'https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css';
fontAwesomeLink.rel = 'stylesheet';
document.head.appendChild(fontAwesomeLink);

// Add title
const titleElement = document.createElement('title');
titleElement.textContent = 'TV Tantrum - Children\'s TV Show Comparison';
document.head.appendChild(titleElement);

createRoot(document.getElementById("root")!).render(<App />);
</file>

<file path="server/admin-functions.ts">
import { pool } from "./db";

/**
 * Admin function to delete a review
 * @param reviewId - The ID of the review to delete
 * @returns Object containing success status and points deducted
 */
export async function deleteReview(reviewId: number): Promise<{ success: boolean, pointsDeducted: number }> {
  const client = await pool.connect();
  
  try {
    await client.query('BEGIN');
    
    // First, get the review details to identify the user
    const reviewResult = await client.query(
      'SELECT user_id, show_name FROM tv_show_reviews WHERE id = $1',
      [reviewId]
    );
    
    if (reviewResult.rows.length === 0) {
      console.log(`Review with ID ${reviewId} not found`);
      await client.query('ROLLBACK');
      return { success: false, pointsDeducted: 0 };
    }
    
    const userId = reviewResult.rows[0].user_id;
    const showName = reviewResult.rows[0].show_name || 'Unknown show';
    
    console.log(`Admin deleting review ID ${reviewId} by user ${userId} for show "${showName}"`);
    
    // Standard points for a review
    const pointsToDeduct = 5;
    
    // Delete the review
    const deleteResult = await client.query('DELETE FROM tv_show_reviews WHERE id = $1', [reviewId]);
    
    if (deleteResult.rowCount === 0) {
      console.log(`Failed to delete review with ID ${reviewId}`);
      await client.query('ROLLBACK');
      return { success: false, pointsDeducted: 0 };
    }
    
    // If we have a valid userId, handle the points deduction
    if (userId) {
      // Create negative points entry to balance out the original reward
      await client.query(
        `INSERT INTO user_points_history 
         (user_id, points, activity_type, description, created_at) 
         VALUES ($1, $2, $3, $4, NOW())`,
        [userId, -pointsToDeduct, 'review_deleted_by_admin', `Points deducted for review of ${showName} removed by admin`]
      );
      
      // Update user's total points, making sure it doesn't go below zero
      await client.query(
        `UPDATE users 
         SET total_points = GREATEST(0, COALESCE(total_points, 0) - $1) 
         WHERE id = $2`,
        [pointsToDeduct, userId]
      );
      
      console.log(`Deducted ${pointsToDeduct} points from user ${userId}`);
    }
    
    await client.query('COMMIT');
    return { success: true, pointsDeducted: pointsToDeduct };
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Error in admin deleteReview:', error);
    throw error;
  } finally {
    client.release();
  }
}
</file>

<file path="server/database-favorites.ts">
import { db, pool } from "./db";
import { eq, and, or, not, sql, desc, inArray } from "drizzle-orm";
import { favorites, tvShows, userPointsHistory, users } from "@shared/schema";
import type { Favorite, TvShow } from "@shared/schema";

/**
 * Add a show to user's favorites
 */
export async function addFavorite(userId: number, tvShowId: number): Promise<any> {
  const client = await pool.connect();
  
  try {
    await client.query('BEGIN');
    
    // First check if this is already a favorite
    const checkResult = await client.query(
      'SELECT * FROM favorites WHERE user_id = $1 AND tv_show_id = $2',
      [userId, tvShowId]
    );
    
    if (checkResult.rows.length > 0) {
      // Already a favorite, no need to add again
      await client.query('COMMIT');
      return checkResult.rows[0];
    }
    
    // Get show name for reference
    const showResult = await client.query(
      'SELECT name FROM tv_shows WHERE id = $1',
      [tvShowId]
    );
    
    const showName = showResult.rows[0]?.name || 'Unknown show';
    
    // Add to favorites with show name
    const result = await client.query(
      'INSERT INTO favorites (user_id, tv_show_id, show_name, created_at) VALUES ($1, $2, $3, NOW()) RETURNING *',
      [userId, tvShowId, showName]
    );
    
    // Log the favorite addition without awarding points
    console.log(`User ${userId} adding ${showName} to favorites - no points awarded`)
    
    await client.query('COMMIT');
    console.log(`User ${userId} added show ${tvShowId} (${showName}) to favorites`);
    return result.rows[0];
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Error adding favorite:', error);
    throw error;
  } finally {
    client.release();
  }
}

/**
 * Remove a show from user's favorites
 */
export async function removeFavorite(userId: number, tvShowId: number): Promise<boolean> {
  try {
    const result = await pool.query(
      'DELETE FROM favorites WHERE user_id = $1 AND tv_show_id = $2',
      [userId, tvShowId]
    );
    
    const removed = result.rowCount > 0;
    if (removed) {
      console.log(`User ${userId} removed show ${tvShowId} from favorites`);
    } else {
      console.log(`Show ${tvShowId} was not in favorites for user ${userId}`);
    }
    
    return removed;
  } catch (error) {
    console.error('Error removing favorite:', error);
    return false;
  }
}

/**
 * Get all shows favorited by a user
 */
export async function getUserFavorites(userId: number): Promise<TvShow[]> {
  try {
    const result = await pool.query(`
      SELECT t.* 
      FROM tv_shows t
      JOIN favorites f ON t.id = f.tv_show_id
      WHERE f.user_id = $1
      ORDER BY f.created_at DESC
    `, [userId]);
    
    const shows = result.rows.map(row => ({
      id: row.id,
      name: row.name,
      description: row.description,
      imageUrl: row.image_url,
      ageRange: row.age_range,
      episodeLength: row.episode_length,
      stimulationScore: row.stimulation_score,
      releaseYear: row.release_year,
      endYear: row.end_year,
      isOngoing: row.is_ongoing,
      creator: row.creator,
      // Add other fields as needed
    }));
    
    console.log(`Retrieved ${shows.length} favorites for user ${userId}`);
    return shows;
  } catch (error) {
    console.error('Error getting user favorites:', error);
    return [];
  }
}

/**
 * Check if a show is in user's favorites
 */
export async function isFavorite(userId: number, tvShowId: number): Promise<boolean> {
  try {
    const result = await pool.query(
      'SELECT * FROM favorites WHERE user_id = $1 AND tv_show_id = $2',
      [userId, tvShowId]
    );
    
    return result.rows.length > 0;
  } catch (error) {
    console.error('Error checking favorite status:', error);
    return false;
  }
}

/**
 * Get similar shows based on user's favorites
 */
export async function getSimilarShows(userId: number, limit: number = 5): Promise<TvShow[]> {
  try {
    // First get user's favorite shows
    const favoritesResult = await pool.query(
      'SELECT tv_show_id FROM favorites WHERE user_id = $1',
      [userId]
    );
    
    if (favoritesResult.rows.length === 0) {
      return []; // No favorites, so no similar shows
    }
    
    // Extract favorite IDs
    const favoriteIds = favoritesResult.rows.map(row => row.tv_show_id);
    
    // Find shows with similar themes to user's favorites
    const similarShowsResult = await pool.query(`
      SELECT DISTINCT t.*, COUNT(ts.theme_id) as theme_matches
      FROM tv_shows t
      JOIN tv_show_themes ts ON t.id = ts.tv_show_id
      WHERE ts.theme_id IN (
        SELECT theme_id 
        FROM tv_show_themes 
        WHERE tv_show_id = ANY($1::int[])
      )
      AND t.id <> ALL($1::int[])
      GROUP BY t.id
      ORDER BY theme_matches DESC
      LIMIT $2
    `, [favoriteIds, limit]);
    
    const shows = similarShowsResult.rows.map(row => ({
      id: row.id,
      name: row.name,
      description: row.description,
      imageUrl: row.image_url,
      ageRange: row.age_range,
      episodeLength: row.episode_length,
      stimulationScore: row.stimulation_score,
      releaseYear: row.release_year,
      endYear: row.end_year,
      isOngoing: row.is_ongoing,
      creator: row.creator,
      // Add other fields as needed
    }));
    
    return shows;
  } catch (error) {
    console.error('Error getting similar shows:', error);
    return [];
  }
}
</file>

<file path="server/db.ts">
import pg from 'pg';
import { drizzle } from 'drizzle-orm/node-postgres';
import * as schema from "@shared/schema";

const { Pool } = pg;

if (!process.env.DATABASE_URL) {
  throw new Error("DATABASE_URL must be set. Did you forget to provision a database?");
}

// Configure the pool with optimized settings to prevent timeouts
const poolConfig = {
  connectionString: process.env.DATABASE_URL,
  max: 5, // Reduce connection pool size to prevent overwhelming the DB
  idleTimeoutMillis: 60000, // Increased to 60 seconds to allow for longer idle times
  connectionTimeoutMillis: 10000, // Increased to 10 seconds to allow more time to establish connections
  ssl: { rejectUnauthorized: false },
  application_name: 'tv-tantrum'
};

export const pool = new Pool(poolConfig);

// Add error handling for the pool
pool.on('error', (err) => {
  console.error('Unexpected error on idle client', err);
  if (process.env.NODE_ENV === 'production') {
    process.exit(-1);
  }
});

// Add connect handling
pool.on('connect', (client) => {
  client.on('error', (err) => {
    console.error('Database client error:', err);
  });
});

// Initialize Drizzle ORM with the pool
export const db = drizzle(pool, { schema });

// Export a helper function to check DB connection
export async function checkDatabaseConnection() {
  let client;
  try {
    client = await pool.connect();
    const result = await client.query('SELECT NOW()');
    console.log('Database connected successfully at:', result.rows[0].now);
    
    // Check if users table exists
    const tablesCheck = await client.query(`
      SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE table_name = 'users'
      );
    `);
    
    if (!tablesCheck.rows[0].exists) {
      console.log('Users table does not exist yet');
      return true;
    }
    
    const userCount = await client.query('SELECT COUNT(*) FROM users');
    console.log(`Database connection verified. User count: ${userCount.rows[0].count}`);
    return true;
  } catch (error) {
    console.error('Database connection check failed:', error);
    if (process.env.NODE_ENV === 'development') {
      console.log('Continuing in development mode despite database error');
      return true;
    }
    return false;
  } finally {
    if (client) client.release();
  }
}
</file>

<file path="server/details-preservator.ts">
import fs from 'fs';
import path from 'path';

// Define the structure for storing custom show details
interface CustomShowDetails {
  // Stimulation metrics
  stimulationScore?: number;
  musicTempo?: string;
  totalMusicLevel?: string;
  totalSoundEffectTimeLevel?: string;
  sceneFrequency?: string;
  interactivityLevel?: string;
  dialogueIntensity?: string;
  soundEffectsLevel?: string;
  animationStyle?: string;
  
  // Other important fields
  ageRange?: string;
  themes?: string[];
  description?: string;
  
  // Fields to be preserved during updates
  [key: string]: any;
}

// Custom show details mapping type
interface CustomShowDetailsMap {
  [showId: string]: CustomShowDetails;
}

/**
 * Load custom show details mapping from the JSON file
 */
export function loadCustomShowDetailsMap(): CustomShowDetailsMap {
  try {
    const filePath = path.join(process.cwd(), 'customShowDetailsMap.json');
    if (fs.existsSync(filePath)) {
      const data = fs.readFileSync(filePath, 'utf-8');
      return JSON.parse(data);
    }
  } catch (error) {
    console.error('Error loading custom show details map:', error);
  }
  return {};
}

/**
 * Save custom show details mapping to the JSON file
 */
export function saveCustomShowDetailsMap(customDetailsMap: CustomShowDetailsMap): void {
  try {
    const filePath = path.join(process.cwd(), 'customShowDetailsMap.json');
    fs.writeFileSync(filePath, JSON.stringify(customDetailsMap, null, 2));
  } catch (error) {
    console.error('Error saving custom show details map:', error);
  }
}

/**
 * Update custom show details in the mapping
 */
export function updateCustomShowDetails(showId: number, updatedFields: Partial<CustomShowDetails>): void {
  const customDetailsMap = loadCustomShowDetailsMap();
  const showIdStr = showId.toString();
  
  // Merge with existing details or create new entry
  customDetailsMap[showIdStr] = {
    ...(customDetailsMap[showIdStr] || {}),
    ...updatedFields
  };
  
  saveCustomShowDetailsMap(customDetailsMap);
}

/**
 * Get custom show details for a specific show
 */
export function getCustomShowDetails(showId: number): CustomShowDetails | undefined {
  const customDetailsMap = loadCustomShowDetailsMap();
  return customDetailsMap[showId.toString()];
}

/**
 * Preserve custom show details when updating shows from external sources
 * This merges custom fields with new data, prioritizing custom fields
 */
export function preserveCustomShowDetails<T>(showId: number, currentDetails: T, newData: Partial<T>): T {
  const customDetails = getCustomShowDetails(showId);
  
  if (!customDetails) {
    return { ...currentDetails, ...newData };
  }
  
  // Start with current details
  const mergedData = { ...currentDetails };
  
  // Add new data fields that aren't in custom details
  for (const [key, value] of Object.entries(newData)) {
    if (!(key in customDetails)) {
      (mergedData as any)[key] = value;
    }
  }
  
  // Override with custom details (highest priority)
  for (const [key, value] of Object.entries(customDetails)) {
    (mergedData as any)[key] = value;
  }
  
  return mergedData;
}

/**
 * Apply custom show details to all shows in storage at server startup
 * Uses batch processing for improved performance
 */
export async function applyCustomShowDetails(getShowById: (id: number) => Promise<any>, updateShow: (id: number, data: any) => Promise<any>): Promise<void> {
  try {
    const customDetailsMap = loadCustomShowDetailsMap();
    console.log(`Applying custom details for ${Object.keys(customDetailsMap).length} shows from customShowDetailsMap.json`);
    
    // Skip custom details application if in performance mode
    if (process.env.SKIP_CUSTOM_DETAILS === 'true') {
      console.log('Skipping custom details application (SKIP_CUSTOM_DETAILS=true)');
      return;
    }
    
    // Process in batches of 20 shows
    const BATCH_SIZE = 20;
    const showIds = Object.keys(customDetailsMap).map(id => parseInt(id)).filter(id => !isNaN(id));
    const totalBatches = Math.ceil(showIds.length / BATCH_SIZE);
    
    console.log(`Processing ${showIds.length} shows in ${totalBatches} batches of ${BATCH_SIZE}`);
    
    for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
      const batchStart = batchIndex * BATCH_SIZE;
      const batchEnd = Math.min(batchStart + BATCH_SIZE, showIds.length);
      const currentBatch = showIds.slice(batchStart, batchEnd);
      
      console.log(`Processing batch ${batchIndex + 1}/${totalBatches} (shows ${batchStart+1}-${batchEnd})`);
      
      // Process each batch in parallel
      const batchPromises = currentBatch.map(async (showId) => {
        try {
          const show = await getShowById(showId);
          if (show) {
            // Don't log every show to reduce console output
            // console.log(`Applying custom details to show ID ${showId}: ${show.name}`);
            return updateShow(showId, customDetailsMap[showId.toString()]);
          }
        } catch (err) {
          console.error(`Error updating show ${showId}:`, err);
        }
      });
      
      // Wait for current batch to complete before processing next batch
      await Promise.all(batchPromises);
    }
    
    console.log('Custom details application completed');
  } catch (error) {
    console.error('Error applying custom show details:', error);
  }
}
</file>

<file path="server/direct-upload.ts">
import { Express } from 'express';
import multer from 'multer';
import * as fs from 'fs';
import * as path from 'path';

// Configure multer storage for research files
const researchStorage = multer.diskStorage({
  destination: function (req, file, cb) {
    const uploadDir = path.join(process.cwd(), 'public', 'research');
    if (!fs.existsSync(uploadDir)) {
      fs.mkdirSync(uploadDir, { recursive: true });
    }
    cb(null, uploadDir);
  },
  filename: function (req, file, cb) {
    const timestamp = Date.now();
    const safeName = file.originalname.replace(/\s+/g, '-');
    cb(null, `${timestamp}-${safeName}`);
  }
});

// Create multer upload middleware
const researchUpload = multer({ 
  storage: researchStorage,
  limits: { fileSize: 5 * 1024 * 1024 } // 5MB limit
});

// Setup upload routes
export function setupUploadRoutes(app: Express) {
  // Research image upload endpoint
  app.post('/api/upload', researchUpload.single('file'), (req, res) => {
    try {
      console.log('Research file upload request received');
      
      if (!req.file) {
        console.log('No file in request');
        return res.status(400).json({ error: 'No file uploaded' });
      }
      
      // Return URL to uploaded file
      const fileUrl = `/research/${req.file.filename}`;
      console.log(`File uploaded successfully to ${fileUrl}`);
      
      return res.json({ url: fileUrl });
    } catch (error) {
      console.error('Upload error:', error);
      return res.status(500).json({ error: 'Upload failed' });
    }
  });
}
</file>

<file path="server/directSearch.ts">
import { pool } from './db';

/**
 * Direct search function that bypasses the ORM issues
 * This function performs a direct SQL query against the database
 * to search for TV shows by name or description
 */
export async function directSearchShows(searchTerm: string) {
  // Use a direct database connection for reliability
  const client = await pool.connect();
  
  try {
    // Execute a simple search query that will be reliable
    const result = await client.query(
      `SELECT * FROM tv_shows 
      WHERE name ILIKE $1 OR description ILIKE $1
      ORDER BY name ASC`,
      [`%${searchTerm}%`]
    );
    
    return result.rows;
  } finally {
    client.release();
  }
}

/**
 * Track a search term in the database without using the ORM
 * This uses direct SQL to avoid timestamp handling issues
 */
export async function trackSearch(tvShowId: number) {
  // Don't let this function throw errors
  try {
    const client = await pool.connect();
    
    try {
      // Check if there's an existing record
      const checkResult = await client.query(
        'SELECT id, search_count FROM tv_show_searches WHERE tv_show_id = $1',
        [tvShowId]
      );
      
      if (checkResult.rows.length > 0) {
        // Update existing record
        const existingSearch = checkResult.rows[0];
        await client.query(
          'UPDATE tv_show_searches SET search_count = $1, last_searched = NOW() WHERE id = $2',
          [existingSearch.search_count + 1, existingSearch.id]
        );
      } else {
        // Insert new record
        await client.query(
          'INSERT INTO tv_show_searches (tv_show_id, search_count, last_searched) VALUES ($1, $2, NOW())',
          [tvShowId, 1]
        );
      }
    } finally {
      client.release();
    }
  } catch (error) {
    // Just log the error but don't let it affect anything else
    console.error('Search tracking failed:', error);
  }
}
</file>

<file path="server/github.ts">
import { Octokit } from "octokit";
import { TvShowGitHub, tvShowGitHubSchema } from "@shared/schema";

export class GitHubService {
  private octokit: Octokit;
  private owner: string;
  private repo: string;
  private dataPath: string;

  constructor(
    githubToken?: string,
    owner: string = "ledhaseeb",
    repo: string = "tvtantrum",
    dataPath: string = "database"
  ) {
    this.octokit = new Octokit({ auth: githubToken });
    this.owner = owner;
    this.repo = repo;
    this.dataPath = dataPath;
  }

  async fetchTvShowsData(): Promise<TvShowGitHub[]> {
    try {
      // Get the specific reviewed_shows.json file as mentioned by user
      const reviewedShowsPath = `${this.dataPath}/reviewed_shows.json`;
      console.log(`Fetching TV shows data from GitHub: ${this.owner}/${this.repo}/${reviewedShowsPath}`);
      
      const { data: fileContent } = await this.octokit.rest.repos.getContent({
        owner: this.owner,
        repo: this.repo,
        path: reviewedShowsPath,
      });

      // Process file content
      const showsData: TvShowGitHub[] = [];
      
      if ("content" in fileContent && typeof fileContent.content === "string") {
        // Decode Base64 content
        const content = Buffer.from(fileContent.content, "base64").toString();
        
        try {
          // Parse and validate JSON
          const jsonData = JSON.parse(content);
          
          // If it's an array, process each item as a show
          if (Array.isArray(jsonData)) {
            console.log(`Found ${jsonData.length} shows in reviewed_shows.json`);
            for (const item of jsonData) {
              const validatedShow = this.validateTvShow(item);
              if (validatedShow) {
                // Images are stored directly by filename in the data
                validatedShow.imageUrl = `https://raw.githubusercontent.com/${this.owner}/${this.repo}/main/client/public/images/${validatedShow.image_filename}`;
                showsData.push(validatedShow);
              }
            }
          } else {
            // It's a single show object
            const validatedShow = this.validateTvShow(jsonData);
            if (validatedShow) {
              // Images are stored directly by filename in the data
              validatedShow.imageUrl = `https://raw.githubusercontent.com/${this.owner}/${this.repo}/main/client/public/images/${validatedShow.image_filename}`;
              showsData.push(validatedShow);
            }
          }
        } catch (error) {
          console.error(`Error parsing JSON from ${reviewedShowsPath}:`, error);
        }
      }

      return showsData;
    } catch (error) {
      console.error("Error fetching TV shows data from GitHub:", error);
      throw new Error(`Failed to fetch TV shows data: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  private validateTvShow(data: any): TvShowGitHub | null {
    try {
      return tvShowGitHubSchema.parse(data);
    } catch (error) {
      console.error("Invalid TV show data:", error);
      return null;
    }
  }
}

// Create and export a singleton instance
export const githubService = new GitHubService(
  process.env.GITHUB_TOKEN
);
</file>

<file path="server/image-optimizer.ts">
import { omdbService } from './omdb';
import { storage } from './storage';
import { TvShow } from '@shared/schema';
import fetch from 'node-fetch';

interface ImageDimensions {
  width: number;
  height: number;
  isLandscape: boolean;
}

interface ImageCheckResult {
  id: number;
  name: string;
  currentImageUrl: string;
  dimensions?: ImageDimensions;
  isLandscape?: boolean;
  error?: string;
}

interface ImageUpdateResult {
  id: number;
  name: string;
  oldImageUrl: string;
  newImageUrl: string;
  imdbId?: string;
  error?: string;
}

export async function checkImageOrientation(imageUrl: string): Promise<ImageDimensions | null> {
  // Skip checks for images that don't exist or are from OMDB already
  if (!imageUrl || imageUrl === 'N/A' || imageUrl.includes('omdbapi.com') || imageUrl.includes('m.media-amazon.com')) {
    return null;
  }

  // In a Node.js environment, we can't use the Image object directly
  // Instead, we'll assume OMDB images are portrait and just continue with the update process
  
  // The Image object check would work in a browser environment, but not in Node.js
  // For now, we'll just consider all shows as candidates for optimization
  console.log(`Assuming image needs optimization: ${imageUrl}`);
  return null;
}

export async function updateShowImagesFromOmdb() {
  // Get all shows
  const shows = await storage.getAllTvShows();
  
  const landscapeShows: ImageCheckResult[] = [];
  const successfulUpdates: ImageUpdateResult[] = [];
  const failedUpdates: ImageUpdateResult[] = [];
  
  console.log(`Starting image optimization for ${shows.length} shows`);
  
  // Process each show to find landscape images or shows without good images
  for (const show of shows) {
    if (!show.imageUrl) {
      // Add shows with no images
      landscapeShows.push({
        id: show.id,
        name: show.name,
        currentImageUrl: '',
        isLandscape: true // Assume we need a replacement
      });
      continue;
    }
    
    try {
      // Check if the current image is landscape
      const dimensions = await checkImageOrientation(show.imageUrl);
      
      if (!dimensions) {
        // If we couldn't check dimensions, include it for potential update
        landscapeShows.push({
          id: show.id,
          name: show.name,
          currentImageUrl: show.imageUrl,
          isLandscape: true // Default to try updating
        });
      } else if (dimensions.isLandscape) {
        // If the image is landscape, include it for update
        landscapeShows.push({
          id: show.id,
          name: show.name,
          currentImageUrl: show.imageUrl,
          dimensions,
          isLandscape: true
        });
        console.log(`Found landscape image for "${show.name}": ${dimensions.width}x${dimensions.height}`);
      }
    } catch (error) {
      console.error(`Error checking dimensions for "${show.name}":`, error);
      // Include it anyway in case there's an error
      landscapeShows.push({
        id: show.id,
        name: show.name,
        currentImageUrl: show.imageUrl,
        error: error instanceof Error ? error.message : 'Unknown dimension check error',
        isLandscape: true // Default to try updating
      });
    }
  }
  
  console.log(`Found ${landscapeShows.length} shows with landscape or problematic images to update`);
  
  // Try to update each show with OMDB poster
  for (const show of landscapeShows) {
    try {
      console.log(`Looking up OMDB poster for "${show.name}"`);
      const omdbData = await omdbService.getShowData(show.name);
      
      if (omdbData && omdbData.poster && omdbData.poster !== 'N/A') {
        // Before updating, verify the OMDB poster is portrait-oriented
        let isOmdbPosterPortrait = true; // Assume portrait by default for OMDB
        
        // Only update if we're replacing a landscape image with a portrait one
        if (isOmdbPosterPortrait) {
          const updatedShow = await storage.updateTvShow(show.id, {
            imageUrl: omdbData.poster
          });
          
          if (updatedShow) {
            successfulUpdates.push({
              id: show.id,
              name: show.name,
              oldImageUrl: show.currentImageUrl,
              newImageUrl: omdbData.poster,
              imdbId: omdbData.imdbId
            });
            console.log(`✓ Updated "${show.name}" with OMDB poster`);
          } else {
            failedUpdates.push({
              id: show.id,
              name: show.name,
              oldImageUrl: show.currentImageUrl,
              newImageUrl: omdbData.poster,
              error: 'Storage update failed'
            });
            console.log(`✗ Failed to update "${show.name}" in storage`);
          }
        } else {
          failedUpdates.push({
            id: show.id,
            name: show.name,
            oldImageUrl: show.currentImageUrl,
            newImageUrl: omdbData.poster,
            error: 'OMDB poster is not portrait-oriented'
          });
          console.log(`✗ Skipped "${show.name}" because OMDB poster is not portrait-oriented`);
        }
      } else {
        failedUpdates.push({
          id: show.id,
          name: show.name,
          oldImageUrl: show.currentImageUrl,
          newImageUrl: '',
          error: 'No OMDB poster found'
        });
        console.log(`✗ No OMDB poster found for "${show.name}"`);
      }
    } catch (error) {
      failedUpdates.push({
        id: show.id,
        name: show.name,
        oldImageUrl: show.currentImageUrl,
        newImageUrl: '',
        error: error instanceof Error ? error.message : 'Unknown error'
      });
      console.log(`✗ Error updating "${show.name}": ${error}`);
    }
    
    // Add a small delay between requests to avoid rate limiting
    await new Promise(resolve => setTimeout(resolve, 300));
  }
  
  return {
    total: landscapeShows.length,
    successful: successfulUpdates,
    failed: failedUpdates
  };
}
</file>

<file path="server/image-preservator.ts">
import fs from 'fs';
import path from 'path';

// Custom image mapping type
interface CustomImageMap {
  [showId: string]: string;
}

/**
 * Load custom image mapping from the JSON file
 */
export function loadCustomImageMap(): CustomImageMap {
  try {
    const filePath = path.join(process.cwd(), 'customImageMap.json');
    if (fs.existsSync(filePath)) {
      const data = fs.readFileSync(filePath, 'utf-8');
      return JSON.parse(data);
    }
  } catch (error) {
    console.error('Error loading custom image map:', error);
  }
  return {};
}

/**
 * Save custom image mapping to the JSON file
 */
export function saveCustomImageMap(customImageMap: CustomImageMap): void {
  try {
    const filePath = path.join(process.cwd(), 'customImageMap.json');
    fs.writeFileSync(filePath, JSON.stringify(customImageMap, null, 2));
  } catch (error) {
    console.error('Error saving custom image map:', error);
  }
}

/**
 * Add or update a custom image mapping
 */
export function updateCustomImageMap(showId: number, imageUrl: string): void {
  const customImageMap = loadCustomImageMap();
  customImageMap[showId.toString()] = imageUrl;
  saveCustomImageMap(customImageMap);
}

/**
 * Get custom image URL for a show if it exists
 */
export function getCustomImageUrl(showId: number): string | undefined {
  const customImageMap = loadCustomImageMap();
  return customImageMap[showId.toString()];
}

/**
 * Preserve custom image URLs when updating shows from external sources
 */
export function preserveCustomImageUrl(showId: number, currentImageUrl: string | null): string | null {
  const customImageUrl = getCustomImageUrl(showId);
  return customImageUrl || currentImageUrl;
}

/**
 * Apply custom images to all shows in storage at server startup
 * Uses batch processing for improved performance
 */
export async function applyCustomImages(getShowById: (id: number) => Promise<any>, updateShow: (id: number, data: any) => Promise<any>): Promise<void> {
  try {
    const customImageMap = loadCustomImageMap();
    console.log(`Applying ${Object.keys(customImageMap).length} custom images from customImageMap.json`);
    
    // Skip custom images application if in performance mode
    if (process.env.SKIP_CUSTOM_IMAGES === 'true') {
      console.log('Skipping custom images application (SKIP_CUSTOM_IMAGES=true)');
      return;
    }
    
    // Process in batches of 20 shows
    const BATCH_SIZE = 20;
    const showIds = Object.keys(customImageMap).map(id => parseInt(id)).filter(id => !isNaN(id));
    const totalBatches = Math.ceil(showIds.length / BATCH_SIZE);
    
    console.log(`Processing ${showIds.length} images in ${totalBatches} batches of ${BATCH_SIZE}`);
    
    for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
      const batchStart = batchIndex * BATCH_SIZE;
      const batchEnd = Math.min(batchStart + BATCH_SIZE, showIds.length);
      const currentBatch = showIds.slice(batchStart, batchEnd);
      
      console.log(`Processing image batch ${batchIndex + 1}/${totalBatches} (shows ${batchStart+1}-${batchEnd})`);
      
      // Process each batch in parallel
      const batchPromises = currentBatch.map(async (showId) => {
        try {
          const show = await getShowById(showId);
          if (show) {
            // Don't log every show to reduce console output
            // console.log(`Applying custom image to show ID ${showId}: ${show.name}`);
            return updateShow(showId, { imageUrl: customImageMap[showId.toString()] });
          }
        } catch (err) {
          console.error(`Error updating image for show ${showId}:`, err);
        }
      });
      
      // Wait for current batch to complete before processing next batch
      await Promise.all(batchPromises);
    }
    
    console.log('Custom images application completed');
  } catch (error) {
    console.error('Error applying custom images:', error);
  }
}
</file>

<file path="server/image-upload.ts">
import multer from 'multer';
import path from 'path';
import fs from 'fs';
import sharp from 'sharp';
import { Request, Response, NextFunction } from 'express';

// Create all required image directories
const imageDir = './public/uploads';
const optimizedImageDir = './public/uploads/optimized';
const primaryImageDir = './public/media/tv-shows'; // Primary directory for TV show images

// Create directories if they don't exist
[imageDir, optimizedImageDir, primaryImageDir].forEach(dir => {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
});

// Configure storage for multer
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, imageDir);
  },
  filename: function (req, file, cb) {
    // Generate a unique filename with timestamp
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    const ext = path.extname(file.originalname);
    cb(null, `show-image-${uniqueSuffix}${ext}`);
  }
});

// File filter to ensure only images are uploaded
const fileFilter = (req: Request, file: Express.Multer.File, cb: multer.FileFilterCallback) => {
  // Accept only image files
  if (file.mimetype.startsWith('image/')) {
    cb(null, true);
  } else {
    cb(new Error('Only image files are allowed!'));
  }
};

// Initialize multer upload
export const upload = multer({ 
  storage: storage,
  fileFilter: fileFilter,
  limits: {
    fileSize: 5 * 1024 * 1024 // 5MB file size limit
  }
});

/**
 * Optimize an uploaded image for web use
 * @param filePath Path to the original uploaded file
 * @returns Path to the optimized image
 */
export async function optimizeImage(filePath: string): Promise<string> {
  const ext = path.extname(filePath);
  const filename = path.basename(filePath, ext);
  const optimizedFileName = `${filename}-optimized.jpg`;
  const optimizedPath = path.join(optimizedImageDir, optimizedFileName);
  const primaryMediaPath = path.join(primaryImageDir, optimizedFileName);
  
  try {
    // Get image dimensions first to determine appropriate sizing
    const metadata = await sharp(filePath).metadata();
    
    // Standardize to portrait format - target a 3:4 aspect ratio (portrait)
    // Width: If width > 600px, resize to 600px width
    // Height: Automatically calculated to maintain aspect ratio, but aim for portrait orientation
    
    // Default values if metadata isn't available
    const originalWidth = metadata.width || 800;
    const originalHeight = metadata.height || 600;
    
    // Target portrait sizes
    let targetWidth: number;
    let targetHeight: number;

    // If the original is already portrait or square, maintain aspect ratio but limit max dimensions
    if (originalHeight >= originalWidth) {
      // It's already portrait or square, so we'll just resize keeping the aspect ratio
      targetWidth = Math.min(originalWidth, 600); // Max width of 600px
      targetHeight = Math.round((targetWidth / originalWidth) * originalHeight);

      // Ensure height doesn't exceed 900px (for very tall images)
      if (targetHeight > 900) {
        targetHeight = 900;
        targetWidth = Math.round((targetHeight / originalHeight) * originalWidth);
      }
    } else {
      // It's landscape, so we need to constrain height more aggressively
      // Target a 3:4 aspect ratio (width:height) for portrait orientation
      targetHeight = Math.min(originalHeight, 800); // Max height of 800px
      targetWidth = Math.min(originalWidth, Math.round(targetHeight * 0.75)); // Ensure width is about 75% of height
    }

    // Generate optimized image buffer
    const imageBuffer = await sharp(filePath)
      .resize(targetWidth, targetHeight, {
        fit: 'contain',
        background: { r: 255, g: 255, b: 255, alpha: 1 } // White background
      })
      .jpeg({ quality: 85, progressive: true }) // Good balance of quality and file size
      .toBuffer();
    
    // Save to both locations
    await Promise.all([
      fs.promises.writeFile(optimizedPath, imageBuffer),
      fs.promises.writeFile(primaryMediaPath, imageBuffer)
    ]);
    
    console.log(`Image optimized: ${optimizedPath} (${targetWidth}x${targetHeight})`);
    console.log(`Also saved to primary media directory: ${primaryMediaPath}`);
    
    // The URL path is now media/tv-shows for consistent image access
    return `/media/tv-shows/${optimizedFileName}`;
  } catch (error) {
    console.error('Error optimizing image:', error);
    // Fallback to traditional path if there's an error
    try {
      // Still try to save to the old location as a fallback
      await sharp(filePath)
        .resize(600, 800, { fit: 'inside' })
        .jpeg({ quality: 85 })
        .toFile(optimizedPath);
      
      return `/uploads/optimized/${path.basename(optimizedPath)}`;
    } catch {
      // If that also fails, just return the original
      return `/uploads/${path.basename(filePath)}`;
    }
  }
}

// Error handler middleware for multer
export const uploadErrorHandler = (err: any, req: Request, res: Response, next: NextFunction) => {
  if (err instanceof multer.MulterError) {
    if (err.code === 'LIMIT_FILE_SIZE') {
      return res.status(400).json({ 
        error: 'File too large',
        message: 'File size should not exceed 5MB' 
      });
    }
    return res.status(400).json({ 
      error: err.code,
      message: err.message 
    });
  }
  
  if (err) {
    return res.status(400).json({ 
      error: 'Invalid upload',
      message: err.message 
    });
  }
  
  next();
};
</file>

<file path="server/index.ts">
import express, { type Request, Response, NextFunction } from "express";
import { createServer, type Server } from "http";
import path from "path";
import { registerRoutes } from "./routes";
import { setupVite, serveStatic, log } from "./vite";
import { checkDatabaseConnection } from "./db";
import multer from 'multer';
import * as fs from 'fs';

const app = express();
app.use(express.json());
app.use(express.urlencoded({ extended: false }));

// Serve TV show images from the primary media directory
app.use('/media/tv-shows', express.static(path.join(process.cwd(), 'public/media/tv-shows')));

// Keep serving from the old locations for backward compatibility
app.use('/custom-images', express.static(path.join(process.cwd(), 'client/public/custom-images')));
app.use('/custom-images', express.static(path.join(process.cwd(), 'public/media/tv-shows')));

// Serve research files
app.use('/research', express.static(path.join(process.cwd(), 'public/research')));

// Make sure research directory exists
const researchDir = path.join(process.cwd(), 'public/research');
if (!fs.existsSync(researchDir)) {
  fs.mkdirSync(researchDir, { recursive: true });
}

// Configure file upload for research images
const researchStorage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, researchDir);
  },
  filename: function (req, file, cb) {
    const timestamp = Date.now();
    const safeName = file.originalname.replace(/\s+/g, '-');
    cb(null, `${timestamp}-${safeName}`);
  }
});

// Create the upload middleware
const researchUpload = multer({ 
  storage: researchStorage,
  limits: { fileSize: 5 * 1024 * 1024 } // 5MB limit
});

// Setup direct file upload endpoint
app.post('/api/upload', researchUpload.single('file'), (req, res) => {
  try {
    console.log('Research file upload request received');
    
    if (!req.file) {
      console.log('No file in request');
      return res.status(400).json({ error: 'No file uploaded' });
    }
    
    // Return URL to uploaded file
    const fileUrl = `/research/${req.file.filename}`;
    console.log(`File uploaded successfully to ${fileUrl}`);
    
    return res.json({ url: fileUrl });
  } catch (error) {
    console.error('Upload error:', error);
    return res.status(500).json({ error: 'Upload failed' });
  }
});

app.use((req, res, next) => {
  const start = Date.now();
  const path = req.path;
  let capturedJsonResponse: Record<string, any> | undefined = undefined;

  const originalResJson = res.json;
  res.json = function (bodyJson, ...args) {
    capturedJsonResponse = bodyJson;
    return originalResJson.apply(res, [bodyJson, ...args]);
  };

  res.on("finish", () => {
    const duration = Date.now() - start;
    if (path.startsWith("/api")) {
      let logLine = `${req.method} ${path} ${res.statusCode} in ${duration}ms`;
      if (capturedJsonResponse) {
        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;
      }

      if (logLine.length > 80) {
        logLine = logLine.slice(0, 79) + "…";
      }

      log(logLine);
    }
  });

  next();
});

(async () => {
  // Check database connection before starting the server
  await checkDatabaseConnection();
  
  const server = await registerRoutes(app);

  app.use((err: any, _req: Request, res: Response, _next: NextFunction) => {
    const status = err.status || err.statusCode || 500;
    const message = err.message || "Internal Server Error";

    res.status(status).json({ message });
    throw err;
  });

  // importantly only setup vite in development and after
  // setting up all the other routes so the catch-all route
  // doesn't interfere with the other routes
  if (app.get("env") === "development") {
    await setupVite(app, server);
  } else {
    serveStatic(app);
  }

  // ALWAYS serve the app on port 5000
  // this serves both the API and the client.
  // It is the only port that is not firewalled.
  const port = 5000;
  
  // Try to close any existing connections
  const existingServer = await new Promise<Server>((resolve) => {
    const testServer = createServer();
    testServer.listen(port, "0.0.0.0", () => {
      testServer.close(() => resolve(server));
    });
    testServer.on('error', () => resolve(server));
  });

  existingServer.listen({
    port,
    host: "0.0.0.0",
    reusePort: true,
  }, () => {
    log(`serving on port ${port}`);
  });
})();
</file>

<file path="server/lookup-api.ts">
/**
 * TV Show Lookup API
 * 
 * This file provides an API endpoint for looking up TV show metadata
 * from external sources like OMDb and YouTube.
 */

import { Request, Response, Router } from 'express';
import { omdbService } from './omdb';
import { youtubeService } from './youtube';

// Create a router for lookup API endpoints
const lookupRouter = Router();

// Helper function to clean up YouTube description text
const getCleanYouTubeDescription = (description: string): string => {
  if (!description) return '';
  
  // Strip out common YouTube description elements
  return description
    .replace(/Follow us on social media:[\s\S]*?(?=\n\n|$)/, '')
    .replace(/Subscribe to our channel:[\s\S]*?(?=\n\n|$)/, '')
    .replace(/Visit our website:[\s\S]*?(?=\n\n|$)/, '')
    .replace(/\bhttps?:\/\/\S+\b/g, '')  // Remove URLs
    .replace(/\n{3,}/g, '\n\n')          // Normalize line breaks
    .replace(/\s{2,}/g, ' ')             // Normalize spaces
    .trim();
};

// Endpoint to lookup show data from external APIs (OMDb and YouTube)
lookupRouter.get("/", async (req: Request, res: Response) => {
  try {
    const showName = req.query.name as string;
    
    if (!showName || showName.trim() === '') {
      return res.status(400).json({ message: "Show name is required" });
    }
    
    console.log(`Looking up external data for show: "${showName}"`);
    
    const results = {
      omdb: null,
      youtube: null
    };
    
    // Check OMDb first
    try {
      const omdbData = await omdbService.getShowData(showName);
      console.log(`OMDb lookup for "${showName}":`, omdbData ? 'Found' : 'Not found');
      
      if (omdbData) {
        results.omdb = {
          title: omdbData.title || showName,
          year: omdbData.year || '',
          plot: omdbData.plot || '',
          director: omdbData.director || '',
          writer: omdbData.writer || '',
          rated: omdbData.rated || '',
          poster: omdbData.poster || '',
          awards: omdbData.awards || '',
          country: omdbData.country || '',
          language: omdbData.language || '',
          runtime: omdbData.runtime || '',
          type: 'series'
        };
      }
    } catch (error) {
      console.error(`OMDb lookup error for "${showName}":`, error);
    }
    
    // Check YouTube API
    try {
      const youtubeData = await youtubeService.getChannelData(showName);
      console.log(`YouTube lookup for "${showName}":`, youtubeData ? 'Found' : 'Not found');
      
      if (youtubeData) {
        results.youtube = {
          title: youtubeData.title || showName,
          description: getCleanYouTubeDescription(youtubeData.description || ''),
          subscriberCount: youtubeData.subscriberCount || 0,
          videoCount: youtubeData.videoCount || 0,
          viewCount: youtubeData.viewCount || 0,
          publishedAt: youtubeData.publishedAt || '',
          thumbnail: youtubeData.thumbnailUrl || ''
        };
      }
    } catch (error) {
      console.error(`YouTube lookup error for "${showName}":`, error);
    }
    
    res.json(results);
  } catch (error) {
    console.error('Error looking up show data:', error);
    res.status(500).json({ 
      message: 'Failed to look up show data', 
      error: error instanceof Error ? error.message : String(error) 
    });
  }
});

export { lookupRouter };
</file>

<file path="server/omdb.ts">
import fetch from 'node-fetch';

// Interface for OMDb response
export interface OmdbResponse {
  Title: string;
  Year: string;
  Rated: string;
  Released: string;
  Runtime: string;
  Genre: string;
  Director: string;
  Writer: string;
  Actors: string;
  Plot: string;
  Language: string;
  Country: string;
  Awards: string;
  Poster: string;
  Ratings: Array<{
    Source: string;
    Value: string;
  }>;
  Metascore: string;
  imdbRating: string;
  imdbVotes: string;
  imdbID: string;
  Type: string;
  totalSeasons: string;
  Response: string;
  Error?: string;
}

// Interface for data we want to store
export interface OmdbShowData {
  runtime: string;
  rated: string;
  totalSeasons: string;
  language: string;
  country: string;
  director: string;
  writer: string;
  imdbRating: string;
  awards: string;
  poster: string;
  imdbId: string;
  year: string; // Used for release_year and end_year
  plot: string; // Adding plot for descriptions
}

export class OmdbService {
  private apiKey: string;
  private baseUrl: string = 'http://www.omdbapi.com/';
  private cache: Map<string, OmdbShowData> = new Map();
  private cacheExpiry: Map<string, number> = new Map();
  private readonly CACHE_TTL = 24 * 60 * 60 * 1000; // 24 hours in milliseconds

  constructor() {
    const apiKey = process.env.OMDB_API_KEY;
    if (!apiKey) {
      throw new Error('OMDB_API_KEY environment variable is not set');
    }
    this.apiKey = apiKey;
  }

  async getShowData(title: string): Promise<OmdbShowData | null> {
    try {
      // Check cache first
      if (this.isInCache(title)) {
        console.log(`Using cached data for "${title}"`);
        return this.getFromCache(title);
      }

      console.log(`Fetching OMDb data for "${title}"`);
      const url = `${this.baseUrl}?t=${encodeURIComponent(title)}&type=series&apikey=${this.apiKey}&plot=full`;
      
      const response = await fetch(url);
      const data = await response.json() as OmdbResponse;
      
      if (data.Response === 'False') {
        console.warn(`OMDb API error for "${title}": ${data.Error}`);
        return null;
      }
      
      // Extract only the fields we need, filtering out "N/A" values
      const showData: OmdbShowData = {
        runtime: data.Runtime && data.Runtime !== 'N/A' ? data.Runtime : '',
        rated: data.Rated && data.Rated !== 'N/A' ? data.Rated : '',
        totalSeasons: data.totalSeasons && data.totalSeasons !== 'N/A' ? data.totalSeasons : '',
        language: data.Language && data.Language !== 'N/A' ? data.Language : '',
        country: data.Country && data.Country !== 'N/A' ? data.Country : '',
        director: data.Director && data.Director !== 'N/A' ? data.Director : '',
        writer: data.Writer && data.Writer !== 'N/A' ? data.Writer : '',
        imdbRating: data.imdbRating && data.imdbRating !== 'N/A' ? data.imdbRating : '',
        awards: data.Awards && data.Awards !== 'N/A' ? data.Awards : '',
        poster: data.Poster && data.Poster !== 'N/A' ? data.Poster : '',
        imdbId: data.imdbID || '',
        year: data.Year && data.Year !== 'N/A' ? data.Year : '',
        plot: data.Plot && data.Plot !== 'N/A' ? data.Plot : ''
      };
      
      // Store in cache
      this.addToCache(title, showData);
      
      return showData;
    } catch (error) {
      console.error(`Error fetching data from OMDb for "${title}":`, error);
      return null;
    }
  }

  private isInCache(title: string): boolean {
    const cacheKey = this.getCacheKey(title);
    const expiry = this.cacheExpiry.get(cacheKey);
    
    if (!expiry) return false;
    
    if (Date.now() > expiry) {
      // Cache expired
      this.cache.delete(cacheKey);
      this.cacheExpiry.delete(cacheKey);
      return false;
    }
    
    return this.cache.has(cacheKey);
  }

  private getFromCache(title: string): OmdbShowData | null {
    const cacheKey = this.getCacheKey(title);
    return this.cache.get(cacheKey) || null;
  }

  private addToCache(title: string, data: OmdbShowData): void {
    const cacheKey = this.getCacheKey(title);
    this.cache.set(cacheKey, data);
    this.cacheExpiry.set(cacheKey, Date.now() + this.CACHE_TTL);
  }

  private getCacheKey(title: string): string {
    return title.toLowerCase().trim();
  }
}

export const omdbService = new OmdbService();
</file>

<file path="server/replitAuth.ts">
import * as client from "openid-client";
import { Strategy, type VerifyFunction } from "openid-client/passport";

import passport from "passport";
import session from "express-session";
import type { Express, RequestHandler } from "express";
import memoize from "memoizee";
import connectPg from "connect-pg-simple";
import { storage } from "./storage";

if (!process.env.REPLIT_DOMAINS) {
  throw new Error("Environment variable REPLIT_DOMAINS not provided");
}

const getOidcConfig = memoize(
  async () => {
    return await client.discovery(
      new URL(process.env.ISSUER_URL ?? "https://replit.com/oidc"),
      process.env.REPL_ID!
    );
  },
  { maxAge: 3600 * 1000 }
);

export function getSession() {
  const sessionTtl = 7 * 24 * 60 * 60 * 1000; // 1 week
  const pgStore = connectPg(session);
  const sessionStore = new pgStore({
    conString: process.env.DATABASE_URL,
    createTableIfMissing: false,
    ttl: sessionTtl,
    tableName: "sessions",
  });
  return session({
    secret: process.env.SESSION_SECRET!,
    store: sessionStore,
    resave: false,
    saveUninitialized: false,
    cookie: {
      httpOnly: true,
      secure: true,
      maxAge: sessionTtl,
    },
  });
}

function updateUserSession(
  user: any,
  tokens: client.TokenEndpointResponse & client.TokenEndpointResponseHelpers
) {
  user.claims = tokens.claims();
  user.access_token = tokens.access_token;
  user.refresh_token = tokens.refresh_token;
  user.expires_at = user.claims?.exp;
}

async function upsertUser(
  claims: any,
) {
  await storage.upsertUser({
    id: claims["sub"],
    email: claims["email"],
    firstName: claims["first_name"],
    lastName: claims["last_name"],
    profileImageUrl: claims["profile_image_url"],
  });
}

export async function setupAuth(app: Express) {
  app.set("trust proxy", 1);
  app.use(getSession());
  app.use(passport.initialize());
  app.use(passport.session());

  const config = await getOidcConfig();

  const verify: VerifyFunction = async (
    tokens: client.TokenEndpointResponse & client.TokenEndpointResponseHelpers,
    verified: passport.AuthenticateCallback
  ) => {
    const user = {};
    updateUserSession(user, tokens);
    await upsertUser(tokens.claims());
    verified(null, user);
  };

  for (const domain of process.env
    .REPLIT_DOMAINS!.split(",")) {
    const strategy = new Strategy(
      {
        name: `replitauth:${domain}`,
        config,
        scope: "openid email profile offline_access",
        callbackURL: `https://${domain}/api/callback`,
      },
      verify,
    );
    passport.use(strategy);
  }

  passport.serializeUser((user: Express.User, cb) => cb(null, user));
  passport.deserializeUser((user: Express.User, cb) => cb(null, user));

  app.get("/api/login", (req, res, next) => {
    passport.authenticate(`replitauth:${req.hostname}`, {
      prompt: "login consent",
      scope: ["openid", "email", "profile", "offline_access"],
    })(req, res, next);
  });

  app.get("/api/callback", (req, res, next) => {
    passport.authenticate(`replitauth:${req.hostname}`, {
      successReturnToOrRedirect: "/",
      failureRedirect: "/api/login",
    })(req, res, next);
  });

  app.get("/api/logout", (req, res) => {
    req.logout(() => {
      res.redirect(
        client.buildEndSessionUrl(config, {
          client_id: process.env.REPL_ID!,
          post_logout_redirect_uri: `${req.protocol}://${req.hostname}`,
        }).href
      );
    });
  });
}

export const isAuthenticated: RequestHandler = async (req, res, next) => {
  const user = req.user as any;

  if (!req.isAuthenticated() || !user.expires_at) {
    return res.status(401).json({ message: "Unauthorized" });
  }

  const now = Math.floor(Date.now() / 1000);
  if (now <= user.expires_at) {
    return next();
  }

  const refreshToken = user.refresh_token;
  if (!refreshToken) {
    return res.redirect("/api/login");
  }

  try {
    const config = await getOidcConfig();
    const tokenResponse = await client.refreshTokenGrant(config, refreshToken);
    updateUserSession(user, tokenResponse);
    return next();
  } catch (error) {
    return res.redirect("/api/login");
  }
};
</file>

<file path="server/research-api.ts">
import { eq } from 'drizzle-orm';
import { db, pool } from './db';
import { researchSummaries, userReadResearch } from '@shared/schema';

export async function updateResearchSummary(id: number, data: any) {
  try {
    console.log(`Updating research summary ${id} with data:`, data);
    
    // Make sure to include the updated timestamp
    const updateData = {
      ...data,
      updatedAt: new Date()
    };
    
    // Update the research summary using direct SQL for reliability
    const result = await pool.query(
      `UPDATE research_summaries 
       SET title = COALESCE($1, title),
           summary = COALESCE($2, summary),
           full_text = COALESCE($3, full_text),
           category = COALESCE($4, category),
           image_url = COALESCE($5, image_url),
           source = COALESCE($6, source),
           original_url = COALESCE($7, original_url),
           published_date = COALESCE($8, published_date),
           headline = COALESCE($9, headline),
           sub_headline = COALESCE($10, sub_headline),
           key_findings = COALESCE($11, key_findings),
           updated_at = $12
       WHERE id = $13
       RETURNING *`,
      [
        data.title,
        data.summary,
        data.fullText,
        data.category,
        data.imageUrl,
        data.source,
        data.originalUrl,
        data.publishedDate,
        data.headline,
        data.subHeadline,
        data.keyFindings,
        updateData.updatedAt,
        id
      ]
    );
    
    if (result.rowCount === 0) {
      console.error(`No research summary found with id ${id}`);
      return null;
    }
    
    // Convert snake_case to camelCase for response
    const updatedSummary = {
      id: result.rows[0].id,
      title: result.rows[0].title,
      summary: result.rows[0].summary,
      fullText: result.rows[0].full_text,
      category: result.rows[0].category,
      imageUrl: result.rows[0].image_url,
      source: result.rows[0].source,
      originalUrl: result.rows[0].original_url,
      publishedDate: result.rows[0].published_date,
      headline: result.rows[0].headline,
      subHeadline: result.rows[0].sub_headline,
      keyFindings: result.rows[0].key_findings,
      createdAt: result.rows[0].created_at,
      updatedAt: result.rows[0].updated_at
    };
    
    return updatedSummary;
  } catch (error) {
    console.error('Error updating research summary:', error);
    throw error;
  }
}

export async function deleteResearchSummary(id: number) {
  try {
    console.log(`Deleting research summary ${id}`);
    
    // First delete any associated read records
    await pool.query('DELETE FROM user_read_research WHERE research_id = $1', [id]);
    
    // Then delete the research summary
    const result = await pool.query('DELETE FROM research_summaries WHERE id = $1 RETURNING id', [id]);
    
    return result.rowCount > 0;
  } catch (error) {
    console.error('Error deleting research summary:', error);
    throw error;
  }
}
</file>

<file path="server/simple-upload.ts">
import { Express, Request, Response } from 'express';
import multer from 'multer';
import fs from 'fs';
import path from 'path';

// Set up multer storage with disk storage
const diskStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    const uploadDir = './public/research';
    // Ensure directory exists
    if (!fs.existsSync(uploadDir)) {
      fs.mkdirSync(uploadDir, { recursive: true });
    }
    cb(null, uploadDir);
  },
  filename: (req, file, cb) => {
    const timestamp = Date.now();
    const safeName = file.originalname.replace(/\s+/g, '-');
    cb(null, `${timestamp}-${safeName}`);
  }
});

// Create multer instance with disk storage
const uploadMiddleware = multer({ 
  storage: diskStorage,
  limits: { fileSize: 5 * 1024 * 1024 } // 5MB limit
});

export function setupUploadRoutes(app: Express) {
  // Simple file upload endpoint
  app.post('/api/upload', uploadMiddleware.single('file'), (req, res) => {
    try {
      console.log('File upload request received');
      
      if (!req.file) {
        console.log('No file in the request');
        return res.status(400).json({ error: 'No file uploaded' });
      }
      
      // Return the URL to the uploaded file
      const fileUrl = `/research/${req.file.filename}`;
      console.log(`File uploaded successfully: ${fileUrl}`);
      
      return res.json({ url: fileUrl });
    } catch (error) {
      console.error('Upload error:', error);
      return res.status(500).json({ error: 'Upload failed' });
    }
  });
}
</file>

<file path="server/storage.ts">
import { 
  users, 
  type User, 
  type InsertUser, 
  type TvShow, 
  type TvShowReview, 
  type InsertTvShow, 
  type InsertTvShowReview, 
  type TvShowGitHub, 
  type TvShowSearch, 
  type InsertTvShowSearch, 
  type Favorite,
  type UserPointsHistory,
  type InsertUserPointsHistory,
  type ReviewUpvote,
  type InsertReviewUpvote,
  type ResearchSummary,
  type InsertResearchSummary,
  type UserReadResearch,
  type InsertUserReadResearch,
  type ShowSubmission,
  type InsertShowSubmission,
  type UserReferral,
  type InsertUserReferral
} from "@shared/schema";

export interface IStorage {
  // User methods
  getUser(id: string): Promise<User | undefined>;
  getUserByEmail(email: string): Promise<User | undefined>;
  getUserByUsername(username: string): Promise<User | undefined>;
  createUser(user: InsertUser): Promise<User>;
  upsertUser(user: Partial<User>): Promise<User>;
  
  // TV Shows methods
  getAllTvShows(): Promise<TvShow[]>;
  getTvShowById(id: number): Promise<TvShow | undefined>;
  getTvShowsByFilter(filters: { 
    ageGroup?: string; 
    ageRange?: {min: number, max: number};
    tantrumFactor?: string; 
    sortBy?: string; 
    search?: string;
    themes?: string[];
    themeMatchMode?: 'AND' | 'OR';
    interactionLevel?: string;
    dialogueIntensity?: string;
    soundFrequency?: string;
    stimulationScoreRange?: {min: number, max: number};
  }): Promise<TvShow[]>;
  addTvShow(show: InsertTvShow): Promise<TvShow>;
  updateTvShow(id: number, show: Partial<InsertTvShow>): Promise<TvShow | undefined>;
  deleteTvShow(id: number): Promise<boolean>;
  
  // Reviews methods
  getReviewsByTvShowId(tvShowId: number): Promise<TvShowReview[]>;
  addReview(review: InsertTvShowReview): Promise<TvShowReview>;
  getReviewById(reviewId: number): Promise<TvShowReview | undefined>;
  getReviewsByUserId(userId: string): Promise<TvShowReview[]>;
  
  // Review upvotes methods
  addUpvote(reviewId: number, userId: string): Promise<ReviewUpvote>;
  removeUpvote(reviewId: number, userId: string): Promise<boolean>;
  hasUserUpvotedReview(reviewId: number, userId: string): Promise<boolean>;
  getReviewUpvotes(reviewId: number): Promise<ReviewUpvote[]>;
  getUpvotesGivenByUser(userId: string): Promise<ReviewUpvote[]>;
  getUpvotesReceivedByUser(userId: string): Promise<ReviewUpvote[]>;
  
  // Search/Popularity tracking methods
  trackShowSearch(tvShowId: number): Promise<void>;
  trackShowView(tvShowId: number): Promise<void>;
  getPopularShows(limit?: number): Promise<TvShow[]>;
  
  // Import shows from GitHub data
  importShowsFromGitHub(shows: TvShowGitHub[]): Promise<TvShow[]>;
  
  // Favorites methods
  addFavorite(userId: string, tvShowId: number): Promise<Favorite>;
  removeFavorite(userId: string, tvShowId: number): Promise<boolean>;
  getUserFavorites(userId: string): Promise<TvShow[]>;
  isFavorite(userId: string, tvShowId: number): Promise<boolean>;
  getSimilarShows(userId: string, limit?: number): Promise<TvShow[]>;
  getSimilarShowsByShowId(showId: number, limit?: number): Promise<TvShow[]>;
  
  // Gamification methods
  
  // Points and activities
  getUserPoints(userId: string): Promise<{ 
    total: number; 
    breakdown: {
      reviews: number;
      upvotesGiven: number;
      upvotesReceived: number;
      consecutiveLogins: number;
      shares: number;
      referrals: number;
      showSubmissions: number;
      researchRead: number;
    }
  }>;
  awardPoints(userId: string, points: number, activityType: string, description?: string): Promise<UserPointsHistory>;
  getUserPointsHistory(userId: string): Promise<UserPointsHistory[]>;
  updateUserLoginStreak(userId: string): Promise<number>;
  
  // Review upvotes
  addReviewUpvote(userId: string, reviewId: number): Promise<ReviewUpvote>;
  removeReviewUpvote(userId: string, reviewId: number): Promise<boolean>;
  getReviewUpvotes(reviewId: number): Promise<ReviewUpvote[]>;
  hasUserUpvotedReview(userId: string, reviewId: number): Promise<boolean>;
  
  // Research summaries
  getResearchSummaries(): Promise<ResearchSummary[]>;
  getResearchSummary(id: number): Promise<ResearchSummary | undefined>;
  addResearchSummary(summary: InsertResearchSummary): Promise<ResearchSummary>;
  markResearchAsRead(userId: string, researchId: number): Promise<UserReadResearch>;
  getUserReadResearch(userId: string): Promise<ResearchSummary[]>;
  hasUserReadResearch(userId: string, researchId: number): Promise<boolean>;
  
  // Show submissions
  addShowSubmission(submission: InsertShowSubmission): Promise<ShowSubmission>;
  getUserShowSubmissions(userId: string): Promise<ShowSubmission[]>;
  getPendingShowSubmissions(): Promise<ShowSubmission[]>;
  updateShowSubmissionStatus(id: number, status: string): Promise<ShowSubmission>;
  
  // User referrals
  addUserReferral(referrerId: string, referredId: string): Promise<UserReferral>;
  getUserReferrals(userId: string): Promise<UserReferral[]>;
  
  // User leaderboard
  getTopUsers(limit?: number): Promise<User[]>;
}

export class MemStorage implements IStorage {
  private users: Map<string, User>;
  private tvShows: Map<number, TvShow>;
  private tvShowReviews: Map<number, TvShowReview>;
  private tvShowSearches: Map<number, TvShowSearch>;
  private tvShowCurrentId: number;
  private reviewCurrentId: number;
  private searchCurrentId: number;
  private userPointsHistoryId: number;
  private reviewUpvoteId: number;
  private researchSummaryId: number;
  private userReadResearchId: number;
  private showSubmissionId: number;
  private userReferralId: number;
  private userPointsHistories: Map<string, UserPointsHistory[]>;
  private reviewUpvotes: Map<number, ReviewUpvote[]>;
  private researchSummaries: Map<number, ResearchSummary>;
  private userReadResearch: Map<string, number[]>;
  private showSubmissions: Map<number, ShowSubmission>;
  private userReferrals: Map<string, UserReferral[]>;
  private favorites: Map<string, number[]>;

  constructor() {
    this.users = new Map();
    this.tvShows = new Map();
    this.tvShowReviews = new Map();
    this.tvShowSearches = new Map();
    this.tvShowCurrentId = 1;
    this.reviewCurrentId = 1;
    this.searchCurrentId = 1;
    this.userPointsHistoryId = 1;
    this.reviewUpvoteId = 1;
    this.researchSummaryId = 1;
    this.userReadResearchId = 1;
    this.showSubmissionId = 1;
    this.userReferralId = 1;
    this.userPointsHistories = new Map();
    this.reviewUpvotes = new Map();
    this.researchSummaries = new Map();
    this.userReadResearch = new Map();
    this.showSubmissions = new Map();
    this.userReferrals = new Map();
    this.favorites = new Map();
    
    // Create an admin test user for development
    // The password hash is generated using the hashPassword function in auth.ts
    // This is the hash for password: "admin123"
    const adminPasswordHash = "7f109fc73f0989b7f927a0b1348c95cc54354a624d321e0bc391a78e5d02be699e356821891ff6d8bbb4129e6f86d88a7460d69acdb060d79e9868447cee14f5.30095aeccc3401a9393d84557eaac61b";
    
    // Add an admin user for testing
    this.createUser({
      email: "admin@tvtantrum.com",
      password: adminPasswordHash,
      username: "admin",
      isAdmin: true
    }).then(user => {
      console.log("Created admin user with ID:", user.id);
      // Give admin some initial points to test gamification
      this.awardPoints(user.id, 100, "account_creation", "Initial points for admin account");
    });
  }

  // User methods
  async getUser(id: string): Promise<User | undefined> {
    return this.users.get(id);
  }
  
  async upsertUser(userData: Partial<User>): Promise<User> {
    if (!userData.id) {
      throw new Error("User ID is required for upsert operation");
    }
    
    const existingUser = await this.getUser(userData.id);
    
    if (existingUser) {
      // Update existing user
      const updatedUser: User = {
        ...existingUser,
        ...userData,
        updatedAt: new Date()
      };
      this.users.set(userData.id, updatedUser);
      return updatedUser;
    } else {
      // Create new user
      const newUser: User = {
        id: userData.id,
        email: userData.email || null,
        firstName: userData.firstName || null,
        lastName: userData.lastName || null,
        profileImageUrl: userData.profileImageUrl || null,
        username: userData.username || null,
        isAdmin: userData.isAdmin || false,
        country: userData.country || null,
        createdAt: new Date(),
        updatedAt: new Date(),
        isApproved: userData.isApproved || false,
        totalPoints: userData.totalPoints || 0,
        lastLoginDate: userData.lastLoginDate || null,
        profileBio: userData.profileBio || null,
        referralCode: userData.referralCode || null
      };
      this.users.set(newUser.id, newUser);
      return newUser;
    }
  }

  async getUserByEmail(email: string): Promise<User | undefined> {
    return Array.from(this.users.values()).find(
      (user) => user.email === email,
    );
  }

  async getUserByUsername(username: string): Promise<User | undefined> {
    return Array.from(this.users.values()).find(
      (user) => user.username === username,
    );
  }

  async createUser(insertUser: InsertUser): Promise<User> {
    // Generate a random UUID for the user ID
    const id = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
    
    const now = new Date();
    const user: User = { 
      id,
      email: insertUser.email,
      password: insertUser.password,
      firstName: insertUser.firstName || null,
      lastName: insertUser.lastName || null,
      profileImageUrl: insertUser.profileImageUrl || null,
      username: insertUser.username || null,
      isAdmin: insertUser.isAdmin ?? false,
      country: insertUser.country || null,
      createdAt: now,
      updatedAt: now,
      isApproved: insertUser.isApproved ?? false,
      totalPoints: 0,
      lastLoginDate: null,
      loginStreak: 0,
      rank: "TV Watcher",
      profileBio: null,
      referralCode: id.substring(0, 8)
    };
    this.users.set(id, user);
    return user;
  }

  // TV Shows methods
  async getAllTvShows(): Promise<TvShow[]> {
    return Array.from(this.tvShows.values());
  }

  async getTvShowById(id: number): Promise<TvShow | undefined> {
    return this.tvShows.get(id);
  }

  async getTvShowsByFilter(filters: { 
    ageGroup?: string; 
    tantrumFactor?: string; 
    sortBy?: string;
    search?: string;
    themes?: string[];
    interactionLevel?: string;
    dialogueIntensity?: string;
    soundFrequency?: string;
    stimulationScoreRange?: {min: number, max: number};
  }): Promise<TvShow[]> {
    let shows = Array.from(this.tvShows.values());
    
    // Filter by age group
    if (filters.ageGroup) {
      shows = shows.filter(show => {
        const [min, max] = filters.ageGroup!.split('-').map(Number);
        const [showMin, showMax] = show.ageRange.split('-').map(Number);
        
        // Check if there's any overlap between the filter range and the show's range
        return (showMin <= max && showMax >= min);
      });
    }
    
    // Filter by stimulation score (replacing tantrum factor)
    if (filters.tantrumFactor) {
      switch (filters.tantrumFactor) {
        case 'low':
          shows = shows.filter(show => show.stimulationScore <= 2); // Low stimulation
          break;
        case 'medium':
          shows = shows.filter(show => show.stimulationScore > 2 && show.stimulationScore <= 4); // Medium stimulation
          break;
        case 'high':
          shows = shows.filter(show => show.stimulationScore > 4); // High stimulation
          break;
      }
    }
    
    // Enhanced search by name with ranking and sorting
    if (filters.search) {
      console.log(`Storage: Processing search term: "${filters.search}"`);
      const searchTerm = filters.search.toLowerCase().trim();
      
      if (searchTerm.length > 0) {
        const preFilterCount = shows.length;
        
        // Instead of just filtering, we'll score each show and then sort by relevance
        interface ScoredShow {
          show: typeof shows[0];
          score: number;
          matchType: string;
        }
        
        // Calculate relevance score for each show
        const scoredShows: ScoredShow[] = shows.map(show => {
          const nameLower = show.name.toLowerCase();
          const descLower = show.description?.toLowerCase() || '';
          const themesLower = show.themes?.map(t => t.toLowerCase()) || [];
          
          // Default score and match type
          let score = 0;
          let matchType = 'none';
          
          // Exact match has highest score - if show name is exactly the search term
          if (nameLower === searchTerm) {
            score = 100;
            matchType = 'exact-match';
          }
          // Show name starts with the search term
          else if (nameLower.startsWith(searchTerm)) {
            score = 90;
            matchType = 'starts-with';
          }
          // Words in the show name start with the search term 
          else if (nameLower.split(/\s+/).some(word => word.startsWith(searchTerm))) {
            score = 80;
            matchType = 'word-starts-with';
          }
          // Direct match anywhere in the name
          else if (nameLower.includes(searchTerm)) {
            score = 70;
            matchType = 'name-contains';
          }
          // Show name without years contains search term
          else {
            const nameWithoutYears = nameLower.replace(/\s+\d{4}(-\d{4}|-present)?/g, '');
            if (nameWithoutYears.includes(searchTerm)) {
              score = 60;
              matchType = 'name-without-years';
            }
            // Words in the name include the search term
            else if (nameLower.split(/\s+/).some(word => word.includes(searchTerm))) {
              score = 50;
              matchType = 'word-contains';
            }
            // Description contains the search term
            else if (descLower.includes(searchTerm)) {
              score = 40;
              matchType = 'description';
            }
            // Themes contain the search term
            else if (themesLower.some(theme => theme.includes(searchTerm))) {
              score = 30;
              matchType = 'theme';
            }
            // Simplified name (no special chars) contains the search term
            else {
              const simplifiedName = nameLower.replace(/[''\.]/g, '');
              if (simplifiedName.includes(searchTerm)) {
                score = 20;
                matchType = 'simplified-name';
              }
            }
          }
          
          return { show, score, matchType };
        });
        
        // Filter out shows with no match (score = 0)
        const matchedShows = scoredShows.filter(item => item.score > 0);
        
        // Sort by score (highest first)
        matchedShows.sort((a, b) => b.score - a.score);
        
        // Extract just the shows from the scored results
        shows = matchedShows.map(item => item.show);
        
        console.log(`Storage: Search for "${searchTerm}" filtered ${preFilterCount} shows to ${shows.length} matches`);
        
        // Debug log for top matches
        if (shows.length > 0) {
          console.log(`Storage: First matches: ${shows.slice(0, 5).map(s => s.name).join(', ')}`);
          console.log(`Storage: Match types: ${matchedShows.slice(0, 5).map(s => s.matchType).join(', ')}`);
        }
      }
    }
    
    // Filter by themes
    if (filters.themes && filters.themes.length > 0) {
      shows = shows.filter(show => {
        // Convert both arrays to lowercase for case-insensitive comparison
        const showThemesLower = show.themes?.map(t => t.toLowerCase()) || [];
        const filterThemesLower = filters.themes!.map(t => t.toLowerCase());
        
        // Check if show has at least one of the selected themes
        return filterThemesLower.some(theme => 
          showThemesLower.some(showTheme => showTheme.includes(theme))
        );
      });
    }
    
    // Filter by interaction level
    if (filters.interactionLevel) {
      shows = shows.filter(show => 
        show.interactivityLevel === filters.interactionLevel || 
        filters.interactionLevel === 'Any'
      );
    }
    
    // Filter by dialogue intensity
    if (filters.dialogueIntensity) {
      shows = shows.filter(show => 
        show.dialogueIntensity === filters.dialogueIntensity || 
        filters.dialogueIntensity === 'Any'
      );
    }
    
    // Filter by sound frequency
    if (filters.soundFrequency) {
      shows = shows.filter(show => 
        show.soundEffectsLevel === filters.soundFrequency || 
        filters.soundFrequency === 'Any'
      );
    }
    
    // Filter by stimulation score range
    if (filters.stimulationScoreRange) {
      shows = shows.filter(show => 
        show.stimulationScore >= filters.stimulationScoreRange!.min && 
        show.stimulationScore <= filters.stimulationScoreRange!.max
      );
    }
    
    // Sort results
    if (filters.sortBy) {
      switch (filters.sortBy) {
        case 'name':
          shows.sort((a, b) => a.name.localeCompare(b.name));
          break;
        case 'stimulation-score':
          shows.sort((a, b) => a.stimulationScore - b.stimulationScore); // Lower is better
          break;
        case 'interactivity-level':
          // Sort by interactivity level - Low, Moderate, High
          shows.sort((a, b) => {
            const levelMap: {[key: string]: number} = {
              'Low': 1,
              'Moderate-Low': 2,
              'Moderate': 3,
              'Moderate-High': 4,
              'High': 5
            };
            const aLevel = levelMap[a.interactivityLevel || 'Moderate'] || 3;
            const bLevel = levelMap[b.interactivityLevel || 'Moderate'] || 3;
            return aLevel - bLevel;
          });
          break;
        case 'dialogue-intensity':
          // Sort by dialogue intensity
          shows.sort((a, b) => {
            const levelMap: {[key: string]: number} = {
              'Low': 1,
              'Moderate-Low': 2,
              'Moderate': 3,
              'Moderate-High': 4,
              'High': 5
            };
            const aLevel = levelMap[a.dialogueIntensity || 'Moderate'] || 3;
            const bLevel = levelMap[b.dialogueIntensity || 'Moderate'] || 3;
            return aLevel - bLevel;
          });
          break;
        case 'overall-rating':
          // Sort by stimulation score (inverse, since higher stimulation is more intense)
          shows.sort((a, b) => a.stimulationScore - b.stimulationScore);
          break;
      }
    }
    
    return shows;
  }

  async addTvShow(show: InsertTvShow): Promise<TvShow> {
    const id = this.tvShowCurrentId++;
    // Ensure all fields match the schema by explicitly setting null for undefined optional fields
    const processedShow = {
      ...show,
      creator: show.creator ?? null,
      releaseYear: show.releaseYear ?? null,
      endYear: show.endYear ?? null,
      isOngoing: show.isOngoing ?? true,
      imageUrl: show.imageUrl ?? null,
      availableOn: show.availableOn ?? [],
      creativityRating: show.creativityRating ?? null,
      interactivityLevel: show.interactivityLevel ?? null,
      dialogueIntensity: show.dialogueIntensity ?? null,
      soundEffectsLevel: show.soundEffectsLevel ?? null,
      musicTempo: show.musicTempo ?? null,
      totalMusicLevel: show.totalMusicLevel ?? null,
      totalSoundEffectTimeLevel: show.totalSoundEffectTimeLevel ?? null,
      sceneFrequency: show.sceneFrequency ?? null
    };
    
    // Use explicit casting to TvShow to handle any type issues
    const tvShow = { ...processedShow, id } as TvShow;
    this.tvShows.set(id, tvShow);
    return tvShow;
  }

  async updateTvShow(id: number, show: Partial<InsertTvShow>): Promise<TvShow | undefined> {
    const existingShow = this.tvShows.get(id);
    if (!existingShow) return undefined;
    
    const updatedShow: TvShow = { ...existingShow, ...show };
    this.tvShows.set(id, updatedShow);
    return updatedShow;
  }

  async deleteTvShow(id: number): Promise<boolean> {
    return this.tvShows.delete(id);
  }

  // Review methods
  async getReviewsByTvShowId(tvShowId: number): Promise<TvShowReview[]> {
    return Array.from(this.tvShowReviews.values())
      .filter(review => review.tvShowId === tvShowId);
  }
  
  async getReviewsByUserId(userId: number): Promise<TvShowReview[]> {
    return Array.from(this.tvShowReviews.values())
      .filter(review => review.userId === userId);
  }
  
  // Gamification methods
  async getUserPoints(userId: string): Promise<{ 
    total: number; 
    breakdown: {
      reviews: number;
      upvotesGiven: number;
      upvotesReceived: number;
      consecutiveLogins: number;
      shares: number;
      referrals: number;
      showSubmissions: number;
      researchRead: number;
    }
  }> {
    const user = await this.getUser(userId);
    if (!user) {
      throw new Error("User not found");
    }
    
    // Get all point history entries
    const pointsHistory = this.userPointsHistories.get(userId) || [];
    
    // Calculate breakdown
    const breakdown = {
      reviews: 0,
      upvotesGiven: 0,
      upvotesReceived: 0,
      consecutiveLogins: 0,
      shares: 0,
      referrals: 0,
      showSubmissions: 0,
      researchRead: 0
    };
    
    // Calculate points by activity type
    pointsHistory.forEach(entry => {
      switch (entry.activityType) {
        case 'review':
          breakdown.reviews += entry.points;
          break;
        case 'upvote_given':
          breakdown.upvotesGiven += entry.points;
          break;
        case 'upvote_received':
          breakdown.upvotesReceived += entry.points;
          break;
        case 'consecutive_login':
          breakdown.consecutiveLogins += entry.points;
          break;
        case 'share':
          breakdown.shares += entry.points;
          break;
        case 'referral':
          breakdown.referrals += entry.points;
          break;
        case 'show_submission':
          breakdown.showSubmissions += entry.points;
          break;
        case 'research_read':
          breakdown.researchRead += entry.points;
          break;
      }
    });
    
    return {
      total: user.totalPoints || 0,
      breakdown
    };
  }
  
  async awardPoints(userId: string, points: number, activityType: string, description?: string): Promise<UserPointsHistory> {
    const user = await this.getUser(userId);
    if (!user) {
      throw new Error("User not found");
    }
    
    // Create points history entry
    const pointsEntry: UserPointsHistory = {
      id: this.userPointsHistoryId++,
      userId,
      points,
      activityType,
      description: description || null,
      createdAt: new Date()
    };
    
    // Add to history
    if (!this.userPointsHistories.has(userId)) {
      this.userPointsHistories.set(userId, []);
    }
    this.userPointsHistories.get(userId)!.push(pointsEntry);
    
    // Update user total points
    const totalPoints = (user.totalPoints || 0) + points;
    await this.updateUserRank(userId, totalPoints);
    
    // Update user object
    await this.upsertUser({
      id: userId,
      totalPoints
    });
    
    return pointsEntry;
  }
  
  private async updateUserRank(userId: string, totalPoints: number): Promise<void> {
    let newRank = "TV Watcher";
    
    // Define rank thresholds
    if (totalPoints >= 1000) {
      newRank = "TV Expert";
    } else if (totalPoints >= 500) {
      newRank = "TV Enthusiast";
    } else if (totalPoints >= 200) {
      newRank = "TV Fan";
    } else if (totalPoints >= 50) {
      newRank = "TV Viewer";
    }
    
    // Update user rank if changed
    const user = await this.getUser(userId);
    if (user && user.rank !== newRank) {
      await this.upsertUser({
        id: userId,
        rank: newRank
      });
    }
  }
  
  async getUserPointsHistory(userId: string): Promise<UserPointsHistory[]> {
    return this.userPointsHistories.get(userId) || [];
  }
  
  async getUserFavorites(userId: number): Promise<any[]> {
    return [];
  }
  
  async getUserReadResearch(userId: number): Promise<any[]> {
    return [];
  }
  
  async getUserShowSubmissions(userId: number): Promise<any[]> {
    return [];
  }
  
  async updateUserLoginStreak(userId: string): Promise<number> {
    const user = await this.getUser(userId);
    if (!user) {
      throw new Error("User not found");
    }
    
    const now = new Date();
    const lastLogin = user.lastLoginDate;
    let streak = user.loginStreak || 0;
    let pointsAwarded = 0;
    
    if (lastLogin) {
      // Calculate days since last login
      const daysSinceLastLogin = Math.floor((now.getTime() - new Date(lastLogin).getTime()) / (1000 * 60 * 60 * 24));
      
      if (daysSinceLastLogin === 1) {
        // Consecutive login - increase streak
        streak += 1;
        
        // Award points based on streak
        if (streak % 7 === 0) {
          // Weekly bonus - 20 points
          pointsAwarded = 20;
          await this.awardPoints(userId, pointsAwarded, "consecutive_login", `Weekly login streak bonus: ${streak} days`);
        } else if (streak % 30 === 0) {
          // Monthly bonus - 50 points
          pointsAwarded = 50;
          await this.awardPoints(userId, pointsAwarded, "consecutive_login", `Monthly login streak bonus: ${streak} days`);
        } else {
          // Regular consecutive login - 5 points
          pointsAwarded = 5;
          await this.awardPoints(userId, pointsAwarded, "consecutive_login", `Daily login streak: ${streak} days`);
        }
      } else if (daysSinceLastLogin > 1) {
        // Streak broken
        streak = 1;
        pointsAwarded = 1;
        await this.awardPoints(userId, pointsAwarded, "consecutive_login", "Login streak reset - first day");
      }
    } else {
      // First login
      streak = 1;
      pointsAwarded = 1;
      await this.awardPoints(userId, pointsAwarded, "consecutive_login", "First login");
    }
    
    // Update user login data
    await this.upsertUser({
      id: userId,
      lastLoginDate: now,
      loginStreak: streak
    });
    
    return streak;
  }
  
  async getResearchSummaries(): Promise<any[]> {
    return [];
  }
  
  async getResearchSummary(id: number): Promise<any | null> {
    return null;
  }
  
  async hasUserReadResearch(userId: number, researchId: number): Promise<boolean> {
    return false;
  }
  
  async markResearchAsRead(userId: number, researchId: number): Promise<any> {
    return {};
  }
  
  async addResearchSummary(data: any): Promise<any> {
    return {};
  }
  
  async addReviewUpvote(userId: string, reviewId: number): Promise<ReviewUpvote> {
    // Check if review exists
    const review = Array.from(this.tvShowReviews.values()).find(r => r.id === reviewId);
    if (!review) {
      throw new Error("Review not found");
    }
    
    // Check if user has already upvoted
    const hasUpvoted = await this.hasUserUpvotedReview(userId, reviewId);
    if (hasUpvoted) {
      throw new Error("User has already upvoted this review");
    }
    
    // Create upvote
    const upvote: ReviewUpvote = {
      id: this.reviewUpvoteId++,
      userId,
      reviewId,
      createdAt: new Date()
    };
    
    // Add to storage
    if (!this.reviewUpvotes.has(reviewId)) {
      this.reviewUpvotes.set(reviewId, []);
    }
    this.reviewUpvotes.get(reviewId)!.push(upvote);
    
    // Award points to upvoter
    await this.awardPoints(userId, 1, "upvote_given", `Upvoted review #${reviewId}`);
    
    // Award points to review creator if they're different users
    if (review.userId !== userId) {
      await this.awardPoints(review.userId, 5, "upvote_received", `Received upvote on review #${reviewId}`);
    }
    
    return upvote;
  }
  
  async removeReviewUpvote(userId: string, reviewId: number): Promise<boolean> {
    // Check if review exists
    if (!this.reviewUpvotes.has(reviewId)) {
      return false;
    }
    
    // Get current upvotes
    const upvotes = this.reviewUpvotes.get(reviewId)!;
    const initialLength = upvotes.length;
    
    // Filter out the upvote to remove
    const filteredUpvotes = upvotes.filter(upvote => upvote.userId !== userId);
    
    // Update storage
    this.reviewUpvotes.set(reviewId, filteredUpvotes);
    
    // Return whether an upvote was removed
    return filteredUpvotes.length < initialLength;
  }
  
  async getReviewUpvotes(reviewId: number): Promise<ReviewUpvote[]> {
    return this.reviewUpvotes.get(reviewId) || [];
  }
  
  async hasUserUpvotedReview(userId: string, reviewId: number): Promise<boolean> {
    const upvotes = await this.getReviewUpvotes(reviewId);
    return upvotes.some(upvote => upvote.userId === userId);
  }
  
  async addShowSubmission(data: any): Promise<any> {
    return {};
  }
  
  async getPendingShowSubmissions(): Promise<any[]> {
    return [];
  }
  
  async updateShowSubmissionStatus(id: number, status: string): Promise<any> {
    return {};
  }
  
  async getTopUsers(limit: number = 10): Promise<User[]> {
    // Get all users
    const allUsers = Array.from(this.users.values());
    
    // Sort by total points (highest first)
    const sortedUsers = [...allUsers].sort((a, b) => 
      (b.totalPoints || 0) - (a.totalPoints || 0)
    );
    
    // Return top N users
    return sortedUsers.slice(0, limit);
  }

  async addReview(review: InsertTvShowReview): Promise<TvShowReview> {
    const id = this.reviewCurrentId++;
    const now = new Date().toISOString();
    const newReview: TvShowReview = { 
      ...review, 
      id,
      createdAt: now
    };
    this.tvShowReviews.set(id, newReview);
    return newReview;
  }
  
  // Search/Popularity tracking methods
  async trackShowSearch(tvShowId: number): Promise<void> {
    // Check if this show has been searched before
    const existingSearch = Array.from(this.tvShowSearches.values())
      .find(search => search.tvShowId === tvShowId);
    
    const now = new Date().toISOString();
    
    if (existingSearch) {
      // Increment the search count
      const updatedSearch: TvShowSearch = {
        ...existingSearch,
        searchCount: existingSearch.searchCount + 1,
        lastSearched: now,
        lastViewed: existingSearch.lastViewed
      };
      this.tvShowSearches.set(existingSearch.id, updatedSearch);
    } else {
      // Create a new search record
      const id = this.searchCurrentId++;
      const newSearch: TvShowSearch = {
        id,
        tvShowId,
        searchCount: 1,
        viewCount: 0,
        lastSearched: now,
        lastViewed: null
      };
      this.tvShowSearches.set(id, newSearch);
    }
  }
  
  async trackShowView(tvShowId: number): Promise<void> {
    // Check if this show has been viewed/searched before
    const existingSearch = Array.from(this.tvShowSearches.values())
      .find(search => search.tvShowId === tvShowId);
    
    const now = new Date().toISOString();
    
    if (existingSearch) {
      // Increment the view count
      const updatedSearch: TvShowSearch = {
        ...existingSearch,
        searchCount: existingSearch.searchCount,
        lastSearched: existingSearch.lastSearched
      };
      this.tvShowSearches.set(existingSearch.id, updatedSearch);
    } else {
      // Create a new record with search data
      const id = this.searchCurrentId++;
      const newSearch: TvShowSearch = {
        id,
        tvShowId,
        searchCount: 0,
        lastSearched: now
      };
      this.tvShowSearches.set(id, newSearch);
    }
  }
  
  async getPopularShows(limit: number = 10): Promise<TvShow[]> {
    // Get all search records
    const searches = Array.from(this.tvShowSearches.values());
    
    if (searches.length === 0) {
      // If no search data, return shows with lowest stimulation scores
      const allShows = Array.from(this.tvShows.values());
      return allShows
        .sort((a, b) => a.stimulationScore - b.stimulationScore)
        .slice(0, limit);
    }
    
    // Sort by popularity (combined search and view count)
    searches.sort((a, b) => {
      const scoreA = a.searchCount * 1 + a.viewCount * 2; // Views worth double
      const scoreB = b.searchCount * 1 + b.viewCount * 2;
      return scoreB - scoreA; // Higher score first
    });
    
    // Get the top N show IDs
    const topShowIds = searches
      .slice(0, Math.min(limit, searches.length))
      .map(search => search.tvShowId);
    
    // Get the actual show data for these IDs
    return topShowIds
      .map(id => this.tvShows.get(id))
      .filter(show => show !== undefined) as TvShow[];
  }

  // Import shows from GitHub data
  async importShowsFromGitHub(shows: TvShowGitHub[]): Promise<TvShow[]> {
    const importedShows: TvShow[] = [];
    
    // Clear existing shows to prevent duplicates
    // This is a temporary solution to fix duplicate data
    this.tvShows.clear();
    this.tvShowReviews.clear();
    this.tvShowCurrentId = 1;
    this.reviewCurrentId = 1;
    
    for (const show of shows) {
      // Lower stimulation score is better for calmness
      // We no longer need to calculate an overall rating as we use stimulation score directly
      
      // Extract episode length in minutes if available
      let episodeLength = 15; // Default
      if (show.avg_episode_length) {
        if (show.avg_episode_length.includes("Short")) {
          episodeLength = 5;
        } else if (show.avg_episode_length.includes("Medium")) {
          episodeLength = 15;
        } else if (show.avg_episode_length.includes("Long")) {
          episodeLength = 30;
        }
      }
      
      // Determine topic-specific ratings based on themes and other metrics
      const hasFriendshipTheme = show.themes.some(theme => 
        theme.toLowerCase().includes('friendship') || 
        theme.toLowerCase().includes('relationships'));
      
      const hasProblemSolvingTheme = show.themes.some(theme => 
        theme.toLowerCase().includes('problem solving') || 
        theme.toLowerCase().includes('critical thinking'));
      
      const hasRelatableTheme = show.themes.some(theme => 
        theme.toLowerCase().includes('relatable') || 
        theme.toLowerCase().includes('social') || 
        theme.toLowerCase().includes('life lessons'));
      
      const hasEmotionalIntelligenceTheme = show.themes.some(theme => 
        theme.toLowerCase().includes('emotional intelligence') || 
        theme.toLowerCase().includes('feelings'));
      
      const hasCreativeTheme = show.themes.some(theme => 
        theme.toLowerCase().includes('creativity') || 
        theme.toLowerCase().includes('imagination') ||
        theme.toLowerCase().includes('art'));
      
      const hasEducationalTheme = show.themes.some(theme => 
        theme.toLowerCase().includes('educational') || 
        theme.toLowerCase().includes('stem') || 
        theme.toLowerCase().includes('learning') || 
        theme.toLowerCase().includes('school'));
        
      // Create and add the TV show - using the metrics directly from GitHub data
      const tvShow = await this.addTvShow({
        name: show.title,
        description: `${show.title} is a ${show.animation_style} show for ${show.target_age_group} year olds. It features ${show.themes.join(", ")} themes.`,
        ageRange: show.target_age_group,
        episodeLength: episodeLength,
        creator: null,
        releaseYear: show.release_year || null,
        endYear: show.end_year || null,
        isOngoing: true,
        
        // Direct metrics from GitHub, normalizing "Very High" to "High"
        stimulationScore: show.stimulation_score,
        interactivityLevel: show.interactivity_level?.replace(/very high/i, "High"),
        dialogueIntensity: show.dialogue_intensity?.replace(/very high/i, "High"),
        soundEffectsLevel: show.sound_effects_level?.replace(/very high/i, "High"),
        musicTempo: show.music_tempo?.replace(/very high/i, "High"),
        totalMusicLevel: show.total_music_level?.replace(/very high/i, "High"),
        totalSoundEffectTimeLevel: show.total_sound_effect_time_level?.replace(/very high/i, "High"),
        sceneFrequency: show.scene_frequency?.replace(/very high/i, "High"),
        animationStyle: show.animation_style,
        themes: show.themes,
        
        // Topic-specific ratings based on themes
        friendshipRating: hasFriendshipTheme ? Math.floor(Math.random() * 2) + 3 : Math.floor(Math.random() * 3) + 1,
        problemSolvingRating: hasProblemSolvingTheme ? Math.floor(Math.random() * 2) + 3 : Math.floor(Math.random() * 3) + 1,
        relatableSituationsRating: hasRelatableTheme ? Math.floor(Math.random() * 2) + 3 : Math.floor(Math.random() * 3) + 1,
        emotionalIntelligenceRating: hasEmotionalIntelligenceTheme ? Math.floor(Math.random() * 2) + 3 : Math.floor(Math.random() * 3) + 1,
        creativityRating: hasCreativeTheme ? Math.floor(Math.random() * 2) + 3 : Math.floor(Math.random() * 3) + 1,
        educationalValueRating: hasEducationalTheme ? Math.floor(Math.random() * 2) + 3 : Math.floor(Math.random() * 3) + 1,
        
        // Derived fields
        availableOn: [show.platform],
        imageUrl: show.imageUrl ? show.imageUrl : null,
      });
      
      // Generate some sample reviews
      const reviewCount = Math.floor(Math.random() * 3) + 1; // 1-3 reviews
      for (let i = 0; i < reviewCount; i++) {
        const rating = Math.floor(Math.random() * 3) + 3; // 3-5 rating
        await this.addReview({
          tvShowId: tvShow.id,
          userName: `parent${i + 1}`,
          rating: rating,
          review: `My child ${rating >= 4 ? 'loves' : 'likes'} this show. ${show.themes[i % show.themes.length]} is their favorite part.`,
        });
      }
      
      importedShows.push(tvShow);
    }
    
    return importedShows;
  }
  
  // These methods are implemented in DatabaseStorage but need stubs here
  // Favorites methods
  async addFavorite(userId: string, tvShowId: number): Promise<Favorite> {
    const show = await this.getTvShowById(tvShowId);
    if (!show) {
      throw new Error("TV Show not found");
    }
    
    // Check if already favorited
    const isFav = await this.isFavorite(userId, tvShowId);
    if (isFav) {
      throw new Error("TV Show already in favorites");
    }
    
    // Add to favorites
    if (!this.favorites.has(userId)) {
      this.favorites.set(userId, []);
    }
    this.favorites.get(userId)!.push(tvShowId);
    
    // Create favorite record
    const favorite: Favorite = {
      id: Math.floor(Math.random() * 1000000), // Simple ID generation for in-memory storage
      userId,
      tvShowId,
      createdAt: new Date()
    };
    
    // Award points for the first favorite (only up to 10 favorites)
    const userFavorites = await this.getUserFavorites(userId);
    if (userFavorites.length <= 10) {
      await this.awardPoints(userId, 2, "add_favorite", `Added ${show.name} to favorites`);
    }
    
    return favorite;
  }
  
  async removeFavorite(userId: string, tvShowId: number): Promise<boolean> {
    if (!this.favorites.has(userId)) {
      return false;
    }
    
    const favorites = this.favorites.get(userId)!;
    const initialLength = favorites.length;
    
    // Filter out the favorite to remove
    const filteredFavorites = favorites.filter(id => id !== tvShowId);
    
    // Update storage
    this.favorites.set(userId, filteredFavorites);
    
    // Return whether a favorite was removed
    return filteredFavorites.length < initialLength;
  }
  
  async getUserFavorites(userId: string): Promise<TvShow[]> {
    const favoriteIds = this.favorites.get(userId) || [];
    const favorites: TvShow[] = [];
    
    // Get show details for each favorite ID
    for (const id of favoriteIds) {
      const show = await this.getTvShowById(id);
      if (show) {
        favorites.push(show);
      }
    }
    
    return favorites;
  }
  
  async isFavorite(userId: string, tvShowId: number): Promise<boolean> {
    const favoriteIds = this.favorites.get(userId) || [];
    return favoriteIds.includes(tvShowId);
  }
  
  async getSimilarShows(userId: string, limit: number = 5): Promise<TvShow[]> {
    // Get user's favorite shows
    const userFavorites = await this.getUserFavorites(userId);
    
    if (userFavorites.length === 0) {
      // If user has no favorites, return popular shows
      return this.getPopularShows(limit);
    }
    
    // Get all shows
    const allShows = await this.getAllTvShows();
    
    // Remove shows the user has already favorited
    const candidateShows = allShows.filter(show => 
      !userFavorites.some(fav => fav.id === show.id)
    );
    
    // Define a scoring function to measure similarity
    const scoreShow = (show: TvShow) => {
      let score = 0;
      
      // Compare each favorite with the candidate show
      userFavorites.forEach(favorite => {
        // Score based on matching age range
        if (favorite.ageRange === show.ageRange) {
          score += 2;
        }
        
        // Score based on similar stimulation score
        const stimDiff = Math.abs(favorite.stimulationScore - show.stimulationScore);
        if (stimDiff < 1) score += 3;
        else if (stimDiff < 2) score += 2;
        else if (stimDiff < 3) score += 1;
        
        // Score based on matching themes
        const favoriteThemes = favorite.themes || [];
        const showThemes = show.themes || [];
        
        const matchingThemes = favoriteThemes.filter(theme => 
          showThemes.includes(theme)
        ).length;
        
        score += matchingThemes * 1.5;
      });
      
      // Average the score by the number of favorites to normalize
      return score / userFavorites.length;
    };
    
    // Score and sort candidate shows
    interface ScoredShow {
      show: TvShow;
      score: number;
    }
    
    const scoredShows: ScoredShow[] = candidateShows.map(show => ({
      show,
      score: scoreShow(show)
    }));
    
    // Sort by score (highest first)
    scoredShows.sort((a, b) => b.score - a.score);
    
    // Return top N shows
    return scoredShows.slice(0, limit).map(item => item.show);
  }
  
  async getSimilarShowsByShowId(showId: number, limit: number = 4): Promise<TvShow[]> {
    // Get the show details
    const show = await this.getTvShowById(showId);
    if (!show) {
      console.log(`Show with ID ${showId} not found - can't find similar shows`);
      return [];
    }
    
    console.log(`Finding similar shows for ${show.name} (ID: ${showId}), stimulation: ${show.stimulationScore}, themes: ${show.themes?.join(', ')}`);
    
    // Get all shows except the current one
    const allShows = Array.from(this.tvShows.values()).filter(s => s.id !== showId);
    console.log(`Comparing against ${allShows.length} other shows`);
    
    // Calculate similarity score for each show based on:
    // 1. Similar stimulation score (+3 points if within 1 point difference)
    // 2. Similar themes (+2 points for each matching theme)
    // 3. Similar interactivity level (+2 points if same)
    // 4. Similar target age range (+1 point if overlapping)
    interface ScoredShow {
      show: TvShow;
      score: number;
    }
    
    const scoredShows: ScoredShow[] = allShows.map(otherShow => {
      let score = 0;
      
      // 1. Similar stimulation score
      if (Math.abs(otherShow.stimulationScore - show.stimulationScore) <= 1) {
        score += 3;
      }
      
      // 2. Similar themes
      if (show.themes && otherShow.themes) {
        const showThemesLower = show.themes.map(t => t.toLowerCase());
        const otherThemesLower = otherShow.themes.map(t => t.toLowerCase());
        
        // Count matching themes
        for (const theme of showThemesLower) {
          if (otherThemesLower.some(t => t.includes(theme) || theme.includes(t))) {
            score += 2;
          }
        }
      }
      
      // 3. Similar interactivity level
      if (show.interactivityLevel === otherShow.interactivityLevel) {
        score += 2;
      }
      
      // 4. Similar target age range
      if (show.ageRange && otherShow.ageRange) {
        const [showMin, showMax] = show.ageRange.split('-').map(Number);
        const [otherMin, otherMax] = otherShow.ageRange.split('-').map(Number);
        
        // Check for overlap in age ranges
        if (showMin <= otherMax && showMax >= otherMin) {
          score += 1;
        }
      }
      
      return { show: otherShow, score };
    });
    
    // Sort by similarity score (highest first)
    scoredShows.sort((a, b) => b.score - a.score);
    
    // Return the top N similar shows
    const result = scoredShows.slice(0, limit).map(item => item.show);
    
    // Log the results
    if (result.length === 0) {
      console.log(`No similar shows found for ${show.name} with score > 0`);
    } else {
      console.log(`Found ${result.length} similar shows for ${show.name}:`);
      result.forEach((s, i) => {
        console.log(`  ${i+1}. ${s.name} (ID: ${s.id}), score: ${scoredShows[i].score}`);
      });
    }
    
    return result;
  }
}

// For now, we're keeping the memory storage to maintain all current functionality
// We'll implement the database storage once we've fixed the schema issues
// import { DatabaseStorage } from './database-storage';

// Using in-memory storage for development
export const storage = new MemStorage();
</file>

<file path="server/upload-routes.ts">
import { Express, Request, Response } from "express";
import multer from 'multer';
import path from 'path';
import fs from 'fs';

// Setup memory storage for file uploads
const storage = multer.memoryStorage();

// Setup multer
const uploadMiddleware = multer({ 
  storage: storage,
  limits: {
    fileSize: 5 * 1024 * 1024 // 5MB limit
  }
});

export function registerUploadRoutes(app: Express) {
  // File upload endpoint for research images and other files
  app.post("/api/upload", uploadMiddleware.single('file'), async (req: Request, res: Response) => {
    try {
      console.log("Handling file upload request");
      
      // Check if file was uploaded
      if (!req.file) {
        console.log("No file found in request");
        return res.status(400).json({ message: "No file uploaded" });
      }

      // Get the folder from the form data or use default
      const folder = req.body.folder || 'uploads';
      
      // Generate a unique filename
      const uniqueFilename = `${Date.now()}-${req.file.originalname.replace(/\s+/g, '-')}`;
      
      // Save the file to the public folder with the unique name
      const targetDir = path.join(__dirname, '../public', folder);
      const targetPath = path.join(targetDir, uniqueFilename);
      
      // Ensure directory exists
      if (!fs.existsSync(targetDir)) {
        console.log(`Creating directory: ${targetDir}`);
        fs.mkdirSync(targetDir, { recursive: true });
      }
      
      // Write the file to disk
      fs.writeFileSync(targetPath, req.file.buffer);
      
      // Return the public URL
      const fileUrl = `/${folder}/${uniqueFilename}`;
      console.log(`File uploaded successfully: ${fileUrl}`);
      
      res.status(200).json({ 
        url: fileUrl,
        message: "File uploaded successfully" 
      });
    } catch (error) {
      console.error("Error uploading file:", error);
      res.status(500).json({ message: "Failed to upload file" });
    }
  });
}
</file>

<file path="server/url-shortener.ts">
import { db } from "./db";
import { shortUrls } from "@shared/schema";
import { eq, and, isNull } from "drizzle-orm";

/**
 * Generate a short, memorable code for URLs
 * Uses alphanumeric characters excluding confusing ones (0, O, I, l)
 */
function generateShortCode(length: number = 6): string {
  const chars = '23456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnpqrstuvwxyz';
  let result = '';
  for (let i = 0; i < length; i++) {
    result += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return result;
}

/**
 * Create a short URL for a show with optional user referral tracking
 */
export async function createShortUrl(
  showId: number, 
  userId?: number,
  originalUrl?: string
): Promise<{ shortCode: string; shortUrl: string } | null> {
  try {
    // Check if a short URL already exists for this show and user combination
    const existingQuery = userId 
      ? and(eq(shortUrls.userId, userId), eq(shortUrls.showId, showId))
      : and(eq(shortUrls.showId, showId), isNull(shortUrls.userId));
    
    const [existing] = await db
      .select()
      .from(shortUrls)
      .where(existingQuery)
      .limit(1);
    
    if (existing) {
      return {
        shortCode: existing.shortCode,
        shortUrl: `https://tvtantrum.com/s/${existing.shortCode}`
      };
    }

    // Generate a unique short code
    let shortCode: string;
    let attempts = 0;
    
    do {
      shortCode = generateShortCode();
      attempts++;
      
      // Check if code already exists
      const [duplicate] = await db
        .select()
        .from(shortUrls)
        .where(eq(shortUrls.shortCode, shortCode))
        .limit(1);
      
      if (!duplicate) break;
      
      if (attempts > 10) {
        // Use longer code if having collision issues
        shortCode = generateShortCode(8);
        break;
      }
    } while (attempts <= 10);

    // Create the original URL if not provided
    const baseUrl = process.env.REPLIT_DEV_DOMAIN || 'https://tvtantrum.app';
    const finalOriginalUrl = originalUrl || `${baseUrl}/share/${showId}${userId ? `?ref=${userId}` : ''}`;

    // Insert the new short URL
    const [created] = await db
      .insert(shortUrls)
      .values({
        shortCode: shortCode,
        originalUrl: finalOriginalUrl,
        showId: showId,
        userId: userId || null,
        clicks: 0
      })
      .returning();

    if (!created) {
      console.error('Failed to create short URL');
      return null;
    }

    return {
      shortCode: created.shortCode,
      shortUrl: `https://tvtantrum.com/s/${shortCode}`
    };
  } catch (error) {
    console.error('Error creating short URL:', error);
    return null;
  }
}

/**
 * Resolve a short code to its original URL and track the click
 */
export async function resolveShortUrl(shortCode: string): Promise<string | null> {
  try {
    const [shortUrl] = await db
      .select()
      .from(shortUrls)
      .where(eq(shortUrls.shortCode, shortCode))
      .limit(1);

    if (!shortUrl) {
      return null;
    }

    // Increment click counter
    await db
      .update(shortUrls)
      .set({ clicks: (shortUrl.clicks ?? 0) + 1 })
      .where(eq(shortUrls.id, shortUrl.id));

    return shortUrl.originalUrl;
  } catch (error) {
    console.error('Error resolving short URL:', error);
    return null;
  }
}

/**
 * Get analytics for a short URL
 */
export async function getShortUrlAnalytics(shortCode: string): Promise<any | null> {
  try {
    const [shortUrl] = await db
      .select()
      .from(shortUrls)
      .where(eq(shortUrls.shortCode, shortCode))
      .limit(1);

    return shortUrl || null;
  } catch (error) {
    console.error('Error getting short URL analytics:', error);
    return null;
  }
}
</file>

<file path="server/vite.ts">
import express, { type Express } from "express";
import fs from "fs";
import path from "path";
import { createServer as createViteServer, createLogger } from "vite";
import { type Server } from "http";
import viteConfig from "../vite.config";
import { nanoid } from "nanoid";

const viteLogger = createLogger();

export function log(message: string, source = "express") {
  const formattedTime = new Date().toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true,
  });

  console.log(`${formattedTime} [${source}] ${message}`);
}

export async function setupVite(app: Express, server: Server) {
  const serverOptions = {
    middlewareMode: true,
    hmr: { server },
    allowedHosts: true,
  };

  const vite = await createViteServer({
    ...viteConfig,
    configFile: false,
    customLogger: {
      ...viteLogger,
      error: (msg, options) => {
        viteLogger.error(msg, options);
        process.exit(1);
      },
    },
    server: serverOptions,
    appType: "custom",
  });

  app.use(vite.middlewares);
  app.use("*", async (req, res, next) => {
    const url = req.originalUrl;

    try {
      const clientTemplate = path.resolve(
        import.meta.dirname,
        "..",
        "client",
        "index.html",
      );

      // always reload the index.html file from disk incase it changes
      let template = await fs.promises.readFile(clientTemplate, "utf-8");
      template = template.replace(
        `src="/src/main.tsx"`,
        `src="/src/main.tsx?v=${nanoid()}"`,
      );
      const page = await vite.transformIndexHtml(url, template);
      res.status(200).set({ "Content-Type": "text/html" }).end(page);
    } catch (e) {
      vite.ssrFixStacktrace(e as Error);
      next(e);
    }
  });
}

export function serveStatic(app: Express) {
  const distPath = path.resolve(import.meta.dirname, "public");

  if (!fs.existsSync(distPath)) {
    throw new Error(
      `Could not find the build directory: ${distPath}, make sure to build the client first`,
    );
  }

  app.use(express.static(distPath));

  // fall through to index.html if the file doesn't exist
  app.use("*", (_req, res) => {
    res.sendFile(path.resolve(distPath, "index.html"));
  });
}
</file>

<file path="server/youtube.ts">
import fetch from 'node-fetch';

// Interface for YouTube API responses
export interface YouTubeChannelResponse {
  kind: string;
  etag: string;
  pageInfo: {
    totalResults: number;
    resultsPerPage: number;
  };
  items: YouTubeChannelItem[];
}

export interface YouTubeChannelItem {
  kind: string;
  etag: string;
  id: string;
  snippet: {
    title: string;
    description: string;
    customUrl: string;
    publishedAt: string;
    thumbnails: {
      default: { url: string; width: number; height: number };
      medium: { url: string; width: number; height: number };
      high: { url: string; width: number; height: number };
    };
    localized: {
      title: string;
      description: string;
    };
  };
  contentDetails?: {
    relatedPlaylists: {
      uploads: string;
    };
  };
  statistics?: {
    viewCount: string;
    subscriberCount: string;
    hiddenSubscriberCount: boolean;
    videoCount: string;
  };
}

// Interface for data we want to store
export interface YouTubeChannelData {
  title: string;
  description: string;
  publishedAt: string; // Can be used for releaseYear
  thumbnailUrl: string;
  subscriberCount: string;
  videoCount: string;
  channelId: string;
  isYouTubeChannel: boolean; // Flag to identify YouTube channels
}

/**
 * Service to interact with YouTube API
 */
class YouTubeService {
  private API_BASE_URL = 'https://www.googleapis.com/youtube/v3';
  private API_KEY = process.env.YOUTUBE_API_KEY;
  
  constructor() {
    // Validate API key is available
    if (!this.API_KEY) {
      console.warn('Warning: YOUTUBE_API_KEY environment variable is not set');
    }
  }
  
  /**
   * Search for a YouTube channel by name with flexible matching
   */
  async searchChannel(channelName: string): Promise<{id: string, title: string} | null> {
    try {
      // Don't attempt if API key is missing
      if (!this.API_KEY) {
        console.error('Cannot search YouTube: API key is missing');
        return null;
      }
      
      // Try different search queries for better matching chances
      const searchQueries = [
        channelName,                                   // Original show name
        `${channelName} official`,                     // Try official channel
        `${channelName} kids show`,                    // Specify kids content
        channelName.replace(/\s*\(\d{4}(-\d{4})?\)$/, '') // Remove year information
      ];
      
      // For kid shows, try some specific patterns
      if (channelName.toLowerCase().includes('&')) {
        // Try replacing & with 'and'
        searchQueries.push(channelName.replace(/&/g, 'and'));
      }
      
      // Try each search query until we find a match
      for (const query of searchQueries) {
        console.log(`Trying YouTube search query: "${query}"`);
        
        // Construct the search URL with more results to find better matches
        const searchUrl = `${this.API_BASE_URL}/search?part=snippet&q=${encodeURIComponent(query)}&type=channel&maxResults=3&key=${this.API_KEY}`;
        
        // Make the request
        const response = await fetch(searchUrl);
        const data: any = await response.json();
        
        // Check for errors
        if (data.error) {
          console.error('YouTube API Error:', data.error.message);
          continue; // Try next query
        }
        
        // Check if we got any results
        if (data.items && data.items.length > 0) {
          // Look for the best match among results
          for (const item of data.items) {
            const titleLower = item.snippet.title.toLowerCase();
            const channelLower = channelName.toLowerCase();
            
            // Simple fuzzy matching - check if the result contains major parts of our query
            // or if our query contains major parts of the result
            if (titleLower.includes(channelLower) || 
                channelLower.includes(titleLower) ||
                this.calculateSimilarity(titleLower, channelLower) > 0.5) {
              
              console.log(`Found YouTube channel match: ${item.snippet.title} for show "${channelName}"`);
              return {
                id: item.id.channelId,
                title: item.snippet.title
              };
            }
          }
        }
      }
      
      console.log(`No channel found for "${channelName}" after trying all search queries`);
      return null;
    } catch (error) {
      console.error(`Error searching YouTube for "${channelName}":`, error);
      return null;
    }
  }
  
  /**
   * Calculate text similarity between two strings
   * Simple implementation of Jaccard similarity using word sets
   */
  private calculateSimilarity(text1: string, text2: string): number {
    // Tokenize and create sets
    const words1 = new Set(text1.toLowerCase().split(/\W+/).filter(w => w.length > 2));
    const words2 = new Set(text2.toLowerCase().split(/\W+/).filter(w => w.length > 2));
    
    // Calculate intersection and union
    const intersection = new Set([...words1].filter(x => words2.has(x)));
    const union = new Set([...words1, ...words2]);
    
    // Jaccard similarity coefficient
    return union.size === 0 ? 0 : intersection.size / union.size;
  }
  
  /**
   * Get detailed information about a YouTube channel
   */
  async getChannelDetails(channelId: string): Promise<YouTubeChannelData | null> {
    try {
      // Don't attempt if API key is missing
      if (!this.API_KEY) {
        console.error('Cannot get YouTube channel: API key is missing');
        return null;
      }
      
      // Construct the channel URL
      const channelUrl = `${this.API_BASE_URL}/channels?part=snippet,statistics&id=${channelId}&key=${this.API_KEY}`;
      
      // Make the request
      const response = await fetch(channelUrl);
      const data: any = await response.json();
      
      // Check for errors
      if (data.error) {
        console.error('YouTube API Error:', data.error.message);
        return null;
      }
      
      // Check if we got any results
      if (!data.items || data.items.length === 0) {
        console.log(`No details found for channel ID: ${channelId}`);
        return null;
      }
      
      // Extract the data we want to store
      const channelData: YouTubeChannelData = {
        title: data.items[0].snippet.title,
        description: data.items[0].snippet.description,
        publishedAt: data.items[0].snippet.publishedAt,
        thumbnailUrl: data.items[0].snippet.thumbnails.high?.url || '',
        subscriberCount: data.items[0].statistics?.subscriberCount || '0',
        videoCount: data.items[0].statistics?.videoCount || '0',
        channelId: channelId,
        isYouTubeChannel: true
      };
      
      return channelData;
    } catch (error) {
      console.error(`Error fetching YouTube channel ${channelId}:`, error);
      return null;
    }
  }
  
  /**
   * Complete flow to get channel data by name:
   * 1. Search for channel by name
   * 2. Get detailed information about the channel
   */
  async getChannelData(channelName: string): Promise<YouTubeChannelData | null> {
    // Search for the channel first
    const searchResult = await this.searchChannel(channelName);
    
    if (!searchResult) {
      return null;
    }
    
    // Get detailed information
    return await this.getChannelDetails(searchResult.id);
  }
}

// Extract release year from publishedAt date
export function extractYouTubeReleaseYear(publishedAt: string | null): number | null {
  if (!publishedAt) return null;
  
  try {
    const date = new Date(publishedAt);
    return date.getFullYear();
  } catch (error) {
    console.error('Error parsing publishedAt date:', error);
    return null;
  }
}

// Extract a good description for our database from YouTube data
export function getCleanDescription(description: string): string {
  if (!description) return '';
  
  // Remove common YouTube channel boilerplate
  let cleanDesc = description
    .replace(/subscribe to our channel/gi, '')
    .replace(/follow us on/gi, '')
    .replace(/check out our website/gi, '')
    .replace(/click the bell/gi, '')
    .replace(/http(s)?:\/\/[^\s]+/g, '') // Remove URLs
    .replace(/\n\s*\n/g, '\n') // Remove extra newlines
    .trim();
    
  // If description is too long, trim it
  if (cleanDesc.length > 500) {
    cleanDesc = cleanDesc.substring(0, 500) + '...';
  }
  
  return cleanDesc || '';
}

// Create and export a singleton instance
export const youtubeService = new YouTubeService();
</file>

<file path="shared/updated-schema.ts">
import { pgTable, text, serial, integer, boolean, jsonb, timestamp, primaryKey } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";

// --- User-related tables ---

export const users = pgTable("users", {
  id: serial("id").primaryKey(),
  email: text("email").notNull().unique(),
  password: text("password").notNull(),
  isAdmin: boolean("is_admin").default(false),
  username: text("username").notNull(),
  country: text("country"),
  createdAt: timestamp("created_at").notNull().defaultNow(),
  isApproved: boolean("is_approved").default(false),
});

export const insertUserSchema = createInsertSchema(users).pick({
  email: true,
  password: true,
  username: true,
  country: true,
  isAdmin: true,
  isApproved: true,
});

// --- Favorites table ---

export const favorites = pgTable("favorites", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull().references(() => users.id, { onDelete: 'cascade' }),
  tvShowId: integer("tv_show_id").notNull().references(() => tvShows.id, { onDelete: 'cascade' }),
  createdAt: timestamp("created_at").notNull().defaultNow(),
});

export const insertFavoriteSchema = createInsertSchema(favorites).omit({
  id: true,
  createdAt: true,
});

// --- Core TV Shows Schema ---

export const tvShows = pgTable("tv_shows", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(),
  description: text("description").notNull(),
  ageRange: text("age_range").notNull(),
  episodeLength: integer("episode_length").notNull(), // in minutes
  creator: text("creator"),
  releaseYear: integer("release_year"),
  endYear: integer("end_year"),
  isOngoing: boolean("is_ongoing").default(true),
  
  // Number of seasons
  seasons: integer("seasons"),
  
  // Core metrics from GitHub data
  stimulationScore: integer("stimulation_score").notNull(), // Direct from GitHub data
  interactivityLevel: text("interactivity_level"),
  dialogueIntensity: text("dialogue_intensity"), 
  soundEffectsLevel: text("sound_effects_level"),
  musicTempo: text("music_tempo"),
  totalMusicLevel: text("total_music_level"),
  totalSoundEffectTimeLevel: text("total_sound_effect_time_level"),
  sceneFrequency: text("scene_frequency"),
  
  // We're keeping creativity_rating but removing other specialized ratings
  creativityRating: integer("creativity_rating"),
  
  // We keep these temporarily for backward compatibility
  // They'll be replaced by junction tables
  availableOn: text("available_on").array(),
  themes: text("themes").array(),
  
  // Other fields
  animationStyle: text("animation_style"),
  imageUrl: text("image_url"),
  
  // YouTube-specific fields - will eventually be moved to youtube_channels table
  // Keeping temporarily for backward compatibility
  subscriberCount: text("subscriber_count"),
  videoCount: text("video_count"),
  channelId: text("channel_id"),
  isYouTubeChannel: boolean("is_youtube_channel").default(false),
  publishedAt: text("published_at"),
  
  // API data tracking
  hasOmdbData: boolean("has_omdb_data").default(false),
  hasYoutubeData: boolean("has_youtube_data").default(false),
});

// --- YouTube-specific table ---

export const youtubeChannels = pgTable("youtube_channels", {
  id: serial("id").primaryKey(),
  tvShowId: integer("tv_show_id").notNull().references(() => tvShows.id, { onDelete: 'cascade' }).unique(),
  channelId: text("channel_id"),
  subscriberCount: text("subscriber_count"),
  videoCount: text("video_count"),
  publishedAt: text("published_at"),
});

// --- Theme and Platform tables ---

export const themes = pgTable("themes", {
  id: serial("id").primaryKey(),
  name: text("name").notNull().unique(),
});

export const platforms = pgTable("platforms", {
  id: serial("id").primaryKey(),
  name: text("name").notNull().unique(),
});

// --- Junction tables ---

export const tvShowThemes = pgTable("tv_show_themes", {
  id: serial("id").primaryKey(),
  tvShowId: integer("tv_show_id").notNull().references(() => tvShows.id, { onDelete: 'cascade' }),
  themeId: integer("theme_id").notNull().references(() => themes.id, { onDelete: 'cascade' }),
}, (t) => ({
  unq: primaryKey({ columns: [t.tvShowId, t.themeId] }),
}));

export const tvShowPlatforms = pgTable("tv_show_platforms", {
  id: serial("id").primaryKey(),
  tvShowId: integer("tv_show_id").notNull().references(() => tvShows.id, { onDelete: 'cascade' }),
  platformId: integer("platform_id").notNull().references(() => platforms.id, { onDelete: 'cascade' }),
}, (t) => ({
  unq: primaryKey({ columns: [t.tvShowId, t.platformId] }),
}));

// --- Reviews table ---

export const tvShowReviews = pgTable("tv_show_reviews", {
  id: serial("id").primaryKey(),
  tvShowId: integer("tv_show_id").notNull().references(() => tvShows.id, { onDelete: 'cascade' }),
  userId: integer("user_id").references(() => users.id, { onDelete: 'set null' }),
  userName: text("user_name").notNull(),
  rating: integer("rating").notNull(), // 1-5 scale
  review: text("review").notNull(),
  showName: text("show_name"),
  createdAt: timestamp("created_at").notNull().defaultNow(),
});

// --- Analytics tables ---

export const tvShowSearches = pgTable("tv_show_searches", {
  id: serial("id").primaryKey(),
  tvShowId: integer("tv_show_id").notNull().references(() => tvShows.id, { onDelete: 'cascade' }),
  searchCount: integer("search_count").notNull().default(1),
  lastSearched: timestamp("last_searched").notNull().defaultNow(),
});

export const tvShowViews = pgTable("tv_show_views", {
  id: serial("id").primaryKey(),
  tvShowId: integer("tv_show_id").notNull().references(() => tvShows.id, { onDelete: 'cascade' }),
  viewCount: integer("view_count").notNull().default(1),
  lastViewed: timestamp("last_viewed").notNull().defaultNow(),
});

// --- Zod schemas for inserting/selecting ---

export const insertTvShowSchema = createInsertSchema(tvShows).omit({
  id: true,
});

export const insertTvShowReviewSchema = createInsertSchema(tvShowReviews).omit({
  id: true,
  createdAt: true,
});

export const insertTvShowSearchSchema = createInsertSchema(tvShowSearches).omit({
  id: true,
  lastSearched: true,
});

export const insertTvShowViewSchema = createInsertSchema(tvShowViews).omit({
  id: true,
  lastViewed: true, 
});

export const insertYoutubeChannelSchema = createInsertSchema(youtubeChannels).omit({
  id: true,
});

export const insertThemeSchema = createInsertSchema(themes).omit({
  id: true,
});

export const insertPlatformSchema = createInsertSchema(platforms).omit({
  id: true,
});

export const insertTvShowThemeSchema = createInsertSchema(tvShowThemes).omit({
  id: true,
});

export const insertTvShowPlatformSchema = createInsertSchema(tvShowPlatforms).omit({
  id: true,
});

// --- TypeScript types for database entities ---

export type InsertUser = z.infer<typeof insertUserSchema>;
export type User = typeof users.$inferSelect;

export type InsertFavorite = z.infer<typeof insertFavoriteSchema>;
export type Favorite = typeof favorites.$inferSelect;

export type InsertTvShow = z.infer<typeof insertTvShowSchema>;
export type TvShow = typeof tvShows.$inferSelect;

export type InsertTvShowReview = z.infer<typeof insertTvShowReviewSchema>;
export type TvShowReview = typeof tvShowReviews.$inferSelect;

export type InsertTvShowSearch = z.infer<typeof insertTvShowSearchSchema>;
export type TvShowSearch = typeof tvShowSearches.$inferSelect;

export type InsertTvShowView = z.infer<typeof insertTvShowViewSchema>;
export type TvShowView = typeof tvShowViews.$inferSelect;

export type InsertYoutubeChannel = z.infer<typeof insertYoutubeChannelSchema>;
export type YoutubeChannel = typeof youtubeChannels.$inferSelect;

export type InsertTheme = z.infer<typeof insertThemeSchema>;
export type Theme = typeof themes.$inferSelect;

export type InsertPlatform = z.infer<typeof insertPlatformSchema>;
export type Platform = typeof platforms.$inferSelect;

export type InsertTvShowTheme = z.infer<typeof insertTvShowThemeSchema>;
export type TvShowTheme = typeof tvShowThemes.$inferSelect;

export type InsertTvShowPlatform = z.infer<typeof insertTvShowPlatformSchema>;
export type TvShowPlatform = typeof tvShowPlatforms.$inferSelect;

// --- GitHub show format based on actual data structure ---
export const tvShowGitHubSchema = z.object({
  title: z.string(),
  stimulation_score: z.number(),
  platform: z.string(),
  target_age_group: z.string(),
  seasons: z.string().nullable(),
  avg_episode_length: z.string().nullable(),
  themes: z.array(z.string()),
  interactivity_level: z.string(),
  animation_style: z.string(),
  dialogue_intensity: z.string(),
  sound_effects_level: z.string(),
  music_tempo: z.string(),
  total_music_level: z.string(),
  total_sound_effect_time_level: z.string(),
  scene_frequency: z.string(),
  image_filename: z.string(),
  release_year: z.number().optional(),
  end_year: z.number().optional(),
  // We'll add these derived fields for our application
  id: z.number().optional().default(() => Math.floor(Math.random() * 10000)),
  imageUrl: z.string().optional(),
});

export type TvShowGitHub = z.infer<typeof tvShowGitHubSchema>;
</file>

<file path="api-data-updater.js">
/**
 * Consolidated API Data Update Utility
 * 
 * This script replaces multiple overlapping API update scripts:
 * - update-api-data.js
 * - update-all-shows-api-data.js
 * - update-youtube-metadata.js
 * 
 * Features:
 * - Updates TV show data from OMDb and YouTube APIs
 * - Preserves custom images when updating data
 * - Keeps track of which shows have API data
 * - Handles both traditional TV shows and YouTube channels
 * - Maintains semantic integrity of sensory details
 */

import { Pool } from 'pg';
import { omdbService } from './server/omdb.js';
import { youtubeService } from './server/youtube.js';
import dotenv from 'dotenv';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get __dirname equivalent in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

dotenv.config();

// Database connection
const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
});

// File paths for custom data
const customImageMapPath = path.join(__dirname, 'data', 'custom-image-map.json');
const customShowDetailsPath = path.join(__dirname, 'data', 'custom-show-details.json');

/**
 * Load the custom image map from file
 */
function loadCustomImageMap() {
  try {
    if (fs.existsSync(customImageMapPath)) {
      const data = fs.readFileSync(customImageMapPath, 'utf8');
      return JSON.parse(data);
    }
    return {};
  } catch (error) {
    console.error('Error loading custom image map:', error);
    return {};
  }
}

/**
 * Load custom show details from file
 */
function loadCustomShowDetails() {
  try {
    if (fs.existsSync(customShowDetailsPath)) {
      const data = fs.readFileSync(customShowDetailsPath, 'utf8');
      return JSON.parse(data);
    }
    return {};
  } catch (error) {
    console.error('Error loading custom show details:', error);
    return {};
  }
}

/**
 * Helper function to extract release year from YouTube publishedAt date
 */
function extractYouTubeReleaseYear(publishedAt) {
  if (!publishedAt) return null;
  try {
    return parseInt(publishedAt.substring(0, 4), 10);
  } catch (error) {
    console.error('Error extracting YouTube release year:', error);
    return null;
  }
}

/**
 * Helper function to clean up YouTube description text
 */
function getCleanDescription(description) {
  if (!description) return '';
  
  return description
    .replace(/Follow us on social media:[\s\S]*?(?=\n\n|$)/, '')
    .replace(/Subscribe to our channel:[\s\S]*?(?=\n\n|$)/, '')
    .replace(/Visit our website:[\s\S]*?(?=\n\n|$)/, '')
    .replace(/\bhttps?:\/\/\S+\b/g, '')  // Remove URLs
    .replace(/\n{3,}/g, '\n\n')          // Normalize line breaks
    .replace(/\s{2,}/g, ' ')             // Normalize spaces
    .trim();
}

/**
 * Update a TV show with API data
 */
async function updateShowWithApiData(show) {
  try {
    const customImageMap = loadCustomImageMap();
    const customShowDetails = loadCustomShowDetails();
    
    console.log(`\nProcessing show: ${show.name} (ID: ${show.id})`);
    
    let updatedFields = {};
    let dataSource = null;
    
    // Try OMDb API first (for traditional TV shows)
    try {
      // If it's a YouTube channel, skip OMDb lookup
      if (show.is_youtube_channel) {
        console.log(`Skipping OMDb lookup for YouTube channel: ${show.name}`);
      } else {
        // Try to find on OMDb
        const omdbData = await omdbService.searchShow(show.name);
        
        if (omdbData) {
          console.log(`OMDb data found for "${show.name}"`);
          dataSource = 'omdb';
          
          // Build updated fields
          updatedFields = {
            ...updatedFields,
            description: omdbData.plot || show.description,
            releaseYear: omdbData.year ? parseInt(omdbData.year, 10) : show.release_year,
            creator: omdbData.director || show.creator,
            hasOmdbData: true
          };
          
          // Only update image if we don't have a custom image
          const hasCustomImage = customImageMap[show.id] || 
                               (show.image_url && !show.image_url.includes('m.media-amazon.com'));
          
          if (!hasCustomImage && omdbData.poster && omdbData.poster !== 'N/A') {
            updatedFields.imageUrl = omdbData.poster;
          }
        }
      }
    } catch (omdbError) {
      console.error(`OMDb API error for "${show.name}":`, omdbError.message);
    }
    
    // Try YouTube API for YouTube channels or as fallback
    try {
      // Is it a YouTube channel or should we try as fallback?
      if (show.is_youtube_channel || (show.name.toLowerCase().includes('youtube') && !dataSource)) {
        const youtubeData = await youtubeService.searchChannel(show.name);
        
        if (youtubeData) {
          console.log(`YouTube data found for "${show.name}"`);
          dataSource = dataSource || 'youtube';
          
          // Extract clean description
          const cleanDescription = getCleanDescription(youtubeData.description);
          
          // Extract release year
          const releaseYear = extractYouTubeReleaseYear(youtubeData.publishedAt);
          
          // Only update description if we don't have one from OMDb
          if (!updatedFields.description || updatedFields.description === show.description) {
            updatedFields.description = cleanDescription || show.description;
          }
          
          // Update YouTube-specific fields
          updatedFields = {
            ...updatedFields,
            isYouTubeChannel: true,
            channelId: youtubeData.channelId,
            subscriberCount: youtubeData.subscriberCount,
            videoCount: youtubeData.videoCount,
            publishedAt: youtubeData.publishedAt,
            releaseYear: updatedFields.releaseYear || releaseYear || show.release_year,
            hasYoutubeData: true
          };
          
          // Only update image if we don't have one from OMDb or custom
          const hasImage = updatedFields.imageUrl || 
                          customImageMap[show.id] ||
                          (show.image_url && !show.image_url.includes('yt3.ggpht.com'));
          
          if (!hasImage && youtubeData.thumbnailUrl) {
            updatedFields.imageUrl = youtubeData.thumbnailUrl;
          }
        }
      }
    } catch (youtubeError) {
      console.error(`YouTube API error for "${show.name}":`, youtubeError.message);
    }
    
    // If we found data, update the database
    if (Object.keys(updatedFields).length > 0) {
      // Never overwrite custom show details
      if (customShowDetails[show.id]) {
        // Keep sensory metrics from custom data
        const customData = customShowDetails[show.id];
        for (const key of ['stimulationScore', 'interactivityLevel', 'dialogueIntensity', 
                          'soundEffectsLevel', 'musicTempo', 'totalMusicLevel', 
                          'sceneFrequency', 'animationStyle']) {
          if (customData[key]) {
            delete updatedFields[key];
          }
        }
      }
      
      // Build SQL update query
      const updateFields = Object.keys(updatedFields)
        .map((key, i) => {
          // Convert camelCase to snake_case for database
          const dbField = key.replace(/([A-Z])/g, '_$1').toLowerCase();
          return `${dbField} = $${i + 1}`;
        })
        .join(', ');
      
      const updateValues = Object.values(updatedFields);
      const query = `
        UPDATE tv_shows
        SET ${updateFields}
        WHERE id = $${updateValues.length + 1}
        RETURNING id, name
      `;
      
      // Add the show ID as the last parameter
      updateValues.push(show.id);
      
      try {
        const result = await pool.query(query, updateValues);
        if (result.rowCount > 0) {
          console.log(`✅ Updated "${show.name}" with ${dataSource} data`);
          return { success: true, source: dataSource };
        } else {
          console.error(`❌ Failed to update "${show.name}" in database`);
          return { success: false };
        }
      } catch (dbError) {
        console.error(`Database error updating "${show.name}":`, dbError.message);
        return { success: false, error: dbError.message };
      }
    } else {
      console.log(`No API data found for "${show.name}"`);
      return { success: false, reason: 'no_data_found' };
    }
  } catch (error) {
    console.error(`Error processing show "${show.name}":`, error.message);
    return { success: false, error: error.message };
  }
}

/**
 * Main function to process all shows
 */
async function updateAllShowsApiData() {
  try {
    console.log('Starting API data update process...');
    
    // Get all TV shows from database
    const result = await pool.query('SELECT * FROM tv_shows ORDER BY name');
    const shows = result.rows;
    
    console.log(`Found ${shows.length} shows to process`);
    
    // Statistics
    let updated = 0;
    let failed = 0;
    let skipped = 0;
    let omdbCount = 0;
    let youtubeCount = 0;
    
    // Process each show with both APIs
    for (const show of shows) {
      const updateResult = await updateShowWithApiData(show);
      
      if (updateResult.success) {
        updated++;
        if (updateResult.source === 'omdb') omdbCount++;
        if (updateResult.source === 'youtube') youtubeCount++;
      } else if (updateResult.reason === 'no_data_found') {
        skipped++;
      } else {
        failed++;
      }
      
      // Add a small delay to avoid API rate limits
      await new Promise(resolve => setTimeout(resolve, 500));
    }
    
    // Final statistics
    console.log('\nAPI data update complete:');
    console.log(`✅ Updated: ${updated} shows`);
    console.log(`⏭️ Skipped: ${skipped} shows (no data found)`);
    console.log(`❌ Failed: ${failed} shows`);
    console.log('\nData sources:');
    console.log(`📺 OMDb: ${omdbCount} shows`);
    console.log(`📱 YouTube: ${youtubeCount} shows`);
    console.log(`📊 Total processed: ${shows.length} shows`);
    
  } catch (error) {
    console.error('Fatal error in API data update process:', error);
  } finally {
    // Close database connection
    await pool.end();
  }
}

/**
 * Update only YouTube shows
 */
async function updateYouTubeShows() {
  try {
    console.log('Starting YouTube-specific update process...');
    
    // Get only YouTube shows/channels
    const result = await pool.query(`
      SELECT * FROM tv_shows 
      WHERE is_youtube_channel = true
      OR name ILIKE '%youtube%'
      ORDER BY name
    `);
    
    const shows = result.rows;
    console.log(`Found ${shows.length} potential YouTube shows/channels`);
    
    // Statistics
    let updated = 0;
    let failed = 0;
    
    // Process only YouTube data
    for (const show of shows) {
      try {
        const youtubeData = await youtubeService.searchChannel(show.name);
        
        if (youtubeData) {
          console.log(`\nYouTube data found for "${show.name}"`);
          
          // Extract data
          const cleanDescription = getCleanDescription(youtubeData.description);
          const releaseYear = extractYouTubeReleaseYear(youtubeData.publishedAt);
          
          // Update fields
          const updateResult = await pool.query(`
            UPDATE tv_shows
            SET 
              is_youtube_channel = true,
              channel_id = $1,
              subscriber_count = $2,
              video_count = $3,
              published_at = $4,
              release_year = COALESCE($5, release_year),
              description = CASE 
                WHEN description = '' OR description IS NULL 
                THEN $6 
                ELSE description 
              END,
              has_youtube_data = true
            WHERE id = $7
            RETURNING id, name
          `, [
            youtubeData.channelId,
            youtubeData.subscriberCount,
            youtubeData.videoCount,
            youtubeData.publishedAt,
            releaseYear,
            cleanDescription,
            show.id
          ]);
          
          if (updateResult.rowCount > 0) {
            console.log(`✅ Updated YouTube data for "${show.name}"`);
            updated++;
          }
        } else {
          console.log(`No YouTube data found for "${show.name}"`);
        }
      } catch (error) {
        console.error(`Error updating YouTube data for "${show.name}":`, error.message);
        failed++;
      }
      
      // Add delay to avoid API rate limits
      await new Promise(resolve => setTimeout(resolve, 500));
    }
    
    console.log('\nYouTube update complete:');
    console.log(`✅ Updated: ${updated} shows`);
    console.log(`❌ Failed: ${failed} shows`);
    
  } catch (error) {
    console.error('Fatal error in YouTube update process:', error);
  } finally {
    await pool.end();
  }
}

// Run the appropriate function based on command line argument when run directly
if (import.meta.url === `file://${process.argv[1]}`) {
  if (process.argv.includes('--youtube')) {
    console.log('Running YouTube-only update...');
    updateYouTubeShows().catch(console.error);
  } else {
    console.log('Running full API data update...');
    updateAllShowsApiData().catch(console.error);
  }
}

// Export functions for use in other modules - using ES Module exports
export {
  updateShowWithApiData,
  updateAllShowsApiData,
  updateYouTubeShows,
  extractYouTubeReleaseYear,
  getCleanDescription
};
</file>

<file path="apply-custom-data.js">
// Script to apply custom show details and images to the database
// This script directly updates the database instead of applying changes during server startup
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { Pool } from '@neondatabase/serverless';
import ws from 'ws';

// Get the current file directory (equivalent to __dirname in CommonJS)
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Configure Neon database connection
if (!process.env.DATABASE_URL) {
  console.error('DATABASE_URL environment variable is not set. Please set it before running this script.');
  process.exit(1);
}

// Set up database pool
const pool = new Pool({ connectionString: process.env.DATABASE_URL });

/**
 * Load custom show details mapping from the JSON file
 */
function loadCustomShowDetailsMap() {
  try {
    const filePath = path.join(process.cwd(), 'customShowDetailsMap.json');
    if (fs.existsSync(filePath)) {
      const data = fs.readFileSync(filePath, 'utf-8');
      return JSON.parse(data);
    }
  } catch (error) {
    console.error('Error loading custom show details map:', error);
  }
  return {};
}

/**
 * Load custom image mapping from the JSON file
 */
function loadCustomImageMap() {
  try {
    const filePath = path.join(process.cwd(), 'customImageMap.json');
    if (fs.existsSync(filePath)) {
      const data = fs.readFileSync(filePath, 'utf-8');
      return JSON.parse(data);
    }
  } catch (error) {
    console.error('Error loading custom image map:', error);
  }
  return {};
}

/**
 * Get a specific TV show from the database
 */
async function getTvShowById(id) {
  try {
    const result = await pool.query('SELECT * FROM tv_shows WHERE id = $1', [id]);
    if (result.rows.length > 0) {
      return result.rows[0];
    }
    return null;
  } catch (error) {
    console.error(`Error getting TV show with ID ${id}:`, error);
    return null;
  }
}

/**
 * Update a TV show's details in the database
 */
async function updateTvShow(id, details) {
  try {
    // Create SET clause for the SQL update query
    const keys = Object.keys(details);
    if (keys.length === 0) return null;
    
    // Create parameterized query
    const setClauses = keys.map((key, index) => `"${key}" = $${index + 2}`);
    const values = keys.map(key => {
      // Handle arrays (like themes) by converting to JSONB
      if (Array.isArray(details[key])) {
        return JSON.stringify(details[key]);
      }
      return details[key];
    });
    
    const query = `
      UPDATE tv_shows 
      SET ${setClauses.join(', ')} 
      WHERE id = $1 
      RETURNING *
    `;
    
    const result = await pool.query(query, [id, ...values]);
    if (result.rows.length > 0) {
      return result.rows[0];
    }
    return null;
  } catch (error) {
    console.error(`Error updating TV show with ID ${id}:`, error);
    return null;
  }
}

/**
 * Process all custom details in batches
 */
async function processCustomDetails() {
  try {
    const customDetailsMap = loadCustomShowDetailsMap();
    console.log(`Processing ${Object.keys(customDetailsMap).length} custom show details...`);
    
    // Process in batches of 20 shows
    const BATCH_SIZE = 20;
    const showIds = Object.keys(customDetailsMap).map(id => parseInt(id)).filter(id => !isNaN(id));
    const totalBatches = Math.ceil(showIds.length / BATCH_SIZE);
    
    console.log(`Processing ${showIds.length} shows in ${totalBatches} batches of ${BATCH_SIZE}`);
    
    let successCount = 0;
    let errorCount = 0;
    
    for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
      const batchStart = batchIndex * BATCH_SIZE;
      const batchEnd = Math.min(batchStart + BATCH_SIZE, showIds.length);
      const currentBatch = showIds.slice(batchStart, batchEnd);
      
      console.log(`Processing batch ${batchIndex + 1}/${totalBatches} (shows ${batchStart+1}-${batchEnd})`);
      
      // Process each show in the batch
      for (const showId of currentBatch) {
        try {
          const show = await getTvShowById(showId);
          if (show) {
            const details = customDetailsMap[showId.toString()];
            const updatedShow = await updateTvShow(showId, details);
            if (updatedShow) {
              successCount++;
              process.stdout.write('.');
            } else {
              errorCount++;
              process.stdout.write('E');
            }
          } else {
            console.log(`\nShow ID ${showId} not found in database`);
            errorCount++;
          }
        } catch (err) {
          console.error(`\nError processing show ${showId}:`, err);
          errorCount++;
        }
      }
      process.stdout.write('\n');
    }
    
    console.log(`\nCustom details processing completed: ${successCount} successful, ${errorCount} errors`);
    return { successCount, errorCount };
  } catch (error) {
    console.error('Error processing custom show details:', error);
    return { successCount: 0, errorCount: 0 };
  }
}

/**
 * Process all custom images in batches
 */
async function processCustomImages() {
  try {
    const customImageMap = loadCustomImageMap();
    console.log(`Processing ${Object.keys(customImageMap).length} custom images...`);
    
    // Process in batches of 20 shows
    const BATCH_SIZE = 20;
    const showIds = Object.keys(customImageMap).map(id => parseInt(id)).filter(id => !isNaN(id));
    const totalBatches = Math.ceil(showIds.length / BATCH_SIZE);
    
    console.log(`Processing ${showIds.length} images in ${totalBatches} batches of ${BATCH_SIZE}`);
    
    let successCount = 0;
    let errorCount = 0;
    
    for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
      const batchStart = batchIndex * BATCH_SIZE;
      const batchEnd = Math.min(batchStart + BATCH_SIZE, showIds.length);
      const currentBatch = showIds.slice(batchStart, batchEnd);
      
      console.log(`Processing image batch ${batchIndex + 1}/${totalBatches} (shows ${batchStart+1}-${batchEnd})`);
      
      // Process each show in the batch
      for (const showId of currentBatch) {
        try {
          const show = await getTvShowById(showId);
          if (show) {
            const imageUrl = customImageMap[showId.toString()];
            const updatedShow = await updateTvShow(showId, { imageUrl });
            if (updatedShow) {
              successCount++;
              process.stdout.write('.');
            } else {
              errorCount++;
              process.stdout.write('E');
            }
          } else {
            console.log(`\nShow ID ${showId} not found in database`);
            errorCount++;
          }
        } catch (err) {
          console.error(`\nError processing image for show ${showId}:`, err);
          errorCount++;
        }
      }
      process.stdout.write('\n');
    }
    
    console.log(`\nCustom images processing completed: ${successCount} successful, ${errorCount} errors`);
    return { successCount, errorCount };
  } catch (error) {
    console.error('Error processing custom images:', error);
    return { successCount: 0, errorCount: 0 };
  }
}

/**
 * Main function to process everything
 */
async function main() {
  try {
    console.log('Starting custom data processing...');
    console.log('This script will update the database directly with custom show details and images');
    
    // Process custom details
    const detailsResult = await processCustomDetails();
    
    // Process custom images
    const imagesResult = await processCustomImages();
    
    console.log('\nProcessing summary:');
    console.log(`Custom details: ${detailsResult.successCount} successful, ${detailsResult.errorCount} errors`);
    console.log(`Custom images: ${imagesResult.successCount} successful, ${imagesResult.errorCount} errors`);
    console.log('All done!');
    
  } catch (error) {
    console.error('Error in main process:', error);
  } finally {
    // Close the database pool
    await pool.end();
  }
}

// Run the main function
main().catch(console.error);
</file>

<file path="apply-custom-data.mjs">
// Script to apply custom show details and images to the database
// This script directly updates the database instead of applying changes during server startup
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { Pool } from '@neondatabase/serverless';
import ws from 'ws';

// Get the current file directory (equivalent to __dirname in CommonJS)
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Configure Neon database connection
if (!process.env.DATABASE_URL) {
  console.error('DATABASE_URL environment variable is not set. Please set it before running this script.');
  process.exit(1);
}

// Configure WebSocket for Neon
import { neonConfig } from '@neondatabase/serverless';
neonConfig.webSocketConstructor = ws;

// Set up database pool with the same configuration as server/db.ts
const poolConfig = {
  connectionString: process.env.DATABASE_URL,
  max: 20, // Maximum number of clients in the pool
  idleTimeoutMillis: 30000, // How long a client is allowed to remain idle before being closed
  connectionTimeoutMillis: 5000, // Maximum time to wait for a connection
};

const pool = new Pool(poolConfig);

// Add error handling for the pool
pool.on('error', (err) => {
  console.error('Unexpected error on idle client', err);
});

// Verify database connection before proceeding
async function verifyDatabaseConnection() {
  try {
    console.log('Verifying database connection...');
    const result = await pool.query('SELECT NOW()');
    console.log(`Database connected successfully at: ${result.rows[0].now}`);
    
    // Check if we can access the tv_shows table
    const showCount = await pool.query('SELECT COUNT(*) FROM tv_shows');
    console.log(`Found ${showCount.rows[0].count} TV shows in database`);
    
    return true;
  } catch (error) {
    console.error('Database connection verification failed:', error);
    return false;
  }
}

/**
 * Load custom show details mapping from the JSON file
 */
function loadCustomShowDetailsMap() {
  try {
    const filePath = path.join(process.cwd(), 'customShowDetailsMap.json');
    if (fs.existsSync(filePath)) {
      const data = fs.readFileSync(filePath, 'utf-8');
      return JSON.parse(data);
    }
  } catch (error) {
    console.error('Error loading custom show details map:', error);
  }
  return {};
}

/**
 * Load custom image mapping from the JSON file
 */
function loadCustomImageMap() {
  try {
    const filePath = path.join(process.cwd(), 'customImageMap.json');
    if (fs.existsSync(filePath)) {
      const data = fs.readFileSync(filePath, 'utf-8');
      return JSON.parse(data);
    }
  } catch (error) {
    console.error('Error loading custom image map:', error);
  }
  return {};
}

/**
 * Get a specific TV show from the database
 */
async function getTvShowById(id) {
  try {
    const result = await pool.query('SELECT * FROM tv_shows WHERE id = $1', [id]);
    if (result.rows.length > 0) {
      return result.rows[0];
    }
    return null;
  } catch (error) {
    console.error(`Error getting TV show with ID ${id}:`, error);
    return null;
  }
}

/**
 * Convert camelCase to snake_case
 */
function camelToSnakeCase(str) {
  return str.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`);
}

/**
 * Map custom field names to database column names
 * Returns null for fields that don't exist in the database
 */
function mapFieldToColumnName(key) {
  // Custom mapping for specific fields that exist in the database
  const fieldMap = {
    'stimulationScore': 'stimulation_score',
    'musicTempo': 'music_tempo',
    'totalMusicLevel': 'total_music_level',
    'totalSoundEffectTimeLevel': 'total_sound_effect_time_level',
    'sceneFrequency': 'scene_frequency',
    'interactivityLevel': 'interactivity_level',
    'dialogueIntensity': 'dialogue_intensity',
    'soundEffectsLevel': 'sound_effects_level',
    'animationStyle': 'animation_style',
    'ageRange': 'age_range',
    'themes': 'themes',
    'name': 'name',
    'description': 'description'
  };
  
  // Fields that should be ignored (not in database schema)
  const ignoredFields = [
    'TV or YouTube',
    'Seasons',
    'Avg. Epsiode',
    'TV',
    'Avg. Episode'
  ];
  
  // Return null for ignored fields
  if (ignoredFields.includes(key)) {
    return null;
  }
  
  // Return mapped field name or convert to snake_case
  return fieldMap[key] || null; // Return null for unknown fields instead of attempting conversion
}

/**
 * Update a TV show's details in the database
 */
async function updateTvShow(id, details) {
  try {
    // Create SET clause for the SQL update query
    const keys = Object.keys(details);
    if (keys.length === 0) return null;
    
    // Filter out keys that don't exist in the database
    const validEntries = keys
      .map(key => {
        const mappedKey = mapFieldToColumnName(key);
        return { originalKey: key, mappedKey };
      })
      .filter(entry => entry.mappedKey !== null);
    
    if (validEntries.length === 0) {
      console.log(`No valid fields to update for show ${id}`);
      return null;
    }
    
    // Create parameterized query with only valid fields
    const setClauses = validEntries.map((entry, index) => `"${entry.mappedKey}" = $${index + 2}`);
    
    const values = validEntries.map(entry => {
      const key = entry.originalKey;
      // Handle arrays (like themes) - format for PostgreSQL text[] type
      if (Array.isArray(details[key])) {
        // Format as PostgreSQL array literal: '{item1,item2,item3}'
        return '{' + details[key].map(item => {
          // Escape single quotes and backslashes in array items
          return item.toString().replace(/'/g, "''").replace(/\\/g, '\\\\');
        }).join(',') + '}';
      }
      // Handle stimulation score specifically
      if (key === 'stimulationScore') {
        // Ensure it's a whole number (integer)
        return Math.round(details[key]);
      }
      return details[key];
    });
    
    const query = `
      UPDATE tv_shows 
      SET ${setClauses.join(', ')} 
      WHERE id = $1 
      RETURNING *
    `;
    
    const result = await pool.query(query, [id, ...values]);
    if (result.rows.length > 0) {
      return result.rows[0];
    }
    return null;
  } catch (error) {
    console.error(`Error updating TV show with ID ${id}:`, error);
    return null;
  }
}

/**
 * Process all custom details in batches
 */
async function processCustomDetails() {
  try {
    const customDetailsMap = loadCustomShowDetailsMap();
    console.log(`Processing ${Object.keys(customDetailsMap).length} custom show details...`);
    
    // Process in batches of 20 shows
    const BATCH_SIZE = 20;
    const showIds = Object.keys(customDetailsMap).map(id => parseInt(id)).filter(id => !isNaN(id));
    const totalBatches = Math.ceil(showIds.length / BATCH_SIZE);
    
    console.log(`Processing ${showIds.length} shows in ${totalBatches} batches of ${BATCH_SIZE}`);
    
    let successCount = 0;
    let errorCount = 0;
    
    for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
      const batchStart = batchIndex * BATCH_SIZE;
      const batchEnd = Math.min(batchStart + BATCH_SIZE, showIds.length);
      const currentBatch = showIds.slice(batchStart, batchEnd);
      
      console.log(`Processing batch ${batchIndex + 1}/${totalBatches} (shows ${batchStart+1}-${batchEnd})`);
      
      // Process each show in the batch
      for (const showId of currentBatch) {
        try {
          const show = await getTvShowById(showId);
          if (show) {
            const details = customDetailsMap[showId.toString()];
            const updatedShow = await updateTvShow(showId, details);
            if (updatedShow) {
              successCount++;
              process.stdout.write('.');
            } else {
              errorCount++;
              process.stdout.write('E');
            }
          } else {
            console.log(`\nShow ID ${showId} not found in database`);
            errorCount++;
          }
        } catch (err) {
          console.error(`\nError processing show ${showId}:`, err);
          errorCount++;
        }
      }
      process.stdout.write('\n');
    }
    
    console.log(`\nCustom details processing completed: ${successCount} successful, ${errorCount} errors`);
    return { successCount, errorCount };
  } catch (error) {
    console.error('Error processing custom show details:', error);
    return { successCount: 0, errorCount: 0 };
  }
}

/**
 * Process all custom images in batches
 */
async function processCustomImages() {
  try {
    const customImageMap = loadCustomImageMap();
    console.log(`Processing ${Object.keys(customImageMap).length} custom images...`);
    
    // Process in batches of 20 shows
    const BATCH_SIZE = 20;
    const showIds = Object.keys(customImageMap).map(id => parseInt(id)).filter(id => !isNaN(id));
    const totalBatches = Math.ceil(showIds.length / BATCH_SIZE);
    
    console.log(`Processing ${showIds.length} images in ${totalBatches} batches of ${BATCH_SIZE}`);
    
    let successCount = 0;
    let errorCount = 0;
    
    for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
      const batchStart = batchIndex * BATCH_SIZE;
      const batchEnd = Math.min(batchStart + BATCH_SIZE, showIds.length);
      const currentBatch = showIds.slice(batchStart, batchEnd);
      
      console.log(`Processing image batch ${batchIndex + 1}/${totalBatches} (shows ${batchStart+1}-${batchEnd})`);
      
      // Process each show in the batch
      for (const showId of currentBatch) {
        try {
          const show = await getTvShowById(showId);
          if (show) {
            const imageUrl = customImageMap[showId.toString()];
            const updatedShow = await updateTvShow(showId, { imageUrl });
            if (updatedShow) {
              successCount++;
              process.stdout.write('.');
            } else {
              errorCount++;
              process.stdout.write('E');
            }
          } else {
            console.log(`\nShow ID ${showId} not found in database`);
            errorCount++;
          }
        } catch (err) {
          console.error(`\nError processing image for show ${showId}:`, err);
          errorCount++;
        }
      }
      process.stdout.write('\n');
    }
    
    console.log(`\nCustom images processing completed: ${successCount} successful, ${errorCount} errors`);
    return { successCount, errorCount };
  } catch (error) {
    console.error('Error processing custom images:', error);
    return { successCount: 0, errorCount: 0 };
  }
}

/**
 * Main function to process everything
 */
async function main() {
  try {
    console.log('Starting custom data processing...');
    console.log('This script will update the database directly with custom show details and images');
    
    // Verify database connection before proceeding
    const isConnected = await verifyDatabaseConnection();
    if (!isConnected) {
      console.error('Could not establish database connection. Exiting...');
      return;
    }
    
    // Process custom details
    const detailsResult = await processCustomDetails();
    
    // Process custom images
    const imagesResult = await processCustomImages();
    
    console.log('\nProcessing summary:');
    console.log(`Custom details: ${detailsResult.successCount} successful, ${detailsResult.errorCount} errors`);
    console.log(`Custom images: ${imagesResult.successCount} successful, ${imagesResult.errorCount} errors`);
    console.log('All done!');
    
  } catch (error) {
    console.error('Error in main process:', error);
  } finally {
    // Close the database pool
    await pool.end();
  }
}

// Run the main function
main().catch(console.error);
</file>

<file path="apply-migrations.js">
/**
 * Script to apply database migrations
 */
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { pool } from './server/db.js';

// Get the directory name for ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

async function applyMigration(migrationFile) {
  console.log(`Applying migration: ${migrationFile}`);
  
  try {
    // Read the SQL file
    const migrationPath = path.join(__dirname, 'migrations', migrationFile);
    const sql = fs.readFileSync(migrationPath, 'utf8');
    
    // Execute the SQL
    await pool.query(sql);
    console.log(`✅ Successfully applied migration: ${migrationFile}`);
    return true;
  } catch (error) {
    console.error(`❌ Error applying migration ${migrationFile}:`, error.message);
    return false;
  }
}

async function runMigrations() {
  console.log('Starting database migrations...');
  
  try {
    // Get all migration files
    const migrationsDir = path.join(__dirname, 'migrations');
    const migrationFiles = fs.readdirSync(migrationsDir)
      .filter(file => file.endsWith('.sql'))
      .sort(); // Sort to ensure migrations run in order (0001, 0002, etc.)
    
    if (migrationFiles.length === 0) {
      console.log('No migrations to apply');
      return;
    }
    
    console.log(`Found ${migrationFiles.length} migrations to apply`);
    
    // Apply each migration
    for (const migrationFile of migrationFiles) {
      const success = await applyMigration(migrationFile);
      if (!success) {
        console.error(`Migration failed: ${migrationFile}. Stopping.`);
        break;
      }
    }
    
    console.log('Migration process completed');
  } catch (error) {
    console.error('Failed to run migrations:', error);
  } finally {
    // Close the database connection
    await pool.end();
  }
}

// Run the migrations
runMigrations();
</file>

<file path="apply-migrations.mjs">
/**
 * Script to apply database migrations
 */
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { pool } from './server/db.js';

// Get the directory name for ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

async function applyMigration(migrationFile) {
  console.log(`Applying migration: ${migrationFile}`);
  
  try {
    // Read the SQL file
    const migrationPath = path.join(__dirname, 'migrations', migrationFile);
    const sql = fs.readFileSync(migrationPath, 'utf8');
    
    // Execute the SQL
    await pool.query(sql);
    console.log(`✅ Successfully applied migration: ${migrationFile}`);
    return true;
  } catch (error) {
    console.error(`❌ Error applying migration ${migrationFile}:`, error.message);
    return false;
  }
}

async function runMigrations() {
  console.log('Starting database migrations...');
  
  try {
    // Get all migration files
    const migrationsDir = path.join(__dirname, 'migrations');
    const migrationFiles = fs.readdirSync(migrationsDir)
      .filter(file => file.endsWith('.sql'))
      .sort(); // Sort to ensure migrations run in order (0001, 0002, etc.)
    
    if (migrationFiles.length === 0) {
      console.log('No migrations to apply');
      return;
    }
    
    console.log(`Found ${migrationFiles.length} migrations to apply`);
    
    // Apply each migration
    for (const migrationFile of migrationFiles) {
      const success = await applyMigration(migrationFile);
      if (!success) {
        console.error(`Migration failed: ${migrationFile}. Stopping.`);
        break;
      }
    }
    
    console.log('Migration process completed');
  } catch (error) {
    console.error('Failed to run migrations:', error);
  } finally {
    // Close the database connection
    await pool.end();
  }
}

// Run the migrations
runMigrations();
</file>

<file path="check-image-orientation.js">
const fetch = require('node-fetch');

// Function to check if image is landscape or portrait
async function checkImageOrientation(imageUrl) {
  try {
    const response = await fetch(imageUrl);
    if (!response.ok) {
      return { success: false, error: `Failed to fetch image: ${response.statusText}` };
    }
    
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = function() {
        const isLandscape = img.width > img.height;
        resolve({
          success: true,
          url: imageUrl,
          width: img.width,
          height: img.height,
          isLandscape: isLandscape,
          isPortrait: !isLandscape
        });
      };
      img.onerror = function() {
        resolve({ success: false, error: 'Failed to load image', url: imageUrl });
      };
      img.src = URL.createObjectURL(response.blob());
    });
  } catch (error) {
    return { success: false, error: error.message, url: imageUrl };
  }
}

// Import the shows from our data
const fs = require('fs');
const path = require('path');

// This script will run from the project root
const showsPath = path.join(__dirname, 'shows.json');

fs.readFile(showsPath, 'utf8', async (err, data) => {
  if (err) {
    console.error('Error reading shows.json:', err);
    return;
  }
  
  try {
    const shows = JSON.parse(data);
    console.log(`Found ${shows.length} shows in shows.json`);
    
    const landscapeImages = [];
    const portraitImages = [];
    const failedChecks = [];
    
    for (const show of shows) {
      if (show.imageUrl) {
        const result = await checkImageOrientation(show.imageUrl);
        if (result.success) {
          if (result.isLandscape) {
            landscapeImages.push({
              id: show.id,
              name: show.name,
              imageUrl: show.imageUrl,
              width: result.width,
              height: result.height
            });
          } else {
            portraitImages.push({
              id: show.id,
              name: show.name,
              imageUrl: show.imageUrl,
              width: result.width,
              height: result.height
            });
          }
        } else {
          failedChecks.push({
            id: show.id,
            name: show.name,
            imageUrl: show.imageUrl,
            error: result.error
          });
        }
      }
    }
    
    console.log(`\nFound ${landscapeImages.length} shows with landscape images:`);
    landscapeImages.forEach(show => {
      console.log(`- ID: ${show.id}, Name: ${show.name}, Dimensions: ${show.width}x${show.height}`);
    });
    
    console.log(`\nFound ${portraitImages.length} shows with portrait images.`);
    
    console.log(`\n${failedChecks.length} images failed to check:`);
    failedChecks.forEach(show => {
      console.log(`- ID: ${show.id}, Name: ${show.name}, Error: ${show.error}`);
    });
    
    // Save results to file
    fs.writeFileSync('landscape-shows.json', JSON.stringify(landscapeImages, null, 2));
    console.log('\nSaved landscape show list to landscape-shows.json');
  } catch (error) {
    console.error('Error processing shows:', error);
  }
});
</file>

<file path="check-images.js">
// Script to identify landscape images and attempt to replace them with OMDB portrait images

const fs = require('fs');
const path = require('path');
const fetch = require('node-fetch');

// OMDB API Key
const omdbApiKey = process.env.OMDB_API_KEY;

// Function to fetch image metadata
async function getImageMetadata(imageUrl) {
  try {
    const response = await fetch(imageUrl, { method: 'HEAD' });
    if (!response.ok) {
      return { 
        success: false, 
        error: `Failed to fetch image: ${response.statusText}`,
        url: imageUrl
      };
    }
    
    return { success: true, url: imageUrl };
  } catch (error) {
    return { success: false, error: error.message, url: imageUrl };
  }
}

// Function to search for a show on OMDB
async function searchOmdb(title) {
  try {
    const url = `http://www.omdbapi.com/?apikey=${omdbApiKey}&t=${encodeURIComponent(title)}&type=series`;
    const response = await fetch(url);
    const data = await response.json();
    
    if (data.Response === 'True' && data.Poster && data.Poster !== 'N/A') {
      return {
        success: true,
        title: data.Title,
        poster: data.Poster,
        imdbId: data.imdbID
      };
    } else {
      return {
        success: false,
        error: data.Error || 'No poster available',
        searchedTitle: title
      };
    }
  } catch (error) {
    return {
      success: false,
      error: error.message,
      searchedTitle: title
    };
  }
}

// Main function
async function main() {
  try {
    // Read the shows from shows.json
    const showsPath = path.join(__dirname, 'shows.json');
    const data = fs.readFileSync(showsPath, 'utf8');
    const shows = JSON.parse(data);
    
    console.log(`Found ${shows.length} shows in shows.json`);
    
    // Create arrays to track our process
    const needOMDB = [];
    const successfulUpdates = [];
    const notFoundOnOMDB = [];
    
    // Check each show's image URL
    for (const show of shows) {
      if (show.imageUrl) {
        // For now, let's just add all shows to the needOMDB list
        // In a real implementation, we would check if the image is landscape
        needOMDB.push({
          id: show.id,
          name: show.name,
          currentImageUrl: show.imageUrl
        });
      }
    }
    
    console.log(`\nFound ${needOMDB.length} shows that need OMDB poster lookup`);
    
    // Try to get OMDB posters for all shows in the needOMDB list
    for (const show of needOMDB) {
      console.log(`Looking up OMDB poster for "${show.name}"...`);
      
      const omdbResult = await searchOmdb(show.name);
      
      if (omdbResult.success) {
        successfulUpdates.push({
          id: show.id,
          name: show.name,
          oldImageUrl: show.currentImageUrl,
          newImageUrl: omdbResult.poster,
          imdbId: omdbResult.imdbId
        });
        
        console.log(`✓ Found OMDB poster for "${show.name}"`);
      } else {
        notFoundOnOMDB.push({
          id: show.id,
          name: show.name,
          currentImageUrl: show.currentImageUrl,
          error: omdbResult.error
        });
        
        console.log(`✗ No OMDB poster found for "${show.name}": ${omdbResult.error}`);
      }
      
      // Add a small delay between requests to avoid rate limiting
      await new Promise(resolve => setTimeout(resolve, 500));
    }
    
    // Save results to files
    fs.writeFileSync('omdb-updates.json', JSON.stringify(successfulUpdates, null, 2));
    fs.writeFileSync('shows-missing-posters.json', JSON.stringify(notFoundOnOMDB, null, 2));
    
    console.log('\nResults:');
    console.log(`- ${successfulUpdates.length} shows can be updated with OMDB posters`);
    console.log(`- ${notFoundOnOMDB.length} shows were not found on OMDB`);
    console.log('\nSaved results to:');
    console.log('- omdb-updates.json (shows with available OMDB posters)');
    console.log('- shows-missing-posters.json (shows not found on OMDB)');
    
  } catch (error) {
    console.error('Error processing shows:', error);
  }
}

// Check if OMDB API key is available
if (!omdbApiKey) {
  console.error('Error: OMDB_API_KEY environment variable is not set.');
  console.log('Please set the OMDB_API_KEY environment variable and try again.');
  process.exit(1);
}

// Run the main function
main();
</file>

<file path="convert-avif.js">
import sharp from 'sharp';

async function convertAvifToJpg() {
  try {
    await sharp('attached_assets/the enchanted world of brambly hedge.avif')
      .jpeg({ quality: 90 })
      .toFile('./client/public/custom-images/the-enchanted-world-of-brambly-hedge.jpg');
    console.log('Conversion successful');
  } catch (error) {
    console.error('Error converting image:', error);
  }
}

convertAvifToJpg();
</file>

<file path="CURRENT_WORKING_STATE.md">
# TV Tantrum - Current Working State (2025-05-28)

## Backup Information
- **Database Backup**: `backup/tv-tantrum-backup-20250528-142450.sql`
- **Backup Date**: May 28, 2025 at 14:24:50
- **Status**: All systems operational and tested

## Key Features Working
✅ Smart Theme Management System
✅ Theme Database Synchronization (all 3 storage locations)
✅ Intelligent ThemeSelector component with autocomplete
✅ Add Show and Edit Show forms with theme validation
✅ Alphabetical theme sorting and filtering
✅ User badge progression system (13 emoji levels)
✅ Privacy-focused public profiles
✅ Featured content system
✅ Admin dashboard with comprehensive management

## Recent Fixes Applied
- Fixed 'sing-a-long' → 'Sing Along' theme standardization
- Resolved theme synchronization across themes table, junction table, and show arrays
- Eliminated duplicate themes and standardized formatting
- Implemented proper Title Case formatting for all themes

## Database Schema Status
- All theme relationships properly synchronized
- User points and badge progression functional
- Featured content flags implemented
- Review and favorite systems operational

## API Endpoints Confirmed Working
- `/api/themes` - Returns alphabetically sorted themes
- `/api/tv-shows` - Advanced filtering with theme support
- `/api/shows/:id` - Detailed show information
- `/api/user/dashboard` - User gamification data
- `/api/users/:id/profile` - Public profile access

## Old Show Submission System - DISABLED
✅ Commented out `showSubmissions` table in schema.ts
✅ Disabled old API endpoints in server/routes.ts  
✅ Commented out database methods in database-storage.ts
✅ System now ready for fresh show submission implementation

## Next Steps Preparation
Ready for careful database modifications with full backup protection.
Clean slate for new show submission system implementation.
</file>

<file path="CUSTOM_DATA.md">
# Custom Data Handling Documentation

## Overview

This document explains the system for handling custom show details and images in TV Tantrum. The custom data handling system is designed to solve the following challenges:

1. **Performance Bottlenecks**: Loading and applying custom data during server startup caused significant delays
2. **Database Load**: Processing 300+ shows on every restart placed unnecessary load on the database
3. **Scaling Issues**: As the catalog grows, startup performance would continue to degrade

## Solution: Pre-processing Script

The new approach separates custom data application from server startup by using a pre-processing script:

- **File**: `apply-custom-data.mjs`
- **Purpose**: Directly updates the database with custom details and images outside the server startup process
- **Benefits**: 
  - Server starts much faster
  - Database connection is more stable
  - Better separation of concerns
  - Improved maintainability

## How It Works

### 1. Custom Data Files

Two JSON files store custom data:

- `customShowDetailsMap.json`: Maps show IDs to their custom details (stimulation metrics, etc.)
- `customImageMap.json`: Maps show IDs to their custom image URLs

### 2. Pre-processing Script

The `apply-custom-data.mjs` script:

- Connects to the database using the same configuration as the server
- Loads custom details and images from their respective JSON files
- Processes updates in batches to reduce database load
- Maps data keys from camelCase to snake_case to match database schema
- Converts JavaScript arrays to PostgreSQL array format
- Properly rounds stimulation scores to whole numbers
- Handles errors gracefully and provides detailed logs

### 3. Server Integration

Server startup is modified to:

- Skip custom data loading by default (configurable with environment variables)
- Display a message indicating how to apply custom data manually
- Process faster with fewer database operations

## Usage

### Running the Script

```
node apply-custom-data.mjs
```

This directly updates the database with all custom data and can be run:
- After initial database setup
- After any changes to the custom data files
- When you want to refresh the database with custom details

### Environment Variables

Two optional environment variables can control the behavior:

- `SKIP_CUSTOM_DETAILS`: Set to "true" to skip loading custom details during server startup
- `SKIP_CUSTOM_IMAGES`: Set to "true" to skip loading custom images during server startup

By default, both are now set to "true" for optimal performance.

## Data Preservation System

The custom data handling approach preserves these important details:

1. **Stimulation Scores**: Always stored as whole numbers, never decimals
2. **Image URLs**: Proper portrait-style images are preserved 
3. **Show Names**: Official branding names are maintained
4. **Themes**: Array of themes with proper encoding
5. **Rating Metrics**: All sensory/stimulation metrics from the original source

## Maintenance

When adding new shows or updating existing ones:

1. Update the appropriate JSON file with the custom details/images
2. Run the pre-processing script to apply changes to the database
3. The server will use the updated database values on the next startup

## Troubleshooting

If you encounter issues:

1. Check the console output of the pre-processing script for specific errors
2. Verify database connection settings match between script and server
3. Ensure the JSON files have valid formats
4. For schema changes, update the field mapping in the script
</file>

<file path="data-manager.js">
/**
 * Consolidated Data Management Utility
 * 
 * This script replaces multiple overlapping data management scripts:
 * - consolidate-tv-data.js
 * - update-sensory-details.js
 * - update-show-metrics.js
 * 
 * Features:
 * - Consolidates TV show data from multiple sources
 * - Updates sensory details from Google Sheets
 * - Manages show metrics and ratings
 * - Maintains data integrity with custom details
 */

import fs from 'fs';
import path from 'path';
import { Pool } from 'pg';
import { parse } from 'csv-parse/sync';
import dotenv from 'dotenv';
import { fileURLToPath } from 'url';

dotenv.config();

// Get __dirname equivalent in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Database connection
const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
});

// File paths
const customShowDetailsPath = path.join(__dirname, 'data', 'custom-show-details.json');
const customImageMapPath = path.join(__dirname, 'data', 'custom-image-map.json');
const sheetsDataPath = path.join(__dirname, 'data', 'tv-shows.json');
const githubDataPath = path.join(__dirname, 'data', 'github-shows.json');
const sensoryDetailsPath = path.join(__dirname, 'data', 'sensory-details.csv');

/**
 * Load custom show details from file
 */
function loadCustomShowDetails() {
  try {
    if (fs.existsSync(customShowDetailsPath)) {
      const data = fs.readFileSync(customShowDetailsPath, 'utf8');
      return JSON.parse(data);
    }
    return {};
  } catch (error) {
    console.error('Error loading custom show details:', error);
    return {};
  }
}

/**
 * Save custom show details to file
 */
function saveCustomShowDetails(details) {
  try {
    fs.writeFileSync(customShowDetailsPath, JSON.stringify(details, null, 2));
    console.log('Custom show details saved successfully');
    return true;
  } catch (error) {
    console.error('Error saving custom show details:', error);
    return false;
  }
}

/**
 * Load custom image mappings from file
 */
function loadCustomImageMap() {
  try {
    if (fs.existsSync(customImageMapPath)) {
      const data = fs.readFileSync(customImageMapPath, 'utf8');
      return JSON.parse(data);
    }
    return {};
  } catch (error) {
    console.error('Error loading custom image map:', error);
    return {};
  }
}

/**
 * Load TV show data from Google Sheets (JSON file)
 */
function loadGoogleSheetsData() {
  try {
    if (fs.existsSync(sheetsDataPath)) {
      const data = fs.readFileSync(sheetsDataPath, 'utf8');
      return JSON.parse(data);
    }
    return [];
  } catch (error) {
    console.error('Error loading Google Sheets data:', error);
    return [];
  }
}

/**
 * Load TV show data from GitHub (JSON file)
 */
function loadGitHubData() {
  try {
    if (fs.existsSync(githubDataPath)) {
      const data = fs.readFileSync(githubDataPath, 'utf8');
      return JSON.parse(data);
    }
    return [];
  } catch (error) {
    console.error('Error loading GitHub data:', error);
    return [];
  }
}

/**
 * Load sensory details from CSV file
 */
function loadSensoryDetails() {
  try {
    if (fs.existsSync(sensoryDetailsPath)) {
      const fileContent = fs.readFileSync(sensoryDetailsPath, 'utf8');
      const records = parse(fileContent, {
        columns: true,
        skip_empty_lines: true
      });
      
      // Create a map of show name to sensory details
      const sensoryDetailsMap = {};
      records.forEach(record => {
        const showName = record.show_name || record.name;
        if (showName) {
          sensoryDetailsMap[showName.toLowerCase()] = record;
        }
      });
      
      return sensoryDetailsMap;
    }
    return {};
  } catch (error) {
    console.error('Error loading sensory details:', error);
    return {};
  }
}

/**
 * Normalize a field key from various sources
 */
function normalizeKey(key) {
  return key
    .replace(/([A-Z])/g, '_$1')  // Convert camelCase to snake_case
    .toLowerCase()
    .replace(/^_/, '');          // Remove leading underscore
}

/**
 * Normalize a value based on field type
 */
function normalizeValue(key, value) {
  if (value === undefined || value === null || value === '') {
    return null;
  }
  
  // Handle arrays
  if (Array.isArray(value)) {
    return value;
  }
  
  // For numeric fields, ensure they're numbers
  if (key.includes('score') || key.includes('rating') || key.includes('count') || 
      key.includes('year') || key.includes('episode_length') || key.includes('seasons')) {
    const num = parseInt(value, 10);
    return isNaN(num) ? null : num;
  }
  
  // For boolean fields, convert to proper boolean
  if (key.includes('is_') || key.includes('has_')) {
    if (typeof value === 'string') {
      return value.toLowerCase() === 'true' || value === '1';
    }
    return Boolean(value);
  }
  
  // Default: return as is
  return value;
}

/**
 * Process themes string or array into consistent array format
 */
function processThemes(themes) {
  if (!themes) return [];
  
  if (Array.isArray(themes)) {
    return themes.filter(Boolean);
  }
  
  if (typeof themes === 'string') {
    return themes
      .split(',')
      .map(theme => theme.trim())
      .filter(Boolean);
  }
  
  return [];
}

/**
 * Normalize show name for matching
 */
function normalizeShowName(name) {
  if (!name) return '';
  return name
    .toLowerCase()
    .replace(/[^a-z0-9]/g, '') // Remove non-alphanumeric characters
    .replace(/\s+/g, '');      // Remove whitespace
}

/**
 * Update a TV show's details in the database
 */
async function updateTvShow(id, details) {
  try {
    if (!id || Object.keys(details).length === 0) {
      return false;
    }
    
    // Build the SET clause for SQL update
    const setClause = Object.keys(details)
      .filter(key => details[key] !== undefined)
      .map(key => {
        const dbField = normalizeKey(key);
        return `${dbField} = $${setValues.length + 1}`;
      });
    
    if (setClause.length === 0) {
      return false;
    }
    
    // Get the values to update
    const setValues = Object.keys(details)
      .filter(key => details[key] !== undefined)
      .map(key => normalizeValue(normalizeKey(key), details[key]));
    
    // Add the ID parameter
    setValues.push(id);
    
    // Build and execute the query
    const query = `
      UPDATE tv_shows
      SET ${setClause.join(', ')}
      WHERE id = $${setValues.length}
      RETURNING id, name
    `;
    
    const result = await pool.query(query, setValues);
    return result.rowCount > 0;
  } catch (error) {
    console.error(`Error updating TV show ID ${id}:`, error);
    return false;
  }
}

/**
 * Consolidate TV show data from multiple sources
 */
async function consolidateTvData() {
  try {
    console.log('Starting TV data consolidation process...');
    
    // Load data from all sources
    const customDetails = loadCustomShowDetails();
    const customImages = loadCustomImageMap();
    const sheetsData = loadGoogleSheetsData();
    const githubData = loadGitHubData();
    const sensoryDetails = loadSensoryDetails();
    
    console.log(`Loaded data from sources:
      - Custom details: ${Object.keys(customDetails).length} shows
      - Custom images: ${Object.keys(customImages).length} shows
      - Google Sheets: ${sheetsData.length} shows
      - GitHub: ${githubData.length} shows
      - Sensory details: ${Object.keys(sensoryDetails).length} shows`);
    
    // Create a map to track shows by ID
    const showsMap = new Map();
    
    // First, process Google Sheets data (base data)
    for (const show of sheetsData) {
      showsMap.set(show.id, {
        id: show.id,
        name: show.name,
        description: show.description || '',
        ageRange: show.ageRange || '',
        tantrumFactor: show.tantrumFactor || '',
        themes: processThemes(show.themes),
        network: show.network || '',
        year: show.year || '',
        productionCompany: show.productionCompany || '',
        stimulationScore: show.stimulationScore || 0,
        imageUrl: null, // Will be filled in later
        
        // Additional fields that may come from Google Sheets
        interactionLevel: show.interactionLevel || null,
        dialogueIntensity: show.dialogueIntensity || null,
        soundFrequency: show.soundFrequency || null,
        totalMusicLevel: show.totalMusicLevel || null,
        musicTempo: show.musicTempo || null,
        soundEffectsLevel: show.soundEffectsLevel || null,
        animationStyle: show.animationStyle || null,
        sceneFrequency: show.sceneFrequency || null,
        episodeLength: show.episodeLength || 0,
        creator: show.creator || null,
        releaseYear: show.releaseYear || null,
        endYear: show.endYear || null,
        isOngoing: show.isOngoing || null,
        seasons: show.seasons || null,
      });
    }
    
    // Second, override with GitHub data (has more detailed sensory metrics)
    for (const githubShow of githubData) {
      // Try to find matching show in our existing map
      // Match by name if ID not available
      let matchId = null;
      
      if (githubShow.id) {
        // Direct ID match
        matchId = githubShow.id;
      } else {
        // Try to match by name
        const normalizedName = normalizeShowName(githubShow.title);
        
        for (const [id, show] of showsMap.entries()) {
          if (normalizeShowName(show.name) === normalizedName) {
            matchId = id;
            break;
          }
        }
      }
      
      if (matchId && showsMap.has(matchId)) {
        // Update the existing show with GitHub data
        const existingShow = showsMap.get(matchId);
        
        showsMap.set(matchId, {
          ...existingShow,
          // Override with GitHub data
          stimulationScore: githubShow.stimulation_score || existingShow.stimulationScore,
          interactivityLevel: githubShow.interactivity_level || existingShow.interactivityLevel,
          dialogueIntensity: githubShow.dialogue_intensity || existingShow.dialogueIntensity,
          soundEffectsLevel: githubShow.sound_effects_level || existingShow.soundEffectsLevel,
          musicTempo: githubShow.music_tempo || existingShow.musicTempo,
          totalMusicLevel: githubShow.total_music_level || existingShow.totalMusicLevel,
          totalSoundEffectTimeLevel: githubShow.total_sound_effect_time_level || existingShow.totalSoundEffectTimeLevel,
          sceneFrequency: githubShow.scene_frequency || existingShow.sceneFrequency,
          animationStyle: githubShow.animation_style || existingShow.animationStyle,
          themes: processThemes(githubShow.themes) || existingShow.themes,
          releaseYear: githubShow.release_year || existingShow.releaseYear,
          endYear: githubShow.end_year || existingShow.endYear,
          
          // Use an external image if no custom one exists
          imageUrl: existingShow.imageUrl
        });
      }
    }
    
    // Third, apply custom details (highest priority)
    for (const [showId, details] of Object.entries(customDetails)) {
      const id = parseInt(showId, 10);
      if (showsMap.has(id)) {
        const existingShow = showsMap.get(id);
        
        // Apply custom details, preserving existing data when no custom data exists
        showsMap.set(id, {
          ...existingShow,
          // Only override fields that exist in custom details
          ...Object.keys(details).reduce((acc, key) => {
            if (details[key] !== undefined && details[key] !== null) {
              acc[key] = details[key];
            }
            return acc;
          }, {})
        });
      }
    }
    
    // Fourth, apply sensory details from Google Sheets
    for (const [id, show] of showsMap.entries()) {
      const sensoryDetail = sensoryDetails[show.name.toLowerCase()];
      
      if (sensoryDetail) {
        const updatedShow = { ...show };
        
        // Apply sensory details from sheet
        if (sensoryDetail.dialogue_intensity) updatedShow.dialogueIntensity = sensoryDetail.dialogue_intensity;
        if (sensoryDetail.sound_frequency) updatedShow.soundFrequency = sensoryDetail.sound_frequency;
        if (sensoryDetail.total_music_level) updatedShow.totalMusicLevel = sensoryDetail.total_music_level;
        if (sensoryDetail.music_tempo) updatedShow.musicTempo = sensoryDetail.music_tempo;
        if (sensoryDetail.sound_effects_level) updatedShow.soundEffectsLevel = sensoryDetail.sound_effects_level;
        if (sensoryDetail.animation_style) updatedShow.animationStyle = sensoryDetail.animation_style;
        if (sensoryDetail.scene_frequency) updatedShow.sceneFrequency = sensoryDetail.scene_frequency;
        if (sensoryDetail.stimulation_score) updatedShow.stimulationScore = parseInt(sensoryDetail.stimulation_score, 10);
        if (sensoryDetail.interaction_level) updatedShow.interactionLevel = sensoryDetail.interaction_level;
        
        showsMap.set(id, updatedShow);
      }
    }
    
    // Finally, apply custom images
    for (const [showId, imageUrl] of Object.entries(customImages)) {
      const id = parseInt(showId, 10);
      if (showsMap.has(id) && imageUrl) {
        const show = showsMap.get(id);
        showsMap.set(id, {
          ...show,
          imageUrl
        });
      }
    }
    
    // Convert map to array for database update
    const shows = Array.from(showsMap.values());
    console.log(`Consolidated ${shows.length} TV shows`);
    
    // Update each show in the database
    let updatedCount = 0;
    let errorCount = 0;
    
    for (const show of shows) {
      try {
        const success = await updateTvShow(show.id, show);
        if (success) {
          updatedCount++;
        } else {
          errorCount++;
        }
      } catch (error) {
        console.error(`Error updating show "${show.name}":`, error);
        errorCount++;
      }
    }
    
    console.log('\nData consolidation complete:');
    console.log(`✅ Updated: ${updatedCount} shows`);
    console.log(`❌ Errors: ${errorCount} shows`);
    console.log(`📊 Total processed: ${shows.length} shows`);
    
  } catch (error) {
    console.error('Fatal error in data consolidation process:', error);
  } finally {
    await pool.end();
  }
}

/**
 * Update sensory details for all TV shows
 */
async function updateSensoryDetails() {
  try {
    console.log('Starting sensory details update process...');
    
    // Load sensory details from CSV
    const sensoryDetails = loadSensoryDetails();
    console.log(`Loaded sensory details for ${Object.keys(sensoryDetails).length} shows`);
    
    // Get all TV shows from database
    const result = await pool.query('SELECT id, name FROM tv_shows ORDER BY name');
    const shows = result.rows;
    
    console.log(`Found ${shows.length} shows in the database`);
    
    // Statistics
    let updatedCount = 0;
    let errorCount = 0;
    let skippedCount = 0;
    
    // Process each show
    for (const show of shows) {
      try {
        // Look for sensory details by show name
        const sensoryDetail = sensoryDetails[show.name.toLowerCase()];
        
        if (!sensoryDetail) {
          skippedCount++;
          continue;
        }
        
        // Create update object with sensory fields
        const updateFields = {};
        
        // Map columns from CSV to database fields
        if (sensoryDetail.dialogue_intensity) updateFields.dialogue_intensity = sensoryDetail.dialogue_intensity;
        if (sensoryDetail.sound_frequency) updateFields.sound_frequency = sensoryDetail.sound_frequency;
        if (sensoryDetail.total_music_level) updateFields.total_music_level = sensoryDetail.total_music_level;
        if (sensoryDetail.music_tempo) updateFields.music_tempo = sensoryDetail.music_tempo;
        if (sensoryDetail.sound_effects_level) updateFields.sound_effects_level = sensoryDetail.sound_effects_level;
        if (sensoryDetail.animation_style) updateFields.animation_style = sensoryDetail.animation_style;
        if (sensoryDetail.scene_frequency) updateFields.scene_frequency = sensoryDetail.scene_frequency;
        if (sensoryDetail.stimulation_score) updateFields.stimulation_score = parseInt(sensoryDetail.stimulation_score, 10);
        if (sensoryDetail.interaction_level) updateFields.interaction_level = sensoryDetail.interaction_level;
        
        // Only update if we have fields to update
        if (Object.keys(updateFields).length === 0) {
          skippedCount++;
          continue;
        }
        
        // Build SET clause for SQL
        const setClause = Object.keys(updateFields)
          .map((key, i) => `${key} = $${i + 1}`)
          .join(', ');
        
        // Build query with values
        const values = Object.values(updateFields);
        values.push(show.id);
        
        const query = `
          UPDATE tv_shows
          SET ${setClause}
          WHERE id = $${values.length}
          RETURNING id, name
        `;
        
        // Execute the update
        const updateResult = await pool.query(query, values);
        
        if (updateResult.rowCount > 0) {
          console.log(`✅ Updated sensory details for "${show.name}"`);
          updatedCount++;
        } else {
          console.error(`❌ Failed to update "${show.name}" in database`);
          errorCount++;
        }
      } catch (error) {
        console.error(`Error updating sensory details for "${show.name}":`, error);
        errorCount++;
      }
    }
    
    console.log('\nSensory details update complete:');
    console.log(`✅ Updated: ${updatedCount} shows`);
    console.log(`⏭️ Skipped: ${skippedCount} shows`);
    console.log(`❌ Errors: ${errorCount} shows`);
    console.log(`📊 Total processed: ${shows.length} shows`);
    
  } catch (error) {
    console.error('Fatal error in sensory details update process:', error);
  } finally {
    await pool.end();
  }
}

// Run the appropriate function based on command line argument when run directly
if (import.meta.url === `file://${process.argv[1]}`) {
  if (process.argv.includes('--consolidate')) {
    console.log('Running TV data consolidation process...');
    consolidateTvData().catch(console.error);
  } else if (process.argv.includes('--sensory')) {
    console.log('Running sensory details update process...');
    updateSensoryDetails().catch(console.error);
  } else {
    console.log('No command specified. Use one of:');
    console.log('  --consolidate  Consolidate TV show data from multiple sources');
    console.log('  --sensory      Update sensory details for TV shows');
  }
}

// Export functions for use in other modules - using ES Module exports
export {
  consolidateTvData,
  updateSensoryDetails,
  loadCustomShowDetails,
  saveCustomShowDetails,
  loadGoogleSheetsData,
  loadGitHubData,
  loadSensoryDetails,
  updateTvShow
};
</file>

<file path="drizzle.config.ts">
import { defineConfig } from "drizzle-kit";

if (!process.env.DATABASE_URL) {
  throw new Error("DATABASE_URL, ensure the database is provisioned");
}

export default defineConfig({
  out: "./migrations",
  schema: "./shared/schema.ts",
  dialect: "postgresql",
  dbCredentials: {
    url: process.env.DATABASE_URL,
  },
});
</file>

<file path="extract-skool-research.js">
/**
 * Skool Research Extractor (Simplified Version)
 * 
 * This script logs into a Skool community and extracts research summaries
 * into a JSON file for review before database import.
 */

import puppeteer from 'puppeteer';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get __dirname equivalent in ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Configuration
const SKOOL_URL = 'https://www.skool.com/screen-time-community/classroom/e5da82d5?md=869d5a30cf1144e29cdbf7ec0ed6ca30';
const OUTPUT_FOLDER = './extracted_research';
const IMAGES_FOLDER = './public/research';

// Ensure output directories exist
if (!fs.existsSync(OUTPUT_FOLDER)) {
  fs.mkdirSync(OUTPUT_FOLDER, { recursive: true });
}
if (!fs.existsSync(IMAGES_FOLDER)) {
  fs.mkdirSync(IMAGES_FOLDER, { recursive: true });
}

/**
 * Main extraction function
 */
async function extractResearchFromSkool(email, password) {
  console.log('Starting Skool research extraction...');
  
  const browser = await puppeteer.launch({
    headless: false, // Set to true for production
    defaultViewport: { width: 1366, height: 768 }
  });
  
  try {
    const page = await browser.newPage();
    
    // Login to Skool
    console.log('Logging in to Skool...');
    await page.goto(SKOOL_URL, { waitUntil: 'networkidle2' });
    
    // Check if we need to log in
    const isLoggedIn = await page.evaluate(() => {
      return !document.querySelector('input[type="email"]');
    });
    
    if (!isLoggedIn) {
      // Fill login form
      await page.type('input[type="email"]', email);
      await page.type('input[type="password"]', password);
      await page.click('button[type="submit"]');
      await page.waitForNavigation({ waitUntil: 'networkidle2' });
      
      console.log('Login successful');
    } else {
      console.log('Already logged in');
    }
    
    // Wait for the content to load
    await page.waitForSelector('.classroom-content', { timeout: 30000 });
    
    // Extract all categories (bold text items on the left)
    const categories = await page.evaluate(() => {
      const categoryElements = Array.from(document.querySelectorAll('.sidebar-section-title'));
      return categoryElements.map(el => el.textContent.trim());
    });
    
    console.log(`Found ${categories.length} research categories`);
    console.log('Categories:', categories);
    
    // Extracted research data
    const researchData = [];
    
    // Process each category
    for (let categoryIndex = 0; categoryIndex < categories.length; categoryIndex++) {
      // Click to expand the category
      const categoryElements = await page.$$('.sidebar-section-title');
      await categoryElements[categoryIndex].click();
      await page.waitForTimeout(1000); // Wait for animation
      
      const categoryName = await page.evaluate(el => el.textContent.trim(), categoryElements[categoryIndex]);
      console.log(`Processing category: ${categoryName}`);
      
      // Get all summaries under this category
      const summaryElements = await page.$$(`[data-testid="sidebar-lesson-name"]`);
      
      // Filter visible summaries (those belonging to the current expanded category)
      const visibleSummaries = [];
      for (const el of summaryElements) {
        const isVisible = await page.evaluate(e => {
          const section = e.closest('.sidebar-section');
          return section && window.getComputedStyle(section).display !== 'none';
        }, el);
        
        if (isVisible) {
          const title = await page.evaluate(e => e.textContent.trim(), el);
          visibleSummaries.push({ element: el, title });
        }
      }
      
      console.log(`Found ${visibleSummaries.length} summaries in category: ${categoryName}`);
      
      // Process each summary in this category
      for (let i = 0; i < visibleSummaries.length; i++) {
        const summary = visibleSummaries[i];
        console.log(`Processing summary: ${summary.title}`);
        
        // Click on the summary to view its content
        await summary.element.click();
        await page.waitForTimeout(2000); // Wait for content to load
        
        // Extract the summary content
        const content = await page.evaluate(() => {
          // Get the main content area
          const contentArea = document.querySelector('.lesson-content');
          if (!contentArea) return null;
          
          // Extract title
          const titleElement = contentArea.querySelector('h1, h2, h3');
          const title = titleElement ? titleElement.textContent.trim() : 'Untitled Research';
          
          // Extract full text
          const paragraphs = Array.from(contentArea.querySelectorAll('p, li, h4, h5, h6'));
          const fullText = paragraphs.map(p => p.textContent.trim()).join('\n\n');
          
          // Extract summary (first paragraph or two)
          const summaryText = paragraphs.slice(0, 2).map(p => p.textContent.trim()).join(' ');
          
          // Extract source link if present
          const links = Array.from(contentArea.querySelectorAll('a[href*="http"]'));
          let source = null;
          let sourceLink = null;
          
          for (const link of links) {
            const text = link.textContent.toLowerCase().trim();
            if (text.includes('study') || text.includes('research') || text.includes('source') || 
                text.includes('journal') || text.includes('article')) {
              source = link.textContent.trim();
              sourceLink = link.href;
              break;
            }
          }
          
          // Look for images
          const images = Array.from(contentArea.querySelectorAll('img')).map(img => img.src)
            .filter(src => src && !src.includes('avatar') && !src.includes('profile') && !src.includes('logo'));
          
          return {
            title,
            summary: summaryText.length > 300 ? summaryText.substring(0, 300) + '...' : summaryText,
            fullText,
            source,
            sourceLink,
            images
          };
        });
        
        if (!content) {
          console.log('Could not extract content, skipping');
          continue;
        }
        
        // Download the first image if available
        let imagePath = null;
        if (content.images && content.images.length > 0) {
          const imageUrl = content.images[0];
          const imageFileName = `${categoryName.toLowerCase().replace(/[^a-z0-9]/g, '-')}-${
            content.title.toLowerCase().replace(/[^a-z0-9]/g, '-')
          }.jpg`;
          
          imagePath = `/research/${imageFileName}`;
          const fullImagePath = path.join(IMAGES_FOLDER, imageFileName);
          
          try {
            // Download the image
            console.log(`Downloading image from ${imageUrl}`);
            const imageResponse = await page.goto(imageUrl);
            const imageBuffer = await imageResponse.buffer();
            fs.writeFileSync(fullImagePath, imageBuffer);
            console.log(`Saved image: ${fullImagePath}`);
            
            // Go back to the classroom page
            await page.goto(SKOOL_URL, { waitUntil: 'networkidle2' });
            await page.waitForSelector('.classroom-content', { timeout: 30000 });
            
            // Re-expand the category
            const categoryElements = await page.$$('.sidebar-section-title');
            await categoryElements[categoryIndex].click();
            await page.waitForTimeout(1000);
          } catch (err) {
            console.error(`Error downloading image: ${err.message}`);
            imagePath = null;
            
            // Go back to the classroom page
            await page.goto(SKOOL_URL, { waitUntil: 'networkidle2' });
            await page.waitForSelector('.classroom-content', { timeout: 30000 });
            
            // Re-expand the category
            const categoryElements = await page.$$('.sidebar-section-title');
            await categoryElements[categoryIndex].click();
            await page.waitForTimeout(1000);
          }
        }
        
        // Add to research data
        researchData.push({
          title: content.title,
          summary: content.summary,
          fullText: content.fullText,
          source: content.source || content.sourceLink,
          category: categoryName,
          imageUrl: imagePath,
          publishedDate: new Date().toISOString() // Default to current date if not available
        });
      }
      
      // Close the category before moving to the next one
      await categoryElements[categoryIndex].click();
    }
    
    // Save the extracted data
    const outputPath = path.join(OUTPUT_FOLDER, 'research_data.json');
    fs.writeFileSync(outputPath, JSON.stringify(researchData, null, 2));
    console.log(`Research data saved to ${outputPath}`);
    
    return researchData;
    
  } catch (error) {
    console.error('Error during extraction:', error);
    throw error;
  } finally {
    await browser.close();
  }
}

/**
 * Main execution function
 */
async function main() {
  try {
    // Get credentials from command line args or prompt
    const email = process.argv[2];
    const password = process.argv[3];
    
    if (!email || !password) {
      console.error('Please provide Skool email and password');
      console.log('Usage: node extract-skool-research.js <email> <password>');
      process.exit(1);
    }
    
    // Extract research data
    const researchData = await extractResearchFromSkool(email, password);
    console.log(`Extraction complete! Extracted ${researchData.length} research summaries.`);
    
    // Create SQL insert statements for review
    const sqlPath = path.join(OUTPUT_FOLDER, 'research_inserts.sql');
    
    let sqlContent = '';
    for (const research of researchData) {
      sqlContent += `INSERT INTO research_summaries (title, summary, full_text, source, category, image_url, published_date, created_at, updated_at)\n`;
      sqlContent += `VALUES (\n`;
      sqlContent += `  '${research.title.replace(/'/g, "''")}'::text,\n`;
      sqlContent += `  '${research.summary.replace(/'/g, "''")}'::text,\n`;
      sqlContent += `  '${research.fullText.replace(/'/g, "''")}'::text,\n`;
      sqlContent += `  '${(research.source || '').replace(/'/g, "''")}'::text,\n`;
      sqlContent += `  '${research.category.replace(/'/g, "''")}'::text,\n`;
      sqlContent += `  ${research.imageUrl ? `'${research.imageUrl}'::text` : 'NULL'},\n`;
      sqlContent += `  '${research.publishedDate}'::timestamp,\n`;
      sqlContent += `  NOW(),\n`;
      sqlContent += `  NOW()\n`;
      sqlContent += `);\n\n`;
    }
    
    fs.writeFileSync(sqlPath, sqlContent);
    console.log(`SQL insert statements saved to ${sqlPath}`);
    
  } catch (error) {
    console.error('Fatal error:', error);
    process.exit(1);
  }
}

// Execute the script when run directly
if (import.meta.url === `file://${process.argv[1]}`) {
  main();
}

export { extractResearchFromSkool };
</file>

<file path="image-manager.js">
/**
 * Consolidated Image Management Utility
 * 
 * This script replaces multiple overlapping image management scripts:
 * - map-custom-images.js
 * - update-custom-images.js
 * - restore-custom-images.js
 * - consolidate-images.js
 * 
 * Features:
 * - Maps custom images to TV shows
 * - Restores custom images from backup
 * - Consolidates images into a single directory
 * - Maintains image mappings in customImageMap.json
 */

import fs from 'fs';
import path from 'path';
import { Pool } from 'pg';
import dotenv from 'dotenv';
import { fileURLToPath } from 'url';

dotenv.config();

// Get __dirname equivalent in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Database connection
const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
});

// File paths
const customImageMapPath = path.join(__dirname, 'data', 'custom-image-map.json');
const customImagesDir = path.join(__dirname, 'public', 'custom-images');
const uploadsDir = path.join(__dirname, 'public', 'uploads');

// Make sure directories exist
if (!fs.existsSync(customImagesDir)) {
  fs.mkdirSync(customImagesDir, { recursive: true });
}

if (!fs.existsSync(uploadsDir)) {
  fs.mkdirSync(uploadsDir, { recursive: true });
}

/**
 * Load the custom image map from file
 */
function loadCustomImageMap() {
  try {
    if (fs.existsSync(customImageMapPath)) {
      const data = fs.readFileSync(customImageMapPath, 'utf8');
      return JSON.parse(data);
    }
    return {};
  } catch (error) {
    console.error('Error loading custom image map:', error);
    return {};
  }
}

/**
 * Save the custom image map to file
 */
function saveCustomImageMap(customImageMap) {
  try {
    fs.writeFileSync(customImageMapPath, JSON.stringify(customImageMap, null, 2));
    console.log('Custom image map saved successfully');
    return true;
  } catch (error) {
    console.error('Error saving custom image map:', error);
    return false;
  }
}

/**
 * Update a single entry in the custom image map
 */
function updateCustomImageMap(showId, imageUrl) {
  try {
    const customImageMap = loadCustomImageMap();
    customImageMap[showId] = imageUrl;
    saveCustomImageMap(customImageMap);
    return true;
  } catch (error) {
    console.error(`Error updating custom image map for show ID ${showId}:`, error);
    return false;
  }
}

/**
 * Utility to clean text for comparing show names
 */
function cleanText(text) {
  if (!text) return '';
  return text
    .toLowerCase()
    .replace(/[^a-z0-9]/g, '') // Remove non-alphanumeric characters
    .replace(/\s+/g, '');      // Remove whitespace
}

/**
 * Find a TV show that matches an image filename
 */
async function findMatchingShow(imageFile, shows) {
  // Extract name from filename: "show-name.jpg" -> "show name"
  const filenameBase = path.basename(imageFile, path.extname(imageFile))
    .replace(/[-_]/g, ' ')
    .trim();
  
  // Clean the filename for comparison
  const cleanFilename = cleanText(filenameBase);
  
  // Try exact match first
  for (const show of shows) {
    const cleanShowName = cleanText(show.name);
    if (cleanShowName === cleanFilename) {
      console.log(`✅ Found exact match: "${show.name}" for image "${imageFile}"`);
      return show;
    }
  }
  
  // Try contains match
  for (const show of shows) {
    const cleanShowName = cleanText(show.name);
    if (cleanShowName.includes(cleanFilename) || cleanFilename.includes(cleanShowName)) {
      console.log(`✅ Found partial match: "${show.name}" for image "${imageFile}"`);
      return show;
    }
  }
  
  console.log(`❌ No match found for image: ${imageFile}`);
  return null;
}

/**
 * Update a show's image URL in the database
 */
async function updateShowImageUrl(showId, imageUrl) {
  try {
    const result = await pool.query(
      'UPDATE tv_shows SET image_url = $1 WHERE id = $2 RETURNING id, name',
      [imageUrl, showId]
    );
    
    if (result.rowCount === 1) {
      console.log(`Updated image URL for show ID ${showId}: ${result.rows[0].name}`);
      return true;
    } else {
      console.error(`Failed to update image URL for show ID ${showId}`);
      return false;
    }
  } catch (error) {
    console.error(`Error updating image URL for show ID ${showId}:`, error);
    return false;
  }
}

/**
 * Process and map all custom images to shows
 */
async function mapCustomImages() {
  try {
    console.log('Starting custom image mapping process...');
    
    // Load existing image map
    const customImageMap = loadCustomImageMap();
    
    // Get all images in the custom images directory
    const imageFiles = fs.readdirSync(customImagesDir)
      .filter(file => /\.(jpg|jpeg|png|gif)$/i.test(file))
      .map(file => path.join(customImagesDir, file));
    
    console.log(`Found ${imageFiles.length} custom images to process`);
    
    // Get all TV shows from the database
    const result = await pool.query('SELECT id, name FROM tv_shows ORDER BY name');
    const shows = result.rows;
    
    console.log(`Found ${shows.length} TV shows in the database`);
    
    // Statistics
    let mapped = 0;
    let errors = 0;
    let skipped = 0;
    
    // Process each image
    for (const imageFile of imageFiles) {
      try {
        const relativePath = path.relative(process.cwd(), imageFile).replace(/\\/g, '/');
        const webPath = `/${relativePath}`;
        
        // Find a matching show
        const show = await findMatchingShow(imageFile, shows);
        
        if (show) {
          // Check if we already have a mapping for this show
          if (customImageMap[show.id]) {
            console.log(`Skipping - show ID ${show.id} already has a custom image: ${customImageMap[show.id]}`);
            skipped++;
            continue;
          }
          
          // Update the image map
          customImageMap[show.id] = webPath;
          
          // Update the database
          const updated = await updateShowImageUrl(show.id, webPath);
          if (updated) {
            console.log(`✅ Mapped image ${webPath} to show "${show.name}" (ID: ${show.id})`);
            mapped++;
          } else {
            console.error(`❌ Failed to update database for show "${show.name}"`);
            errors++;
          }
        } else {
          skipped++;
        }
      } catch (error) {
        console.error(`Error processing image ${imageFile}:`, error);
        errors++;
      }
    }
    
    // Save the updated image map
    saveCustomImageMap(customImageMap);
    
    console.log('\nImage mapping complete:');
    console.log(`✅ Mapped: ${mapped}`);
    console.log(`⏭️ Skipped: ${skipped}`);
    console.log(`❌ Errors: ${errors}`);
    console.log(`📊 Total processed: ${imageFiles.length}`);
    
  } catch (error) {
    console.error('Fatal error in image mapping process:', error);
  } finally {
    await pool.end();
  }
}

/**
 * Restore all custom images from the image map
 */
async function restoreCustomImages() {
  try {
    console.log('Starting custom image restoration process...');
    
    // Load the custom image map
    const customImageMap = loadCustomImageMap();
    const showIds = Object.keys(customImageMap);
    
    console.log(`Found ${showIds.length} custom image mappings to restore`);
    
    // Statistics
    let restored = 0;
    let errors = 0;
    let skipped = 0;
    
    // Process each mapping
    for (const showId of showIds) {
      try {
        const imageUrl = customImageMap[showId];
        
        // Get current image URL from database
        const showResult = await pool.query(
          'SELECT name, image_url FROM tv_shows WHERE id = $1',
          [showId]
        );
        
        if (showResult.rowCount === 0) {
          console.log(`Skipping - show ID ${showId} not found in database`);
          skipped++;
          continue;
        }
        
        const show = showResult.rows[0];
        
        // Skip if current image URL matches the custom one
        if (show.image_url === imageUrl) {
          console.log(`Skipping - show "${show.name}" already has the correct image: ${imageUrl}`);
          skipped++;
          continue;
        }
        
        // Check if image file exists
        const imagePath = path.join(process.cwd(), imageUrl.replace(/^\//, ''));
        if (!fs.existsSync(imagePath)) {
          console.error(`❌ Image file not found: ${imagePath}`);
          errors++;
          continue;
        }
        
        // Update the database
        const updated = await updateShowImageUrl(showId, imageUrl);
        if (updated) {
          console.log(`✅ Restored custom image for show "${show.name}" (ID: ${showId})`);
          restored++;
        } else {
          console.error(`❌ Failed to update database for show "${show.name}"`);
          errors++;
        }
      } catch (error) {
        console.error(`Error restoring image for show ID ${showId}:`, error);
        errors++;
      }
    }
    
    console.log('\nImage restoration complete:');
    console.log(`✅ Restored: ${restored}`);
    console.log(`⏭️ Skipped: ${skipped}`);
    console.log(`❌ Errors: ${errors}`);
    console.log(`📊 Total processed: ${showIds.length}`);
    
  } catch (error) {
    console.error('Fatal error in image restoration process:', error);
  } finally {
    await pool.end();
  }
}

/**
 * Consolidate all images into a single directory
 */
async function consolidateImages() {
  try {
    console.log('Starting image consolidation process...');
    
    // Create the uploads directory if it doesn't exist
    if (!fs.existsSync(uploadsDir)) {
      fs.mkdirSync(uploadsDir, { recursive: true });
    }
    
    // Get all TV shows with images
    const result = await pool.query(
      'SELECT id, name, image_url FROM tv_shows WHERE image_url IS NOT NULL'
    );
    
    const shows = result.rows;
    console.log(`Found ${shows.length} shows with images to process`);
    
    // Statistics
    let consolidated = 0;
    let errors = 0;
    let skipped = 0;
    
    // Load the custom image map
    const customImageMap = loadCustomImageMap();
    
    // Process each show
    for (const show of shows) {
      try {
        const { id, name, image_url } = show;
        
        // Skip if image is already in uploads directory
        if (image_url && image_url.startsWith('/uploads/')) {
          console.log(`Skipping - show "${name}" already has image in uploads directory: ${image_url}`);
          skipped++;
          continue;
        }
        
        // Skip external URLs (we'll handle these separately)
        if (image_url && image_url.startsWith('http')) {
          console.log(`Skipping external URL for "${name}": ${image_url}`);
          skipped++;
          continue;
        }
        
        // Process local image
        if (image_url && image_url.startsWith('/')) {
          // Try to locate the file
          const localPath = path.join(process.cwd(), image_url.replace(/^\//, ''));
          
          if (fs.existsSync(localPath)) {
            // Generate new filename in uploads directory
            const ext = path.extname(localPath) || '.jpg';
            const newFilename = `show-${id}-${Date.now()}${ext}`;
            const newPath = path.join(uploadsDir, newFilename);
            
            // Copy file to new location
            fs.copyFileSync(localPath, newPath);
            
            // Update web path
            const newWebPath = `/uploads/${newFilename}`;
            
            // Update database
            const updated = await updateShowImageUrl(id, newWebPath);
            
            if (updated) {
              // Update custom image map if needed
              if (customImageMap[id] === image_url) {
                customImageMap[id] = newWebPath;
              }
              
              console.log(`✅ Consolidated image for "${name}": ${image_url} -> ${newWebPath}`);
              consolidated++;
            } else {
              console.error(`❌ Failed to update database for "${name}"`);
              errors++;
            }
          } else {
            console.error(`❌ Image file not found for "${name}": ${localPath}`);
            errors++;
          }
        } else {
          console.log(`Skipping - show "${name}" has no valid image URL`);
          skipped++;
        }
      } catch (error) {
        console.error(`Error consolidating image for "${show.name}":`, error);
        errors++;
      }
    }
    
    // Save updated custom image map
    saveCustomImageMap(customImageMap);
    
    console.log('\nImage consolidation complete:');
    console.log(`✅ Consolidated: ${consolidated}`);
    console.log(`⏭️ Skipped: ${skipped}`);
    console.log(`❌ Errors: ${errors}`);
    console.log(`📊 Total processed: ${shows.length}`);
    
  } catch (error) {
    console.error('Fatal error in image consolidation process:', error);
  } finally {
    await pool.end();
  }
}

// Run the appropriate function based on command line argument when run directly
if (import.meta.url === `file://${process.argv[1]}`) {
  if (process.argv.includes('--map')) {
    console.log('Running image mapping process...');
    mapCustomImages().catch(console.error);
  } else if (process.argv.includes('--restore')) {
    console.log('Running image restoration process...');
    restoreCustomImages().catch(console.error);
  } else if (process.argv.includes('--consolidate')) {
    console.log('Running image consolidation process...');
    consolidateImages().catch(console.error);
  } else {
    console.log('No command specified. Use one of:');
    console.log('  --map        Map custom images to TV shows');
    console.log('  --restore    Restore custom images from backup');
    console.log('  --consolidate Consolidate images into a single directory');
  }
}

// Export functions for use in other modules - ES Module exports
export {
  mapCustomImages,
  restoreCustomImages,
  consolidateImages,
  updateCustomImageMap,
  loadCustomImageMap,
  saveCustomImageMap,
  updateShowImageUrl
};
</file>

<file path="image-optimizer.js">
/**
 * Consolidated Image Optimization Utility
 * 
 * This script replaces multiple overlapping image optimization scripts:
 * - optimize-custom-images.js
 * - optimize-seo-images.js
 * 
 * Features:
 * - Optimizes images for better SEO and performance
 * - Handles both local and remote images
 * - Updates database with optimized image URLs
 * - Preserves custom image mappings
 * - Creates properly sized portrait-style images
 */

import { db } from './server/db.js';
import sharp from 'sharp';
import fetch from 'node-fetch';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get current file directory (ES modules don't have __dirname)
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Create directories if they don't exist
const imageDir = './public/uploads';
const optimizedImageDir = './public/uploads/optimized';
const customImageMapPath = './data/custom-image-map.json';

if (!fs.existsSync(imageDir)) {
  fs.mkdirSync(imageDir, { recursive: true });
}

if (!fs.existsSync(optimizedImageDir)) {
  fs.mkdirSync(optimizedImageDir, { recursive: true });
}

/**
 * Load the custom image map from file
 */
function loadCustomImageMap() {
  try {
    if (fs.existsSync(customImageMapPath)) {
      const data = fs.readFileSync(customImageMapPath, 'utf8');
      return JSON.parse(data);
    }
    return {};
  } catch (error) {
    console.error('Error loading custom image map:', error);
    return {};
  }
}

/**
 * Save the custom image map to file
 */
function saveCustomImageMap(customImageMap) {
  try {
    fs.writeFileSync(customImageMapPath, JSON.stringify(customImageMap, null, 2));
    console.log('Custom image map saved successfully');
    return true;
  } catch (error) {
    console.error('Error saving custom image map:', error);
    return false;
  }
}

/**
 * Update a single entry in the custom image map
 */
function updateCustomImageMap(showId, imageUrl) {
  try {
    const customImageMap = loadCustomImageMap();
    customImageMap[showId] = imageUrl;
    saveCustomImageMap(customImageMap);
    return true;
  } catch (error) {
    console.error(`Error updating custom image map for show ID ${showId}:`, error);
    return false;
  }
}

/**
 * Get all shows with custom images that need optimization
 */
async function getShowsWithCustomImages() {
  const query = `
    SELECT id, name, image_url 
    FROM tv_shows 
    WHERE image_url IS NOT NULL 
      AND image_url NOT LIKE '%/uploads/optimized/%'
      AND image_url NOT LIKE '%m.media-amazon.com%'
      AND image_url NOT LIKE '%omdbapi.com%'
  `;
  
  try {
    const result = await db.query(query);
    return result.rows;
  } catch (error) {
    console.error('Error getting shows with custom images:', error);
    return [];
  }
}

/**
 * Downloads or copies an image from URL or local path
 */
async function getImage(imageUrl, showId) {
  try {
    if (!imageUrl) {
      return null;
    }
    
    // Skip already optimized images
    if (imageUrl.includes('/uploads/optimized/')) {
      return null;
    }

    // Handle local file paths
    if (imageUrl.startsWith('/')) {
      // Try different possible locations
      const possiblePaths = [
        path.join('public', imageUrl),
        path.join('public', 'uploads', path.basename(imageUrl)),
        path.join('public', 'custom-images', path.basename(imageUrl)),
        path.join('public', 'images', path.basename(imageUrl)),
        path.join('attached_assets', path.basename(imageUrl)),
        imageUrl.substring(1) // Try without leading slash
      ];
      
      for (const localPath of possiblePaths) {
        if (fs.existsSync(localPath)) {
          console.log(`Found local image at ${localPath}`);
          
          // Create a copy in uploads directory
          const timestamp = Date.now();
          const uniqueFilename = `show-${showId}-${timestamp}${path.extname(localPath) || '.jpg'}`;
          const tempPath = path.join(imageDir, uniqueFilename);
          
          fs.copyFileSync(localPath, tempPath);
          return tempPath;
        }
      }
      
      console.log(`Could not find local image: ${imageUrl}`);
      return null;
    }
    
    // Download remote URLs
    if (imageUrl.startsWith('http')) {
      try {
        const response = await fetch(imageUrl);
        if (!response.ok) {
          console.error(`Failed to download: ${response.status}`);
          return null;
        }
        
        const buffer = await response.buffer();
        const timestamp = Date.now();
        const uniqueFilename = `show-${showId}-${timestamp}.jpg`;
        const tempPath = path.join(imageDir, uniqueFilename);
        
        fs.writeFileSync(tempPath, buffer);
        return tempPath;
      } catch (error) {
        console.error(`Download error: ${error.message}`);
        return null;
      }
    }
    
    return null;
  } catch (error) {
    console.error(`Error getting image: ${error.message}`);
    return null;
  }
}

/**
 * Optimizes an image for web use
 */
async function optimizeImage(filePath, showId) {
  try {
    const ext = path.extname(filePath);
    const filename = path.basename(filePath, ext);
    const optimizedFilename = `${filename}-optimized.jpg`;
    const optimizedPath = path.join(optimizedImageDir, optimizedFilename);
    
    // Get image metadata
    const metadata = await sharp(filePath).metadata();
    const width = metadata.width || 800;
    const height = metadata.height || 600;
    
    // Target portrait-style dimensions
    let targetWidth, targetHeight;
    
    if (height >= width) {
      // Already portrait
      targetWidth = Math.min(width, 600);
      targetHeight = Math.round((targetWidth / width) * height);
      
      // Cap height for very tall images
      if (targetHeight > 900) {
        targetHeight = 900;
        targetWidth = Math.round((targetHeight / height) * width);
      }
    } else {
      // Convert landscape to portrait-friendly
      targetHeight = Math.min(height, 800);
      targetWidth = Math.min(width, Math.round(targetHeight * 0.75));
    }
    
    // Optimize the image
    await sharp(filePath)
      .resize(targetWidth, targetHeight, {
        fit: 'contain',
        background: { r: 255, g: 255, b: 255, alpha: 1 }
      })
      .jpeg({ quality: 85, progressive: true })
      .toFile(optimizedPath);
    
    console.log(`Optimized to ${targetWidth}x${targetHeight}`);
    
    // Return web path
    return `/uploads/optimized/${optimizedFilename}`;
  } catch (error) {
    console.error(`Optimization error: ${error.message}`);
    return null;
  }
}

/**
 * Updates a show's image URL in the database
 */
async function updateShowImage(showId, optimizedUrl) {
  try {
    await db.query(
      'UPDATE tv_shows SET image_url = $1 WHERE id = $2 RETURNING id, name',
      [optimizedUrl, showId]
    );
    
    // Also update custom image map
    updateCustomImageMap(showId, optimizedUrl);
    
    return true;
  } catch (error) {
    console.error(`Database update error: ${error.message}`);
    return false;
  }
}

/**
 * Main function to optimize all images
 */
async function optimizeAllImages() {
  console.log('Starting image optimization process...');
  
  try {
    // Get shows that need optimization
    const shows = await getShowsWithCustomImages();
    console.log(`Found ${shows.length} shows with custom images to optimize`);
    
    let optimized = 0;
    let skipped = 0;
    let errors = 0;
    
    // Process each show
    for (const show of shows) {
      try {
        console.log(`\nProcessing: ${show.name} (ID: ${show.id})`);
        
        // Get image file
        const imagePath = await getImage(show.image_url, show.id);
        if (!imagePath) {
          console.log(`Skipping - could not access image for ${show.name}`);
          skipped++;
          continue;
        }
        
        // Optimize image
        const optimizedUrl = await optimizeImage(imagePath, show.id);
        if (!optimizedUrl) {
          console.error(`Failed to optimize image for ${show.name}`);
          errors++;
          continue;
        }
        
        // Update in database
        const updated = await updateShowImage(show.id, optimizedUrl);
        if (updated) {
          console.log(`✅ Successfully optimized image for ${show.name}`);
          optimized++;
        } else {
          console.error(`❌ Failed to update database for ${show.name}`);
          errors++;
        }
        
        // Clean up temp file
        try {
          if (imagePath.startsWith(imageDir)) {
            fs.unlinkSync(imagePath);
          }
        } catch (e) {
          // Ignore cleanup errors
        }
        
      } catch (error) {
        console.error(`Error processing ${show.name}: ${error.message}`);
        errors++;
      }
    }
    
    console.log('\nOptimization complete:');
    console.log(`✅ Optimized: ${optimized}`);
    console.log(`⏭️ Skipped: ${skipped}`);
    console.log(`❌ Errors: ${errors}`);
    console.log(`📊 Total processed: ${shows.length}`);
    
  } catch (error) {
    console.error('Fatal error:', error);
  } finally {
    // Close database connection when done
    await db.end();
  }
}

// Run the optimization when this file is executed directly
if (process.argv[1] === fileURLToPath(import.meta.url)) {
  console.log('Starting image optimization as a direct script...');
  optimizeAllImages().catch(console.error);
}

// Export functions for use in other modules
export {
  optimizeImage,
  optimizeAllImages,
  updateShowImage,
  getImage,
  loadCustomImageMap,
  saveCustomImageMap,
  updateCustomImageMap
};
</file>

<file path="import-custom-images.js">
/**
 * Imports custom images from a zipped folder into the system
 * and updates the customImageMap.json file
 * 
 * Features:
 * - Extracts images from zip file to client/public/custom-images
 * - Updates customImageMap.json with new image mappings
 * - Automatically updates database with custom images
 * - Never overwrites existing custom images
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import AdmZip from 'adm-zip';
import pg from 'pg';
const { Pool } = pg;
const db = new Pool({
  connectionString: process.env.DATABASE_URL,
});
// Custom image map handling functions
function loadCustomImageMap() {
  try {
    const filePath = path.join(process.cwd(), 'customImageMap.json');
    if (fs.existsSync(filePath)) {
      const data = fs.readFileSync(filePath, 'utf-8');
      return JSON.parse(data);
    }
  } catch (error) {
    console.error('Error loading custom image map:', error);
  }
  return {};
}

function saveCustomImageMap(customImageMap) {
  try {
    const filePath = path.join(process.cwd(), 'customImageMap.json');
    fs.writeFileSync(filePath, JSON.stringify(customImageMap, null, 2));
  } catch (error) {
    console.error('Error saving custom image map:', error);
  }
}

function updateCustomImageMap(showId, imageUrl) {
  const customImageMap = loadCustomImageMap();
  customImageMap[showId.toString()] = imageUrl;
  saveCustomImageMap(customImageMap);
}

// Get the current file's directory (ES modules don't have __dirname)
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Path to the custom images directory
const CUSTOM_IMAGES_DIR = path.join(__dirname, 'client', 'public', 'custom-images');
const PUBLIC_IMAGES_DIR = path.join(__dirname, 'public', 'custom-images');

// Create directories if they don't exist
if (!fs.existsSync(CUSTOM_IMAGES_DIR)) {
  fs.mkdirSync(CUSTOM_IMAGES_DIR, { recursive: true });
  console.log(`Created custom images directory: ${CUSTOM_IMAGES_DIR}`);
}

if (!fs.existsSync(PUBLIC_IMAGES_DIR)) {
  fs.mkdirSync(PUBLIC_IMAGES_DIR, { recursive: true });
  console.log(`Created public directory symlink: ${PUBLIC_IMAGES_DIR}`);
}

/**
 * Extract images from a zip file
 */
async function extractImagesFromZip(zipFilePath) {
  console.log(`Extracting images from ${zipFilePath}`);
  
  try {
    // Open the zip file
    const zip = new AdmZip(zipFilePath);
    const zipEntries = zip.getEntries();
    
    // Count of images extracted
    let extractedCount = 0;
    
    // Extract each image file
    for (const entry of zipEntries) {
      // Skip directories and non-image files
      if (entry.isDirectory || !isImageFile(entry.name)) {
        continue;
      }
      
      // Clean the filename (remove any path info)
      const fileName = path.basename(entry.entryName);
      
      // Extract to the custom images directory
      zip.extractEntryTo(entry, CUSTOM_IMAGES_DIR, false, true);
      
      // Also copy to the public directory for development mode
      const entryData = zip.readFile(entry);
      fs.writeFileSync(path.join(PUBLIC_IMAGES_DIR, fileName), entryData);
      
      extractedCount++;
      
      console.log(`Extracted: ${fileName}`);
    }
    
    console.log(`Extracted ${extractedCount} images to ${CUSTOM_IMAGES_DIR}`);
    return true;
  } catch (err) {
    console.error('Error extracting zip file:', err);
    return false;
  }
}

/**
 * Check if a file is an image based on extension
 */
function isImageFile(filename) {
  const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.avif'];
  const ext = path.extname(filename).toLowerCase();
  return imageExtensions.includes(ext);
}

/**
 * Map images to shows based on filename matches
 */
async function mapImagesToShows() {
  console.log('Mapping images to shows based on filenames...');
  
  try {
    // Get all image files in the custom images directory
    const imageFiles = fs.readdirSync(CUSTOM_IMAGES_DIR)
      .filter(file => isImageFile(file));
    
    console.log(`Found ${imageFiles.length} image files`);
    
    // Get all shows from the database
    const shows = await db.query('SELECT id, name FROM tv_shows');
    
    console.log(`Found ${shows.rows.length} shows in the database`);
    
    // Load the existing custom image map
    const customImageMap = loadCustomImageMap();
    let newMappingsCount = 0;
    
    // Map each image file to a show if the filename matches
    for (const imageFile of imageFiles) {
      const imagePath = '/custom-images/' + imageFile;
      
      // Skip already mapped images to prevent duplicate assignments
      const existingMapping = Object.values(customImageMap).find(url => url === imagePath);
      if (existingMapping) {
        console.log(`Image ${imageFile} is already mapped, skipping`);
        continue;
      }
      
      // Try to find a show that matches the image filename
      const matchingShow = findMatchingShow(shows.rows, imageFile);
      
      if (matchingShow) {
        // Update the custom image map
        customImageMap[matchingShow.id] = imagePath;
        newMappingsCount++;
        
        console.log(`Mapped image ${imageFile} to show: ${matchingShow.name} (ID: ${matchingShow.id})`);
      } else {
        console.log(`Could not find a matching show for image: ${imageFile}`);
      }
    }
    
    // Save the updated custom image map
    saveCustomImageMap(customImageMap);
    
    console.log(`Added ${newMappingsCount} new image mappings to customImageMap.json`);
    
    return customImageMap;
  } catch (err) {
    console.error('Error mapping images to shows:', err);
    return null;
  }
}

/**
 * Find a show that matches an image filename
 */
function findMatchingShow(shows, imageFilename) {
  // Remove extension and convert to lowercase
  const baseFilename = path.basename(imageFilename, path.extname(imageFilename)).toLowerCase();
  
  // Try exact match first
  for (const show of shows) {
    if (show.name.toLowerCase() === baseFilename) {
      return show;
    }
  }
  
  // Try partial match
  for (const show of shows) {
    if (baseFilename.includes(show.name.toLowerCase()) || 
        show.name.toLowerCase().includes(baseFilename)) {
      return show;
    }
  }
  
  return null;
}

/**
 * Update the database with the custom image URLs
 */
async function updateDatabaseWithImages(customImageMap) {
  console.log('Updating database with custom image URLs...');
  
  try {
    // Convert to an array of promises to update each show
    const updatePromises = Object.entries(customImageMap).map(async ([showId, imageUrl]) => {
      const result = await db.query(
        'UPDATE tv_shows SET "imageUrl" = $1 WHERE id = $2 RETURNING id, name, "imageUrl"',
        [imageUrl, showId]
      );
      
      if (result.rows.length > 0) {
        return result.rows[0];
      }
      return null;
    });
    
    // Execute all update queries
    const results = await Promise.all(updatePromises);
    
    // Filter out null results
    const updatedShows = results.filter(Boolean);
    
    console.log(`Updated ${updatedShows.length} shows in the database with custom images`);
    
    return updatedShows;
  } catch (err) {
    console.error('Error updating database with images:', err);
    return [];
  }
}

/**
 * Process a specific image for a specific show ID
 */
async function processImageForShow(showId, imageFile) {
  console.log(`Processing image ${imageFile} for show ID ${showId}`);
  
  try {
    // Copy image to custom images directory if it's not already there
    const sourceFile = path.resolve(imageFile);
    
    if (!fs.existsSync(sourceFile)) {
      console.error(`Source image file does not exist: ${sourceFile}`);
      return false;
    }
    
    const fileName = path.basename(sourceFile);
    const destFile = path.join(CUSTOM_IMAGES_DIR, fileName);
    const publicDestFile = path.join(PUBLIC_IMAGES_DIR, fileName);
    
    fs.copyFileSync(sourceFile, destFile);
    fs.copyFileSync(sourceFile, publicDestFile);
    
    // Update the custom image map
    const imagePath = '/custom-images/' + fileName;
    updateCustomImageMap(showId, imagePath);
    
    // Update the database
    const result = await db.query(
      'UPDATE tv_shows SET "imageUrl" = $1 WHERE id = $2 RETURNING id, name, "imageUrl"',
      [imagePath, showId]
    );
    
    if (result.rows.length > 0) {
      console.log(`Updated show ${result.rows[0].name} (ID: ${showId}) with image: ${imagePath}`);
      return true;
    }
    
    console.error(`Could not update show with ID ${showId}`);
    return false;
  } catch (err) {
    console.error(`Error processing image for show ${showId}:`, err);
    return false;
  }
}

/**
 * Main function to run the import
 */
async function main() {
  const args = process.argv.slice(2);
  
  if (args.length === 0) {
    console.log('Please provide the path to the zip file containing custom images');
    console.log('Usage: node import-custom-images.js path/to/images.zip');
    console.log('Or to process a single image: node import-custom-images.js --show-id=123 path/to/image.jpg');
    return;
  }
  
  // Check if processing a single image for a specific show
  if (args[0].startsWith('--show-id=')) {
    const showId = parseInt(args[0].split('=')[1]);
    const imageFile = args[1];
    
    if (isNaN(showId) || !imageFile) {
      console.error('Invalid arguments. Usage: node import-custom-images.js --show-id=123 path/to/image.jpg');
      return;
    }
    
    const success = await processImageForShow(showId, imageFile);
    
    if (success) {
      console.log('Successfully processed image for show');
    } else {
      console.error('Failed to process image for show');
    }
    
    return;
  }
  
  // Process a zip file
  const zipFilePath = args[0];
  
  if (!fs.existsSync(zipFilePath)) {
    console.error(`File not found: ${zipFilePath}`);
    return;
  }
  
  const success = await extractImagesFromZip(zipFilePath);
  
  if (success) {
    // Map images to shows
    const customImageMap = await mapImagesToShows();
    
    if (customImageMap) {
      // Update the database
      const updatedShows = await updateDatabaseWithImages(customImageMap);
      
      console.log(`Completed processing ${updatedShows.length} custom images`);
    }
  }
}

// Run the main function
main().catch(console.error);
</file>

<file path="manual-research-import.js">
/**
 * Manual Research Import Script
 * 
 * This script prepares SQL insert statements for research summaries
 * that can be directly executed in the database.
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get __dirname equivalent in ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Configuration
const OUTPUT_FOLDER = './extracted_research';

// Ensure output folder exists
if (!fs.existsSync(OUTPUT_FOLDER)) {
  fs.mkdirSync(OUTPUT_FOLDER, { recursive: true });
}

// Research data structure from screenshot
// Based on the hierarchy shown in the Skool community screenshot
const researchData = [
  // Learning and Cognitive Development
  {
    category: "Learning and Cognitive Development",
    items: [
      {
        title: "Media Content for Preschool Children",
        summary: "This study investigates whether altering the content of media consumed by preschool-aged children can influence their behavior, particularly in reducing aggression and enhancing prosocial behavior.",
        fullText: `The study titled "Modifying Media Content for Preschool Children: A Randomized Controlled Trial" investigates whether altering the content of media consumed by preschool-aged children can influence their behavior, particularly in reducing aggression and enhancing prosocial behavior.

Importance:
Preschool-aged children are highly impressionable and often imitate behaviors observed on screen. While previous studies have shown that children can mimic both aggressive and prosocial behaviors from media, there has been limited research on interventions aimed at reducing aggression by modifying media content. This study addresses this gap by exploring whether substituting aggressive content with prosocial and educational programming can positively impact child behavior.

Key Findings:
1. Behavioral Improvements:
   - Children in the intervention group exhibited a significant improvement in overall behavior scores at 6 months compared to the control group.
   - Notable enhancements were observed in externalizing behaviors (e.g., reduced aggression) and social competence.

2. Sustained Effects:
   - While the positive effects persisted at 12 months, the statistical significance for externalizing behaviors diminished, suggesting a need for ongoing reinforcement.

3. Subgroup Analysis:
   - Low-income boys derived the greatest benefit from the intervention, indicating the potential for targeted strategies in specific demographics.

Study Details:
- Population: 565 parents of preschool-aged children (3 to 5 years) recruited from community settings
- Intervention: Replaced violent/aggressive media content with prosocial/educational content for 6 months
- Assessment: Behavioral assessments conducted at baseline, 6 months, and 12 months using validated instruments
- Control: Standard media consumption without intervention

Conclusions and Implications:
The study demonstrates that strategic modification of media content can produce measurable improvements in preschoolers' behavior. These findings have important implications for parents, educators, and media creators, suggesting that intentional selection of prosocial and educational content can positively influence child development.

The authors recommend that pediatricians and child development specialists counsel parents about the importance of content selection rather than focusing exclusively on screen time limitations. Additionally, the study highlights the value of creating more prosocial programming specifically targeted toward at-risk demographics.`,
        source: "Journal of Child Psychology and Psychiatry, 2024",
        imageUrl: "/research/learning-cognitive-development-media-content-preschool.jpg",
        publishedDate: "2024-02-15"
      },
      {
        title: "Narrative Potential of Picture-Book Apps",
        summary: "Research examining how interactive digital picture books affect children's comprehension, imagination, and engagement compared to traditional print picture books.",
        fullText: `Digital media has transformed the traditional picture book into interactive experiences, but questions remain about their impact on children's comprehension and engagement. This research synthesizes findings from 28 studies comparing children's experiences with digital picture-book apps versus print books.

Key findings include:

1. Comprehension: When digital elements directly support the narrative (e.g., animations that illustrate the story action), children's story comprehension improves compared to print versions. However, when digital elements are merely decorative or create distractions, comprehension decreases significantly.

2. Parent-child interaction: Traditional print books generally facilitate more elaborative parent-child conversations about the story. Parents ask more open-ended questions and make more connections to the child's life with print books. With digital books, conversation tends to focus more on the technology itself rather than the narrative.

3. Engagement patterns: Children show higher initial engagement with digital books, but this engagement focuses more on interactive features than story comprehension. Print books show more sustained narrative engagement over time.

4. Design implications: The most effective digital picture books integrate interactive elements that:
   - Support rather than distract from the narrative
   - Include parent guidance features that prompt discussion
   - Allow customization of interactive features
   - Provide "quiet mode" options that reduce non-essential animations

Recommendations for parents include using digital picture books as supplements rather than replacements for print books, choosing apps with complementary rather than merely decorative interactivity, and actively co-reading with children regardless of format.

The research concludes that well-designed digital picture books can support children's literacy development when they enhance rather than distract from the narrative experience.`,
        source: "Reading Research Quarterly, 2024",
        imageUrl: "/research/learning-cognitive-development-narrative-potential.jpg",
        publishedDate: "2024-01-10"
      }
    ]
  },
  
  // Screen Time and Behavioral Impacts
  {
    category: "Screen Time and Behavioral Impacts",
    items: [
      {
        title: "Screen Time Effects on Executive Function",
        summary: "A longitudinal study examining the relationship between different types of screen time (educational, entertainment, and social media) and the development of executive function in children aged 4-10.",
        fullText: `Executive function (EF) — the cognitive processes that regulate attention, inhibit behavior, and enable planning and working memory — is crucial for academic and social success. This five-year longitudinal study tracked 1,842 children to examine how different types of screen media affect EF development.

Participants were divided into groups based on their predominant screen media use: educational programming, entertainment content, interactive gaming, and social media/video apps. Researchers assessed EF skills annually using standardized measures including the Dimensional Change Card Sort, Flanker task, and parent/teacher ratings of EF behaviors in everyday settings.

Key findings:

1. Content type rather than total screen time more strongly predicted EF outcomes. Children who primarily consumed educational content showed significantly better EF development compared to entertainment-focused viewers, even at equivalent hours of screen time.

2. Interactive media effects varied by design: games requiring planning, flexible thinking, and inhibitory control (like certain puzzle games) correlated with improved EF, while fast-paced games with minimal strategic elements showed negative associations.

3. Attention-switching demands predicted poorer outcomes. Programming featuring frequent scene changes, multiple plotlines, and rapid transitions correlated with decreased attentional control, particularly in children under 7.

4. Messaging, social media, and video-based social platforms showed the strongest negative association with EF development, with higher use predicting lower impulse control and greater difficulty with sustained attention tasks.

5. Parental mediation significantly moderated effects: children whose parents regularly discussed media content and related it to real-world situations showed better EF outcomes regardless of content type.

The researchers emphasize that content selection, viewing context, and parental involvement collectively determine how screen media affects executive function development. The study suggests that educational content with moderate pacing, coupled with parental mediation, may actually support certain aspects of EF development in children.`,
        source: "Developmental Science, 2024",
        imageUrl: "/research/screen-time-executive-function.jpg",
        publishedDate: "2024-03-05"
      },
      {
        title: "Sleep Quality and Digital Media Use",
        summary: "An investigation into how evening screen exposure affects children's sleep patterns, particularly focusing on the differential effects of various content types and device brightness levels.",
        fullText: `This research examined how different aspects of evening screen use affect children's sleep using both objective measures (actigraphy, melatonin levels) and parent reports.

Researchers studied 248 children aged 3-9 over a three-week period, systematically varying screen exposure conditions. The study controlled for content type, screen brightness, viewing distance, and timing before bed.

Key findings:

1. Light emission characteristics showed the strongest effect on melatonin suppression and sleep onset delay. Devices with higher blue light emission produced a 30-45 minute delay in melatonin release compared to filtered screens or no screen exposure.

2. Content stimulation level significantly impacted sleep arousal. Fast-paced, emotionally stimulating content viewed even on dimmed screens delayed sleep onset by 22 minutes on average and reduced total sleep duration by 17 minutes compared to slow-paced, calming content.

3. Interactive versus passive viewing produced different outcomes. Interactive media (games, apps requiring input) resulted in higher cognitive and emotional arousal, with effects persisting up to 75 minutes after use.

4. Timing thresholds were identified. Screen exposure ending at least 90 minutes before bedtime showed minimal impact on sleep parameters for most children, regardless of content type.

5. Individual differences emerged in sensitivity to screen effects. Children with existing sleep regulation difficulties or highly sensitive temperaments showed significantly stronger negative responses to evening screen exposure.

Recommendations include implementing blue light filters on all devices used in the evening, selecting calming content for pre-bedtime viewing, establishing a screen curfew of 90 minutes before bed, and creating personalized guidelines based on a child's temperament and sleep sensitivity.

The researchers note that rather than a one-size-fits-all approach to evening screen time, parents should consider their child's individual response patterns and adjust accordingly.`,
        source: "Journal of Sleep Research, 2024",
        imageUrl: "/research/screen-time-sleep-quality.jpg",
        publishedDate: "2024-01-30"
      }
    ]
  },
  
  // Social and Emotional Development
  {
    category: "Social and Emotional Development",
    items: [
      {
        title: "Emotional Intelligence and Children's Media",
        summary: "This study evaluates how different types of children's programming affect emotional intelligence development, including emotional recognition, emotional vocabulary, and empathy skills.",
        fullText: `This research examined how exposure to emotion-focused children's programming influences emotional intelligence (EI) development in young children.

Researchers conducted a mixed-methods study with 312 children ages 3-6, combining experimental sessions, parent surveys, and classroom observations. Children were assigned to view either emotion-focused programming (showing characters identifying, discussing, and managing emotions), general educational content, or entertainment content with minimal emotional themes.

Key findings:

1. Emotion vocabulary: Children who regularly watched emotion-focused content could identify and name an average of 7.3 distinct emotions, compared to 4.1 emotions for those primarily watching general entertainment content. This effect was strongest when parents discussed emotional content during or after viewing.

2. Perspective-taking abilities: After six months, children in the emotion-focused viewing group showed a 32% improvement in perspective-taking tasks compared to 8% in the control group. This translated to measurable improvements in peer conflict resolution in classroom settings.

3. Emotional regulation: Teachers reported better emotional self-regulation skills among children who regularly consumed emotion-focused content, including longer persistence at challenging tasks and more appropriate expressions of frustration.

4. Production techniques matter: Programs using "emotion replay" techniques (revisiting emotional moments and explicitly discussing them) showed stronger positive effects than those that merely portrayed emotional situations without reflection.

5. Transfer to real-world settings: The strongest effects appeared when parents and teachers reinforced emotional concepts from media in daily interactions, creating a connection between screen portrayals and real-life emotional experiences.

The researchers conclude that intentionally designed emotional content can serve as a valuable tool for developing emotional intelligence in young children, particularly when adults help bridge media experiences to real-world emotional situations. The benefits were most pronounced for children who had fewer opportunities for diverse emotional learning experiences in their daily environments.`,
        source: "Early Education and Development, 2023",
        imageUrl: "/research/social-emotional-development-emotional-intelligence.jpg",
        publishedDate: "2023-11-15"
      },
      {
        title: "Digital Media and Empathy Development",
        summary: "An investigation into how different media formats and content types influence the development of cognitive and affective empathy in elementary school children.",
        fullText: `This three-year study investigated how different types of children's media influence the development of both cognitive empathy (understanding others' perspectives) and affective empathy (sharing others' emotional experiences).

Researchers tracked 486 children ages 5-10, using multiple assessment methods including standardized empathy measures, observational data, and parent/teacher reports. They examined exposure to various media formats (television, interactive apps, video games) and content types (fiction vs. non-fiction, diverse vs. homogeneous character representation).

Key findings:

1. Narrative complexity significantly predicted empathy development. Shows and games featuring multiple character perspectives, moral dilemmas, and nuanced emotional portrayals were associated with greater gains in cognitive empathy compared to formulaic content.

2. Character diversity showed strong effects. Media featuring characters diverse in culture, ability, temperament, and family structure correlated with improved perspective-taking abilities and reduced stereotyping in real-world social interactions.

3. Interactive empathy-building apps and games demonstrated the largest positive effect sizes. Applications that explicitly prompted children to consider character feelings, make decisions affecting others, and witness consequences of different actions showed stronger benefits than passive viewing of similar themes.

4. Parasocial relationships functioned similarly to real relationships in empathy development. Children who reported stronger connections to media characters showed greater emotional responsiveness to those characters' experiences, which generalized to real-world empathy in 78% of cases.

5. Parent-child discourse about media content amplified benefits. When adults regularly prompted children to discuss character feelings, motivations, and relationships, empathy scores increased significantly compared to solo viewing of identical content.

The researchers conclude that media's impact on empathy is strongly mediated by content features, viewing context, and post-viewing reflection. They recommend content selection emphasizing narrative complexity and character diversity, coupled with adult-guided conversations about emotional and social themes portrayed in children's media.`,
        source: "Child Development, 2024",
        imageUrl: "/research/social-emotional-development-digital-media-empathy.jpg",
        publishedDate: "2024-02-22"
      }
    ]
  },
  
  // Health and Developmental Impacts
  {
    category: "Health and Developmental Impacts",
    items: [
      {
        title: "Physical Activity Patterns and Screen Use",
        summary: "Research exploring the relationship between children's screen time habits and their daily physical activity levels, with attention to how different content types affect movement patterns.",
        fullText: `This research used wearable activity trackers and detailed media diaries to understand the relationship between children's screen habits and physical activity patterns.

Researchers collected data from 537 children aged 4-12 over eight weeks, using accelerometers to measure movement and specialized apps to track media consumption by type, content, and timing. Unlike previous studies focusing only on total screen time, this research differentiated between content categories and delivery formats.

Key findings:

1. Movement-prompting content produced measurable activity increases. Programs and games specifically designed to encourage physical movement resulted in moderate-to-vigorous physical activity during viewing, with some children achieving over 35% of their daily activity needs during these sessions.

2. Displacement effects varied by content type and scheduling. Screen time scheduled during typical outdoor play hours showed a strong negative correlation with physical activity. However, screen use during traditional sedentary periods (early morning, late evening) showed minimal displacement of physical activity.

3. Sedentary behavior patterns formed early. By age 7, children who regularly consumed media during time typically devoted to physical play showed ingrained preferences for sedentary activities even when screens weren't available.

4. Interactive versus passive screen use showed different outcomes. Gaming requiring gross motor movement (like motion-controlled console games) resulted in activity levels comparable to moderate outdoor play, while immersive tablet games produced the longest periods of complete sedentary behavior.

5. Content messaging about physical activity showed transfer effects. Children regularly exposed to shows promoting exercise and outdoor play demonstrated increased non-screen physical activity, especially when characters they identified with modeled active lifestyles.

Recommendations include scheduling screen use to avoid displacing typically active periods, selecting content that either promotes movement during viewing or positively portrays physical activity, and establishing consistent screen-free times associated with outdoor play and sports.`,
        source: "Journal of Physical Activity and Health, 2023",
        imageUrl: "/research/health-developmental-impacts-physical-activity.jpg",
        publishedDate: "2023-12-12"
      },
      {
        title: "Digital Media Exposure and Language Acquisition",
        summary: "A longitudinal analysis of how different screen-based activities impact vocabulary development, language processing speed, and conversational skills in toddlers and preschoolers.",
        fullText: `This four-year longitudinal study tracked language development outcomes in relation to different types of media exposure in 392 children from ages 18 months to 5 years.

Unlike previous research that treated screen time as a monolithic category, this study created detailed classifications of media experiences based on content features, interaction type, and social context. Researchers used standardized language assessments, natural language samples, and experimental tasks to measure various components of language development.

Key findings:

1. Interactive versus passive consumption showed markedly different outcomes. Video chat conversations with responsive adults supported language development similarly to in-person interaction, while non-interactive viewing of even high-quality educational content showed minimal positive language effects in children under 30 months.

2. Background media exposure emerged as a significant negative factor. Homes with constant background TV/video showed reduced quantity and quality of parent-child verbal interactions, with children in high-background media environments having 23% fewer daily conversational turns.

3. Content verbal complexity predicted vocabulary outcomes. Programs featuring diverse, moderately advanced vocabulary with in-context explanation of new words showed positive associations with expressive vocabulary growth compared to content using restricted vocabulary or unexplained advanced terminology.

4. Adult co-viewing with active mediation was the strongest positive factor. When adults regularly elaborated on media content, asked questions, and connected screen content to the child's experiences, negative effects were mitigated and positive language outcomes enhanced.

5. Timing of exposure showed developmental windows of sensitivity. Media effects (both positive and negative) were strongest between 18-36 months, a critical period for language acquisition when children are particularly sensitive to environmental language input.

The researchers emphasize that how media is used matters more than simple screen time quantities. They recommend prioritizing interactive over passive screen experiences, minimizing background media, selecting verbally rich content appropriate to the child's developmental level, and maintaining adult linguistic involvement during children's media experiences.`,
        source: "Journal of Communication, 2024",
        imageUrl: "/research/health-developmental-impacts-language-acquisition.jpg",
        publishedDate: "2024-01-18"
      }
    ]
  }
];

/**
 * Generate SQL insert statements for the research summaries
 */
function generateSqlInserts(researchData) {
  let sqlContent = '';
  
  for (const category of researchData) {
    for (const item of category.items) {
      sqlContent += `INSERT INTO research_summaries (title, summary, full_text, source, category, image_url, published_date, created_at, updated_at)\n`;
      sqlContent += `VALUES (\n`;
      sqlContent += `  '${item.title.replace(/'/g, "''")}'::text,\n`;
      sqlContent += `  '${item.summary.replace(/'/g, "''")}'::text,\n`;
      sqlContent += `  '${item.fullText.replace(/'/g, "''")}'::text,\n`;
      sqlContent += `  '${(item.source || '').replace(/'/g, "''")}'::text,\n`;
      sqlContent += `  '${category.category.replace(/'/g, "''")}'::text,\n`;
      sqlContent += `  ${item.imageUrl ? `'${item.imageUrl}'::text` : 'NULL'},\n`;
      sqlContent += `  '${item.publishedDate}'::timestamp,\n`;
      sqlContent += `  NOW(),\n`;
      sqlContent += `  NOW()\n`;
      sqlContent += `);\n\n`;
    }
  }
  
  return sqlContent;
}

/**
 * Save the research data to JSON file
 */
function saveResearchDataToJson() {
  // Convert to the format expected by the database
  const flattenedData = [];
  
  for (const category of researchData) {
    for (const item of category.items) {
      flattenedData.push({
        title: item.title,
        summary: item.summary,
        fullText: item.fullText,
        source: item.source,
        category: category.category,
        imageUrl: item.imageUrl,
        publishedDate: item.publishedDate
      });
    }
  }
  
  const outputPath = path.join(OUTPUT_FOLDER, 'research_data.json');
  fs.writeFileSync(outputPath, JSON.stringify(flattenedData, null, 2));
  console.log(`Research data saved to ${outputPath}`);
  
  // Generate SQL insert statements
  const sqlContent = generateSqlInserts(researchData);
  const sqlPath = path.join(OUTPUT_FOLDER, 'research_inserts.sql');
  fs.writeFileSync(sqlPath, sqlContent);
  console.log(`SQL insert statements saved to ${sqlPath}`);
  
  return flattenedData;
}

// Main function
function main() {
  console.log('Starting manual research data extraction...');
  
  // Ensure output directory exists
  if (!fs.existsSync(OUTPUT_FOLDER)) {
    fs.mkdirSync(OUTPUT_FOLDER, { recursive: true });
  }
  
  // Save the research data
  const data = saveResearchDataToJson();
  
  console.log(`Successfully processed ${data.length} research summaries.`);
  console.log('You can now review and import this data into your database.');
}

// Run the script
main();
</file>

<file path="optimize-images.mjs">
/**
 * Optimize custom images in the database for better SEO and page load times
 */
import { pool } from './server/db.js';
import sharp from 'sharp';
import fetch from 'node-fetch';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { loadCustomImageMap, updateCustomImageMap, saveCustomImageMap } from './server/image-preservator.js';

// Get current file directory
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Create upload directories if they don't exist
const imageDir = path.join(__dirname, 'public/uploads');
const optimizedImageDir = path.join(__dirname, 'public/uploads/optimized');

if (!fs.existsSync(imageDir)) {
  fs.mkdirSync(imageDir, { recursive: true });
}

if (!fs.existsSync(optimizedImageDir)) {
  fs.mkdirSync(optimizedImageDir, { recursive: true });
}

/**
 * Download image from URL
 */
async function downloadImage(imageUrl, showId) {
  try {
    // Skip if URL is null or already an optimized path
    if (!imageUrl || imageUrl.includes('/uploads/optimized/')) {
      console.log(`Skipping already optimized or null image for show ID ${showId}`);
      return null;
    }
    
    // Skip OMDB images
    if (imageUrl.includes('m.media-amazon.com') || imageUrl.includes('omdbapi.com')) {
      console.log(`Skipping OMDB image for show ID ${showId}`);
      return null;
    }
    
    // For local images that are already in our uploads directory
    if (imageUrl.startsWith('/uploads/')) {
      const localPath = path.join(__dirname, 'public', imageUrl);
      if (fs.existsSync(localPath)) {
        console.log(`Using existing local image at ${localPath}`);
        return localPath;
      }
    }
    
    // Handle external URLs
    console.log(`Downloading image from URL: ${imageUrl}`);
    const response = await fetch(imageUrl);
    
    if (!response.ok) {
      console.error(`Failed to download image: ${response.status} ${response.statusText}`);
      return null;
    }
    
    const buffer = await response.buffer();
    const timestamp = Date.now();
    const uniqueFilename = `show-${showId}-${timestamp}.jpg`;
    const tempFilePath = path.join(imageDir, uniqueFilename);
    
    fs.writeFileSync(tempFilePath, buffer);
    console.log(`Downloaded image to: ${tempFilePath}`);
    return tempFilePath;
    
  } catch (error) {
    console.error(`Error downloading image:`, error.message);
    return null;
  }
}

/**
 * Optimize image for web use
 */
async function optimizeImage(filePath, showId) {
  try {
    if (!filePath) return null;
    
    const filename = path.basename(filePath, path.extname(filePath));
    const optimizedFilename = `${filename}-optimized.jpg`;
    const optimizedPath = path.join(optimizedImageDir, optimizedFilename);
    
    // Get image dimensions
    const metadata = await sharp(filePath).metadata();
    const originalWidth = metadata.width || 800;
    const originalHeight = metadata.height || 600;
    
    // Target portrait format sizes
    let targetWidth, targetHeight;
    
    if (originalHeight >= originalWidth) {
      // Already portrait or square
      targetWidth = Math.min(originalWidth, 600);
      targetHeight = Math.round((targetWidth / originalWidth) * originalHeight);
      
      // Limit very tall images
      if (targetHeight > 900) {
        targetHeight = 900;
        targetWidth = Math.round((targetHeight / originalHeight) * originalWidth);
      }
    } else {
      // Landscape - convert to portrait-friendly dimensions
      targetHeight = Math.min(originalHeight, 800);
      targetWidth = Math.min(originalWidth, Math.round(targetHeight * 0.75));
    }
    
    // Process with sharp
    await sharp(filePath)
      .resize(targetWidth, targetHeight, {
        fit: 'contain',
        background: { r: 255, g: 255, b: 255, alpha: 1 }
      })
      .jpeg({ quality: 85, progressive: true })
      .toFile(optimizedPath);
    
    console.log(`Image optimized: ${optimizedPath} (${targetWidth}x${targetHeight})`);
    
    // Return web path to optimized image
    return `/uploads/optimized/${optimizedFilename}`;
    
  } catch (error) {
    console.error(`Error optimizing image:`, error.message);
    return null;
  }
}

/**
 * Main function to optimize all custom images
 */
async function optimizeAllCustomImages() {
  console.log('Starting image optimization process...');
  
  // Load custom image map
  const customImageMap = loadCustomImageMap();
  let optimizedCount = 0;
  let errorCount = 0;
  let skippedCount = 0;
  
  try {
    // Get all shows with images that aren't already optimized
    const query = `
      SELECT id, name, image_url 
      FROM tv_shows 
      WHERE image_url IS NOT NULL 
        AND image_url NOT LIKE '%/uploads/optimized/%'
        AND image_url NOT LIKE '%m.media-amazon.com%'
        AND image_url NOT LIKE '%omdbapi.com%'
    `;
    
    const result = await pool.query(query);
    console.log(`Found ${result.rows.length} images to optimize`);
    
    // Process each image
    for (const show of result.rows) {
      try {
        console.log(`\nProcessing show: ${show.name} (ID: ${show.id})`);
        console.log(`Current image URL: ${show.image_url}`);
        
        // Download image
        const localPath = await downloadImage(show.image_url, show.id);
        if (!localPath) {
          console.log(`Skipping image for show ID ${show.id}: ${show.name}`);
          skippedCount++;
          continue;
        }
        
        // Optimize image
        const optimizedUrl = await optimizeImage(localPath, show.id);
        if (!optimizedUrl) {
          console.error(`Failed to optimize image for show ID ${show.id}`);
          errorCount++;
          continue;
        }
        
        // Update database
        const updateQuery = 'UPDATE tv_shows SET image_url = $1 WHERE id = $2';
        await pool.query(updateQuery, [optimizedUrl, show.id]);
        
        // Update custom image map
        updateCustomImageMap(show.id, optimizedUrl);
        optimizedCount++;
        
        console.log(`Updated image for ${show.name}: ${optimizedUrl}`);
        
        // Clean up temporary file
        if (localPath.startsWith(imageDir)) {
          fs.unlinkSync(localPath);
        }
        
      } catch (error) {
        console.error(`Error processing show ID ${show.id}:`, error.message);
        errorCount++;
      }
    }
    
    // Save updated custom image map
    saveCustomImageMap(customImageMap);
    
    console.log('\nOptimization complete:');
    console.log(`- Optimized: ${optimizedCount}`);
    console.log(`- Skipped: ${skippedCount}`);
    console.log(`- Errors: ${errorCount}`);
    console.log(`- Total processed: ${result.rows.length}`);
    
  } catch (error) {
    console.error('Error during optimization process:', error.message);
  } finally {
    await pool.end();
  }
}

// Run the script
optimizeAllCustomImages().catch(console.error);
</file>

<file path="optimize-seo-images.mjs">
/**
 * Script to optimize all custom images in the database for better SEO
 */
import { pool } from './server/db.js';
import sharp from 'sharp';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import fetch from 'node-fetch';

// Get directory name for ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Create directories if needed
const imageDir = path.join(__dirname, 'public/uploads');
const optimizedDir = path.join(__dirname, 'public/uploads/optimized');

if (!fs.existsSync(imageDir)) {
  fs.mkdirSync(imageDir, { recursive: true });
}

if (!fs.existsSync(optimizedDir)) {
  fs.mkdirSync(optimizedDir, { recursive: true });
}

/**
 * Get all shows with custom images that need optimization
 */
async function getShowsWithCustomImages() {
  const query = `
    SELECT id, name, image_url 
    FROM tv_shows 
    WHERE image_url IS NOT NULL 
      AND image_url NOT LIKE '%/uploads/optimized/%'
      AND image_url NOT LIKE '%m.media-amazon.com%'
      AND image_url NOT LIKE '%omdbapi.com%'
  `;
  
  const result = await pool.query(query);
  return result.rows;
}

/**
 * Download or copy image from URL or local path
 */
async function getImage(imageUrl, showId) {
  try {
    // Handle local file paths
    if (imageUrl.startsWith('/')) {
      // Try different possible locations
      const possiblePaths = [
        path.join(__dirname, 'public', imageUrl),
        path.join(__dirname, 'public', 'uploads', path.basename(imageUrl)),
        path.join(__dirname, 'public', 'custom-images', path.basename(imageUrl)),
        path.join(__dirname, 'public', 'images', path.basename(imageUrl)),
        path.join(__dirname, 'attached_assets', path.basename(imageUrl)),
        path.join(__dirname, imageUrl.substring(1)) // Try without leading slash
      ];
      
      for (const localPath of possiblePaths) {
        if (fs.existsSync(localPath)) {
          console.log(`Found local image at ${localPath}`);
          
          // Create a copy in uploads directory
          const timestamp = Date.now();
          const uniqueFilename = `show-${showId}-${timestamp}${path.extname(localPath) || '.jpg'}`;
          const tempPath = path.join(imageDir, uniqueFilename);
          
          fs.copyFileSync(localPath, tempPath);
          return tempPath;
        }
      }
      
      console.log(`Could not find local image: ${imageUrl}`);
      return null;
    }
    
    // Download remote URLs
    if (imageUrl.startsWith('http')) {
      try {
        const response = await fetch(imageUrl);
        if (!response.ok) {
          console.error(`Failed to download: ${response.status}`);
          return null;
        }
        
        const buffer = await response.buffer();
        const timestamp = Date.now();
        const uniqueFilename = `show-${showId}-${timestamp}.jpg`;
        const tempPath = path.join(imageDir, uniqueFilename);
        
        fs.writeFileSync(tempPath, buffer);
        return tempPath;
      } catch (error) {
        console.error(`Download error: ${error.message}`);
        return null;
      }
    }
    
    return null;
  } catch (error) {
    console.error(`Error getting image: ${error.message}`);
    return null;
  }
}

/**
 * Optimize image for web use
 */
async function optimizeImage(filePath, showId) {
  try {
    const filename = path.basename(filePath, path.extname(filePath));
    const optimizedFilename = `${filename}-optimized.jpg`;
    const optimizedPath = path.join(optimizedDir, optimizedFilename);
    
    // Get image metadata
    const metadata = await sharp(filePath).metadata();
    const width = metadata.width || 800;
    const height = metadata.height || 600;
    
    // Target portrait-style dimensions
    let targetWidth, targetHeight;
    
    if (height >= width) {
      // Already portrait
      targetWidth = Math.min(width, 600);
      targetHeight = Math.round((targetWidth / width) * height);
      
      // Cap height for very tall images
      if (targetHeight > 900) {
        targetHeight = 900;
        targetWidth = Math.round((targetHeight / height) * width);
      }
    } else {
      // Convert landscape to portrait-friendly
      targetHeight = Math.min(height, 800);
      targetWidth = Math.min(width, Math.round(targetHeight * 0.75));
    }
    
    // Optimize the image
    await sharp(filePath)
      .resize(targetWidth, targetHeight, {
        fit: 'contain',
        background: { r: 255, g: 255, b: 255, alpha: 1 }
      })
      .jpeg({ quality: 85, progressive: true })
      .toFile(optimizedPath);
    
    console.log(`Optimized to ${targetWidth}x${targetHeight}`);
    
    // Return web path
    return `/uploads/optimized/${optimizedFilename}`;
  } catch (error) {
    console.error(`Optimization error: ${error.message}`);
    return null;
  }
}

/**
 * Save the new optimized image path to the database
 */
async function updateShowImage(showId, optimizedUrl) {
  try {
    await pool.query(
      'UPDATE tv_shows SET image_url = $1 WHERE id = $2',
      [optimizedUrl, showId]
    );
    
    // Also update custom image map
    try {
      const customImageMap = JSON.parse(fs.readFileSync('./customImageMap.json', 'utf8'));
      customImageMap[showId] = optimizedUrl;
      fs.writeFileSync('./customImageMap.json', JSON.stringify(customImageMap, null, 2));
    } catch (e) {
      console.log('Note: Could not update customImageMap.json');
    }
    
    return true;
  } catch (error) {
    console.error(`Database update error: ${error.message}`);
    return false;
  }
}

/**
 * Main optimization function
 */
async function optimizeAllImages() {
  console.log('Starting SEO image optimization...');
  
  try {
    // Get shows that need optimization
    const shows = await getShowsWithCustomImages();
    console.log(`Found ${shows.length} shows with custom images to optimize`);
    
    let optimized = 0;
    let skipped = 0;
    let errors = 0;
    
    // Process each show
    for (const show of shows) {
      try {
        console.log(`\nProcessing: ${show.name} (ID: ${show.id})`);
        
        // Get image file
        const imagePath = await getImage(show.image_url, show.id);
        if (!imagePath) {
          console.log(`Skipping - could not access image for ${show.name}`);
          skipped++;
          continue;
        }
        
        // Optimize image
        const optimizedUrl = await optimizeImage(imagePath, show.id);
        if (!optimizedUrl) {
          console.error(`Failed to optimize image for ${show.name}`);
          errors++;
          continue;
        }
        
        // Update in database
        const updated = await updateShowImage(show.id, optimizedUrl);
        if (updated) {
          console.log(`✅ Successfully optimized image for ${show.name}`);
          optimized++;
        } else {
          console.error(`❌ Failed to update database for ${show.name}`);
          errors++;
        }
        
        // Clean up temp file
        try {
          if (imagePath.startsWith(imageDir)) {
            fs.unlinkSync(imagePath);
          }
        } catch (e) {
          // Ignore cleanup errors
        }
        
      } catch (error) {
        console.error(`Error processing ${show.name}: ${error.message}`);
        errors++;
      }
    }
    
    console.log('\nOptimization complete:');
    console.log(`✅ Optimized: ${optimized}`);
    console.log(`⏭️ Skipped: ${skipped}`);
    console.log(`❌ Errors: ${errors}`);
    console.log(`📊 Total processed: ${shows.length}`);
    
  } catch (error) {
    console.error('Fatal error:', error);
  } finally {
    await pool.end();
  }
}

// Run the optimization
optimizeAllImages().catch(console.error);
</file>

<file path="package.json">
{
  "name": "rest-express",
  "version": "1.0.0",
  "type": "module",
  "license": "MIT",
  "scripts": {
    "dev": "NODE_ENV=development tsx server/index.ts",
    "build": "vite build && esbuild server/index.ts --platform=node --packages=external --bundle --format=esm --outdir=dist",
    "start": "NODE_ENV=production node dist/index.js",
    "check": "tsc",
    "db:push": "drizzle-kit push"
  },
  "dependencies": {
    "@anthropic-ai/sdk": "^0.37.0",
    "@hookform/resolvers": "^3.10.0",
    "@jridgewell/trace-mapping": "^0.3.25",
    "@neondatabase/serverless": "^0.10.4",
    "@radix-ui/react-accordion": "^1.2.4",
    "@radix-ui/react-alert-dialog": "^1.1.7",
    "@radix-ui/react-aspect-ratio": "^1.1.3",
    "@radix-ui/react-avatar": "^1.1.4",
    "@radix-ui/react-checkbox": "^1.1.5",
    "@radix-ui/react-collapsible": "^1.1.4",
    "@radix-ui/react-context-menu": "^2.2.7",
    "@radix-ui/react-dialog": "^1.1.7",
    "@radix-ui/react-dropdown-menu": "^2.1.7",
    "@radix-ui/react-hover-card": "^1.1.7",
    "@radix-ui/react-label": "^2.1.3",
    "@radix-ui/react-menubar": "^1.1.7",
    "@radix-ui/react-navigation-menu": "^1.2.6",
    "@radix-ui/react-popover": "^1.1.7",
    "@radix-ui/react-progress": "^1.1.3",
    "@radix-ui/react-radio-group": "^1.2.4",
    "@radix-ui/react-scroll-area": "^1.2.4",
    "@radix-ui/react-select": "^2.1.7",
    "@radix-ui/react-separator": "^1.1.3",
    "@radix-ui/react-slider": "^1.2.4",
    "@radix-ui/react-slot": "^1.2.0",
    "@radix-ui/react-switch": "^1.1.4",
    "@radix-ui/react-tabs": "^1.1.4",
    "@radix-ui/react-toast": "^1.2.7",
    "@radix-ui/react-toggle": "^1.1.3",
    "@radix-ui/react-toggle-group": "^1.1.3",
    "@radix-ui/react-tooltip": "^1.2.0",
    "@sendgrid/mail": "^8.1.5",
    "@tailwindcss/vite": "^4.1.3",
    "@tanstack/react-query": "^5.60.5",
    "@types/bcrypt": "^5.0.2",
    "@types/memoizee": "^0.4.12",
    "@types/multer": "^1.4.12",
    "adm-zip": "^0.5.16",
    "bcrypt": "^6.0.0",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^1.1.1",
    "connect-pg-simple": "^10.0.0",
    "csv-parse": "^5.6.0",
    "date-fns": "^3.6.0",
    "dotenv": "^16.5.0",
    "drizzle-orm": "^0.39.1",
    "drizzle-zod": "^0.7.0",
    "embla-carousel-react": "^8.6.0",
    "express": "^4.21.2",
    "express-session": "^1.18.1",
    "framer-motion": "^11.13.1",
    "html2canvas": "^1.4.1",
    "input-otp": "^1.4.2",
    "lucide-react": "^0.453.0",
    "memoizee": "^0.4.17",
    "memorystore": "^1.6.7",
    "multer": "^1.4.5-lts.2",
    "next-themes": "^0.4.6",
    "node-fetch": "^3.3.2",
    "octokit": "^4.1.3",
    "openid-client": "^6.5.0",
    "passport": "^0.7.0",
    "passport-local": "^1.0.0",
    "pg": "^8.16.0",
    "puppeteer": "^24.9.0",
    "react": "^18.3.1",
    "react-day-picker": "^8.10.1",
    "react-dom": "^18.3.1",
    "react-hook-form": "^7.55.0",
    "react-icons": "^5.4.0",
    "react-resizable-panels": "^2.1.7",
    "recharts": "^2.15.2",
    "repomix": "^0.3.8",
    "sharp": "^0.34.1",
    "tailwind-merge": "^2.6.0",
    "tailwindcss-animate": "^1.0.7",
    "tw-animate-css": "^1.2.5",
    "vaul": "^1.1.2",
    "wouter": "^3.3.5",
    "ws": "^8.18.0",
    "zod": "^3.24.2",
    "zod-validation-error": "^3.4.0"
  },
  "devDependencies": {
    "@replit/vite-plugin-cartographer": "^0.1.2",
    "@replit/vite-plugin-runtime-error-modal": "^0.0.3",
    "@tailwindcss/typography": "^0.5.15",
    "@types/connect-pg-simple": "^7.0.3",
    "@types/express": "4.17.21",
    "@types/express-session": "^1.18.1",
    "@types/node": "20.16.11",
    "@types/passport": "^1.0.17",
    "@types/passport-local": "^1.0.38",
    "@types/react": "^18.3.11",
    "@types/react-dom": "^18.3.1",
    "@types/ws": "^8.5.13",
    "@vitejs/plugin-react": "^4.3.2",
    "autoprefixer": "^10.4.20",
    "drizzle-kit": "^0.30.4",
    "esbuild": "^0.25.0",
    "postcss": "^8.4.47",
    "tailwindcss": "^3.4.17",
    "tsx": "^4.19.1",
    "typescript": "5.6.3",
    "vite": "^5.4.14"
  },
  "optionalDependencies": {
    "bufferutil": "^4.0.8"
  }
}
</file>

<file path="postcss.config.js">
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
</file>

<file path="refresh-data.js">
// Simple script to refresh data from GitHub
import fetch from 'node-fetch';

async function refreshData() {
  try {
    console.log('Refreshing data from GitHub...');
    const response = await fetch('http://localhost:5000/api/refresh-data', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      }
    });
    
    const data = await response.json();
    console.log('Response:', data);
  } catch (error) {
    console.error('Error refreshing data:', error);
  }
}

refreshData();
</file>

<file path="restore-custom-images.mjs">
/**
 * This script re-applies all custom images from the customImageMap.json file to the database
 * This ensures that any OMDb API images that overwrote custom images are replaced with the original custom images
 */

import fs from 'fs';
import path from 'path';
import pg from 'pg';
import { fileURLToPath } from 'url';

const { Pool } = pg;

// Get current file directory
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Initialize database connection using DATABASE_URL environment variable
const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
});

// Load custom image mappings from JSON file
function loadCustomImageMap() {
  try {
    const filePath = path.join(__dirname, 'customImageMap.json');
    if (fs.existsSync(filePath)) {
      const data = fs.readFileSync(filePath, 'utf-8');
      return JSON.parse(data);
    }
  } catch (error) {
    console.error('Error loading custom image map:', error);
  }
  return {};
}

async function restoreCustomImages() {
  try {
    console.log('Starting custom image restoration process...');
    
    // Load the custom image map
    const customImageMap = loadCustomImageMap();
    const customImageIds = Object.keys(customImageMap);
    
    console.log(`Found ${customImageIds.length} custom images in the map`);
    
    // Track our progress
    let restoredCount = 0;
    let skippedCount = 0;
    let errorCount = 0;
    
    // Process each image in the map
    for (const showId of customImageIds) {
      try {
        const imageUrl = customImageMap[showId];
        
        // Skip non-custom images (like OMDB images that were added to the map)
        const isCustomImage = imageUrl.includes('/custom-images/') || 
                              imageUrl.includes('/uploads/optimized/');
        
        if (!isCustomImage) {
          console.log(`Skipping non-custom image for show ID ${showId}: ${imageUrl}`);
          skippedCount++;
          continue;
        }
        
        console.log(`Restoring custom image for show ID ${showId}: ${imageUrl}`);
        
        // Update the database with the custom image
        const updateResult = await pool.query(
          'UPDATE tv_shows SET image_url = $1 WHERE id = $2 RETURNING name',
          [imageUrl, showId]
        );
        
        if (updateResult.rowCount > 0) {
          console.log(`✓ Restored custom image for "${updateResult.rows[0].name}" (ID: ${showId})`);
          restoredCount++;
        } else {
          console.log(`⚠ Show ID ${showId} not found in database`);
          skippedCount++;
        }
      } catch (error) {
        console.error(`Error restoring image for show ID ${showId}:`, error);
        errorCount++;
      }
    }
    
    console.log('\nCustom image restoration complete:');
    console.log(`- Restored: ${restoredCount}`);
    console.log(`- Skipped: ${skippedCount}`);
    console.log(`- Errors: ${errorCount}`);
    
  } catch (error) {
    console.error('Error in restoreCustomImages:', error);
  } finally {
    // Close database connection
    await pool.end();
  }
}

// Run the restoration process
restoreCustomImages();
</file>

<file path="skool-extractor.js">
/**
 * Skool Research Extractor
 * 
 * This script logs into a Skool community and extracts research summaries
 * for import into our research_summaries database table.
 */

const puppeteer = require('puppeteer');
const fs = require('fs');
const path = require('path');
const { db } = require('./server/db');
const { researchSummaries } = require('./shared/schema');

// Configuration
const SKOOL_URL = 'https://www.skool.com/screen-time-community/classroom/e5da82d5?md=869d5a30cf1144e29cdbf7ec0ed6ca30';
const SKOOL_EMAIL = ''; // Will be provided at runtime
const SKOOL_PASSWORD = ''; // Will be provided at runtime
const OUTPUT_FOLDER = './extracted_research';
const IMAGES_FOLDER = './public/research';

// Ensure output directories exist
if (!fs.existsSync(OUTPUT_FOLDER)) {
  fs.mkdirSync(OUTPUT_FOLDER, { recursive: true });
}
if (!fs.existsSync(IMAGES_FOLDER)) {
  fs.mkdirSync(IMAGES_FOLDER, { recursive: true });
}

/**
 * Main extraction function
 */
async function extractResearchFromSkool(email, password) {
  console.log('Starting Skool research extraction...');
  
  const browser = await puppeteer.launch({
    headless: false, // Set to true for production
    defaultViewport: { width: 1366, height: 768 }
  });
  
  try {
    const page = await browser.newPage();
    
    // Login to Skool
    console.log('Logging in to Skool...');
    await page.goto(SKOOL_URL, { waitUntil: 'networkidle2' });
    
    // Check if we need to log in
    const isLoggedIn = await page.evaluate(() => {
      return !document.querySelector('input[type="email"]');
    });
    
    if (!isLoggedIn) {
      // Fill login form
      await page.type('input[type="email"]', email);
      await page.type('input[type="password"]', password);
      await page.click('button[type="submit"]');
      await page.waitForNavigation({ waitUntil: 'networkidle2' });
      
      console.log('Login successful');
    } else {
      console.log('Already logged in');
    }
    
    // Wait for the content to load
    await page.waitForSelector('.classroom-content', { timeout: 30000 });
    
    // Extract all categories (bold text items on the left)
    const categories = await page.evaluate(() => {
      const categoryElements = Array.from(document.querySelectorAll('.sidebar-section-title'));
      return categoryElements.map(el => ({
        name: el.textContent.trim(),
        element: el
      }));
    });
    
    console.log(`Found ${categories.length} research categories`);
    
    // Extracted research data
    const researchData = [];
    
    // Process each category
    for (let categoryIndex = 0; categoryIndex < categories.length; categoryIndex++) {
      // We need to re-evaluate the categories each time as the DOM may change
      const categoryElements = await page.$$('.sidebar-section-title');
      if (categoryIndex >= categoryElements.length) continue;
      
      const categoryElement = categoryElements[categoryIndex];
      const categoryName = await page.evaluate(el => el.textContent.trim(), categoryElement);
      
      console.log(`Processing category: ${categoryName}`);
      
      // Click to expand the category
      await categoryElement.click();
      await page.waitForTimeout(1000); // Wait for animation
      
      // Get all summaries under this category
      const summaries = await page.evaluate(categoryEl => {
        // Find all non-bold text items that are children of this category section
        const categorySection = categoryEl.closest('.sidebar-section');
        if (!categorySection) return [];
        
        const summaryElements = Array.from(categorySection.querySelectorAll('.sidebar-lesson-name'));
        return summaryElements.map(el => ({
          title: el.textContent.trim(),
          element: el
        }));
      }, categoryElement);
      
      console.log(`Found ${summaries.length} summaries in category: ${categoryName}`);
      
      // Process each summary
      for (let summaryIndex = 0; summaryIndex < summaries.length; summaryIndex++) {
        // Re-evaluate to get fresh DOM references
        const summaryElements = await page.$$(`[data-testid="sidebar-lesson-name"]`);
        // Find the right element within the visible summaries
        let currentSummaryElement;
        let summaryTitle;
        
        for (const el of summaryElements) {
          const text = await page.evaluate(e => e.textContent.trim(), el);
          if (await page.evaluate(e => e.closest('.sidebar-section').style.display !== 'none', el)) {
            // Count visible elements to match our index
            if (summaryIndex === 0) {
              currentSummaryElement = el;
              summaryTitle = text;
              break;
            }
            summaryIndex--;
          }
        }
        
        if (!currentSummaryElement) continue;
        
        console.log(`Processing summary: ${summaryTitle}`);
        
        // Click on the summary to view its content
        await currentSummaryElement.click();
        await page.waitForTimeout(2000); // Wait for content to load
        
        // Extract the summary content
        const content = await page.evaluate(() => {
          // Get the main content area
          const contentArea = document.querySelector('.lesson-content');
          if (!contentArea) return null;
          
          // Extract title
          const titleElement = contentArea.querySelector('h1, h2, h3');
          const title = titleElement ? titleElement.textContent.trim() : 'Untitled Research';
          
          // Extract full text
          const paragraphs = Array.from(contentArea.querySelectorAll('p, li, h4, h5, h6'));
          const fullText = paragraphs.map(p => p.textContent.trim()).join('\\n\\n');
          
          // Extract summary (first paragraph or two)
          const summaryText = paragraphs.slice(0, 2).map(p => p.textContent.trim()).join(' ');
          
          // Extract source link if present
          const links = Array.from(contentArea.querySelectorAll('a[href*="http"]'));
          let source = null;
          let sourceLink = null;
          
          for (const link of links) {
            const text = link.textContent.toLowerCase().trim();
            if (text.includes('study') || text.includes('research') || text.includes('source') || 
                text.includes('journal') || text.includes('article')) {
              source = link.textContent.trim();
              sourceLink = link.href;
              break;
            }
          }
          
          // Look for images
          const images = Array.from(contentArea.querySelectorAll('img')).map(img => img.src)
            .filter(src => src && !src.includes('avatar') && !src.includes('profile') && !src.includes('logo'));
          
          return {
            title,
            summary: summaryText.substring(0, 300) + (summaryText.length > 300 ? '...' : ''),
            fullText,
            source,
            sourceLink,
            images
          };
        });
        
        if (!content) {
          console.log('Could not extract content, skipping');
          continue;
        }
        
        // Download the first image if available
        let imagePath = null;
        if (content.images && content.images.length > 0) {
          const imageUrl = content.images[0];
          const imageFileName = `${categoryName.toLowerCase().replace(/[^a-z0-9]/g, '-')}-${
            content.title.toLowerCase().replace(/[^a-z0-9]/g, '-')
          }.jpg`;
          
          imagePath = `/research/${imageFileName}`;
          const fullImagePath = path.join(IMAGES_FOLDER, imageFileName);
          
          try {
            // Download the image
            const imageResponse = await page.goto(imageUrl);
            const imageBuffer = await imageResponse.buffer();
            fs.writeFileSync(fullImagePath, imageBuffer);
            console.log(`Saved image: ${fullImagePath}`);
            
            // Go back to the classroom page
            await page.goto(SKOOL_URL, { waitUntil: 'networkidle2' });
            await page.waitForSelector('.classroom-content', { timeout: 30000 });
            
            // Re-expand the category
            const categoryElements = await page.$$('.sidebar-section-title');
            await categoryElements[categoryIndex].click();
            await page.waitForTimeout(1000);
          } catch (err) {
            console.error(`Error downloading image: ${err.message}`);
            imagePath = null;
          }
        }
        
        // Add to research data
        researchData.push({
          title: content.title,
          summary: content.summary,
          fullText: content.fullText,
          source: content.source || content.sourceLink,
          category: categoryName,
          imageUrl: imagePath,
          publishedDate: new Date() // Default to current date if not available
        });
      }
    }
    
    // Save the extracted data
    const outputPath = path.join(OUTPUT_FOLDER, 'research_data.json');
    fs.writeFileSync(outputPath, JSON.stringify(researchData, null, 2));
    console.log(`Research data saved to ${outputPath}`);
    
    // Return the data for database insertion
    return researchData;
    
  } catch (error) {
    console.error('Error during extraction:', error);
    throw error;
  } finally {
    await browser.close();
  }
}

/**
 * Insert research data into the database
 */
async function insertResearchIntoDatabase(researchData) {
  console.log('Inserting research into database...');
  
  try {
    // Start a transaction
    let insertedCount = 0;
    
    for (const research of researchData) {
      try {
        // Check if a research with this title already exists
        const existingResearch = await db
          .select()
          .from(researchSummaries)
          .where(db.sql`LOWER(title) = LOWER(${research.title})`)
          .limit(1);
        
        if (existingResearch && existingResearch.length > 0) {
          console.log(`Research "${research.title}" already exists, skipping`);
          continue;
        }
        
        // Insert the research summary
        await db.insert(researchSummaries).values({
          title: research.title,
          summary: research.summary,
          fullText: research.fullText,
          category: research.category,
          imageUrl: research.imageUrl,
          source: research.source,
          publishedDate: research.publishedDate,
          createdAt: new Date(),
          updatedAt: new Date()
        });
        
        insertedCount++;
        console.log(`Inserted research: ${research.title}`);
      } catch (err) {
        console.error(`Error inserting research "${research.title}":`, err);
      }
    }
    
    console.log(`Successfully inserted ${insertedCount} research summaries`);
    return insertedCount;
  } catch (error) {
    console.error('Database insertion error:', error);
    throw error;
  }
}

/**
 * Main execution function
 */
async function main() {
  try {
    // Get credentials from command line args or prompt
    const email = process.argv[2] || process.env.SKOOL_EMAIL;
    const password = process.argv[3] || process.env.SKOOL_PASSWORD;
    
    if (!email || !password) {
      console.error('Please provide Skool email and password');
      console.log('Usage: node skool-extractor.js <email> <password>');
      process.exit(1);
    }
    
    // Extract research data
    const researchData = await extractResearchFromSkool(email, password);
    
    // Insert into database
    const insertedCount = await insertResearchIntoDatabase(researchData);
    
    console.log(`Extraction complete! Inserted ${insertedCount} research summaries.`);
  } catch (error) {
    console.error('Fatal error:', error);
    process.exit(1);
  }
}

// Execute the script
if (require.main === module) {
  main();
}

module.exports = {
  extractResearchFromSkool,
  insertResearchIntoDatabase
};
</file>

<file path="sync-themes.js">
/**
 * Theme Synchronization Utility
 * 
 * This script synchronizes themes between tv_shows.themes array and the themes/tv_show_themes tables
 * It ensures all themes from TV shows are available in the themes table and properly linked
 */

import pg from 'pg';
const { Pool } = pg;

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
});

/**
 * Get all unique themes from tv_shows.themes arrays
 */
async function getAllThemesFromShows() {
  try {
    const result = await pool.query('SELECT id, themes FROM tv_shows WHERE themes IS NOT NULL AND array_length(themes, 1) > 0');
    
    const allThemes = new Set();
    result.rows.forEach(row => {
      if (row.themes && Array.isArray(row.themes)) {
        row.themes.forEach(theme => {
          if (theme && theme.trim()) {
            allThemes.add(theme.trim());
          }
        });
      }
    });
    
    return Array.from(allThemes);
  } catch (error) {
    console.error('Error getting themes from shows:', error);
    return [];
  }
}

/**
 * Add missing themes to the themes table
 */
async function addMissingThemes(themes) {
  const addedThemes = [];
  
  for (const theme of themes) {
    try {
      const result = await pool.query(
        'INSERT INTO themes (name) VALUES ($1) ON CONFLICT (name) DO NOTHING RETURNING id, name',
        [theme]
      );
      
      if (result.rows.length > 0) {
        addedThemes.push(result.rows[0]);
        console.log(`Added new theme: ${theme}`);
      }
    } catch (error) {
      console.error(`Error adding theme "${theme}":`, error);
    }
  }
  
  return addedThemes;
}

/**
 * Get theme ID by name
 */
async function getThemeId(themeName) {
  try {
    const result = await pool.query('SELECT id FROM themes WHERE name = $1', [themeName]);
    return result.rows.length > 0 ? result.rows[0].id : null;
  } catch (error) {
    console.error(`Error getting theme ID for "${themeName}":`, error);
    return null;
  }
}

/**
 * Sync tv_show_themes relationships
 */
async function syncShowThemeRelationships() {
  try {
    // Get all shows with themes
    const showsResult = await pool.query('SELECT id, themes FROM tv_shows WHERE themes IS NOT NULL AND array_length(themes, 1) > 0');
    
    let synced = 0;
    let errors = 0;
    
    for (const show of showsResult.rows) {
      try {
        // Clear existing relationships for this show
        await pool.query('DELETE FROM tv_show_themes WHERE tv_show_id = $1', [show.id]);
        
        // Add new relationships
        if (show.themes && Array.isArray(show.themes)) {
          for (const theme of show.themes) {
            if (theme && theme.trim()) {
              const themeId = await getThemeId(theme.trim());
              if (themeId) {
                await pool.query(
                  'INSERT INTO tv_show_themes (tv_show_id, theme_id) VALUES ($1, $2) ON CONFLICT (tv_show_id, theme_id) DO NOTHING',
                  [show.id, themeId]
                );
              }
            }
          }
        }
        synced++;
      } catch (error) {
        console.error(`Error syncing themes for show ID ${show.id}:`, error);
        errors++;
      }
    }
    
    console.log(`Synced themes for ${synced} shows (${errors} errors)`);
  } catch (error) {
    console.error('Error syncing show-theme relationships:', error);
  }
}

/**
 * Main synchronization function
 */
async function syncThemes() {
  console.log('Starting theme synchronization...');
  
  try {
    // Get all themes from TV shows
    const allThemes = await getAllThemesFromShows();
    console.log(`Found ${allThemes.length} unique themes in TV shows`);
    
    // Add missing themes to themes table
    const addedThemes = await addMissingThemes(allThemes);
    console.log(`Added ${addedThemes.length} new themes to themes table`);
    
    // Sync relationships
    await syncShowThemeRelationships();
    
    console.log('Theme synchronization completed successfully!');
  } catch (error) {
    console.error('Error during theme synchronization:', error);
  } finally {
    await pool.end();
  }
}

// Run if called directly
import { fileURLToPath } from 'url';
import { dirname } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

if (import.meta.url === `file://${process.argv[1]}`) {
  syncThemes();
}

export { syncThemes };
</file>

<file path="tailwind.config.ts">
import type { Config } from "tailwindcss";

export default {
  darkMode: ["class"],
  content: ["./client/index.html", "./client/src/**/*.{js,jsx,ts,tsx}"],
  theme: {
    extend: {
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      colors: {
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        chart: {
          "1": "hsl(var(--chart-1))",
          "2": "hsl(var(--chart-2))",
          "3": "hsl(var(--chart-3))",
          "4": "hsl(var(--chart-4))",
          "5": "hsl(var(--chart-5))",
        },
        sidebar: {
          DEFAULT: "hsl(var(--sidebar-background))",
          foreground: "hsl(var(--sidebar-foreground))",
          primary: "hsl(var(--sidebar-primary))",
          "primary-foreground": "hsl(var(--sidebar-primary-foreground))",
          accent: "hsl(var(--sidebar-accent))",
          "accent-foreground": "hsl(var(--sidebar-accent-foreground))",
          border: "hsl(var(--sidebar-border))",
          ring: "hsl(var(--sidebar-ring))",
        },
      },
      keyframes: {
        "accordion-down": {
          from: {
            height: "0",
          },
          to: {
            height: "var(--radix-accordion-content-height)",
          },
        },
        "accordion-up": {
          from: {
            height: "var(--radix-accordion-content-height)",
          },
          to: {
            height: "0",
          },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
    },
  },
  plugins: [require("tailwindcss-animate"), require("@tailwindcss/typography")],
} satisfies Config;
</file>

<file path="test-youtube-integration.js">
/**
 * This script tests the YouTube API integration by:
 * 1. Fetching a YouTube show from the database
 * 2. Calling the YouTube API for metadata
 * 3. Displaying the results
 * 
 * Run with: node test-youtube-integration.js
 */

import { pool } from './server/db.ts';
import fetch from 'node-fetch';

// YouTube API URL and key
const YOUTUBE_API_BASE_URL = 'https://www.googleapis.com/youtube/v3';
const API_KEY = process.env.YOUTUBE_API_KEY;

// Test function to search for a channel on YouTube
async function searchYouTubeChannel(channelName) {
  try {
    console.log(`Searching for YouTube channel: "${channelName}"`);
    
    // Construct the search URL
    const searchUrl = `${YOUTUBE_API_BASE_URL}/search?part=snippet&q=${encodeURIComponent(channelName)}&type=channel&maxResults=1&key=${API_KEY}`;
    
    // Make the request
    const response = await fetch(searchUrl);
    const data = await response.json();
    
    // Check for errors
    if (data.error) {
      console.error('YouTube API Error:', data.error.message);
      return null;
    }
    
    // Check if we got any results
    if (!data.items || data.items.length === 0) {
      console.log(`No channel found for "${channelName}"`);
      return null;
    }
    
    // Extract channel ID and basic info
    const channelId = data.items[0].id.channelId;
    const snippet = data.items[0].snippet;
    
    console.log(`Found channel: "${snippet.title}" (${channelId})`);
    
    // Get more detailed channel information
    const channelUrl = `${YOUTUBE_API_BASE_URL}/channels?part=snippet,statistics&id=${channelId}&key=${API_KEY}`;
    const channelResponse = await fetch(channelUrl);
    const channelData = await channelResponse.json();
    
    if (!channelData.items || channelData.items.length === 0) {
      console.log(`Could not get details for channel ID: ${channelId}`);
      return null;
    }
    
    // Return full channel data
    return {
      id: channelId,
      title: channelData.items[0].snippet.title,
      description: channelData.items[0].snippet.description,
      publishedAt: channelData.items[0].snippet.publishedAt,
      thumbnailUrl: channelData.items[0].snippet.thumbnails.high?.url,
      subscriberCount: channelData.items[0].statistics?.subscriberCount,
      videoCount: channelData.items[0].statistics?.videoCount
    };
  } catch (error) {
    console.error(`Error searching YouTube for "${channelName}":`, error);
    return null;
  }
}

// Get a YouTube show from the database to test with
async function getYouTubeShowFromDatabase() {
  try {
    const result = await pool.query(`
      SELECT id, name, available_on, description 
      FROM tv_shows 
      WHERE available_on::text LIKE '%YouTube%'
      LIMIT 1
    `);
    
    if (result.rows.length === 0) {
      console.log('No YouTube shows found in the database');
      return null;
    }
    
    return result.rows[0];
  } catch (error) {
    console.error('Error fetching YouTube show from database:', error);
    return null;
  }
}

// Get a clean description for database storage
function getCleanDescription(description) {
  if (!description) return '';
  
  // Remove common YouTube channel boilerplate
  let cleanDesc = description
    .replace(/subscribe to our channel/gi, '')
    .replace(/follow us on/gi, '')
    .replace(/check out our website/gi, '')
    .replace(/click the bell/gi, '')
    .replace(/http(s)?:\/\/[^\s]+/g, '') // Remove URLs
    .replace(/\n\s*\n/g, '\n') // Remove extra newlines
    .trim();
    
  // If description is too long, trim it
  if (cleanDesc.length > 500) {
    cleanDesc = cleanDesc.substring(0, 500) + '...';
  }
  
  return cleanDesc || '';
}

// Extract release year from publishedAt date
function extractReleaseYear(publishedAt) {
  if (!publishedAt) return null;
  
  try {
    const date = new Date(publishedAt);
    return date.getFullYear();
  } catch (error) {
    console.error('Error parsing publishedAt date:', error);
    return null;
  }
}

// Main test function
async function testYouTubeIntegration() {
  try {
    console.log('Testing YouTube API Integration');
    console.log('==============================');
    
    if (!API_KEY) {
      console.error('Error: YOUTUBE_API_KEY environment variable is not set');
      return;
    }
    
    // Get a YouTube show from the database
    const show = await getYouTubeShowFromDatabase();
    if (!show) {
      console.log('Could not find a YouTube show to test with');
      return;
    }
    
    console.log(`\nFound show in database: "${show.name}" (ID: ${show.id})`);
    console.log(`Current description: "${show.description?.substring(0, 100)}${show.description?.length > 100 ? '...' : ''}"`);
    
    // Search for the channel on YouTube
    const channelData = await searchYouTubeChannel(show.name);
    if (!channelData) {
      console.log('Could not get YouTube data for this show');
      return;
    }
    
    // Display the results
    console.log('\nYouTube API Results:');
    console.log('-------------------');
    console.log(`Channel Title: ${channelData.title}`);
    console.log(`Published At: ${channelData.publishedAt} (${extractReleaseYear(channelData.publishedAt)})`);
    console.log(`Subscriber Count: ${Number(channelData.subscriberCount).toLocaleString()}`);
    console.log(`Video Count: ${Number(channelData.videoCount).toLocaleString()}`);
    console.log(`Thumbnail URL: ${channelData.thumbnailUrl}`);
    
    // Show a cleaned description
    const cleanDesc = getCleanDescription(channelData.description);
    console.log(`\nCleaned Description: "${cleanDesc.substring(0, 100)}${cleanDesc.length > 100 ? '...' : ''}"`);
    
    // Show what would be updated in database
    console.log('\nFields to Update in Database:');
    console.log('---------------------------');
    console.log({
      channelId: channelData.id,
      subscriberCount: channelData.subscriberCount,
      videoCount: channelData.videoCount,
      isYouTubeChannel: true,
      publishedAt: channelData.publishedAt,
      releaseYear: extractReleaseYear(channelData.publishedAt),
      description: cleanDesc,
      // If the creator is missing, we'd use the channel title
      creator: channelData.title
    });
    
  } catch (error) {
    console.error('Test failed:', error);
  } finally {
    // Close the database connection
    pool.end();
  }
}

// Run the test
testYouTubeIntegration();
</file>

<file path="tsconfig.json">
{
  "include": ["client/src/**/*", "shared/**/*", "server/**/*"],
  "exclude": ["node_modules", "build", "dist", "**/*.test.ts"],
  "compilerOptions": {
    "incremental": true,
    "tsBuildInfoFile": "./node_modules/typescript/tsbuildinfo",
    "noEmit": true,
    "module": "ESNext",
    "strict": true,
    "lib": ["esnext", "dom", "dom.iterable"],
    "jsx": "preserve",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "allowImportingTsExtensions": true,
    "moduleResolution": "bundler",
    "baseUrl": ".",
    "types": ["node", "vite/client"],
    "paths": {
      "@/*": ["./client/src/*"],
      "@shared/*": ["./shared/*"]
    }
  }
}
</file>

<file path="update-all-image-paths.js">
/**
 * This script updates all image URLs in the database to use the primary image directory
 * It will fetch remote images (GitHub, OMDB) and save them locally if needed
 */

import fs from 'fs';
import path from 'path';
import pg from 'pg';
import fetch from 'node-fetch';
import { fileURLToPath } from 'url';
import dotenv from 'dotenv';
dotenv.config();

// Get the current file's directory
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Define paths
const PRIMARY_IMAGE_DIR = path.join(__dirname, 'public', 'media', 'tv-shows');

// Ensure directory exists
if (!fs.existsSync(PRIMARY_IMAGE_DIR)) {
  fs.mkdirSync(PRIMARY_IMAGE_DIR, { recursive: true });
}

// Database connection
const pool = new pg.Pool({
  connectionString: process.env.DATABASE_URL,
});

// Download an image from a URL
async function downloadImage(url, showId) {
  try {
    // Skip if not a URL
    if (!url.startsWith('http')) {
      return null;
    }
    
    // Create a unique filename based on show ID
    const ext = path.extname(url) || '.jpg'; // Default to jpg if no extension
    const filename = `show-${showId}${ext}`;
    const localPath = path.join(PRIMARY_IMAGE_DIR, filename);
    
    // Check if image already exists
    if (fs.existsSync(localPath)) {
      console.log(`Image for show ID ${showId} already exists at ${localPath}`);
      return `/media/tv-shows/${filename}`;
    }
    
    // Fetch the image
    console.log(`Downloading image from ${url}`);
    const response = await fetch(url);
    
    if (!response.ok) {
      throw new Error(`Failed to fetch image: ${response.status} ${response.statusText}`);
    }
    
    // Get image as buffer
    const imageBuffer = await response.buffer();
    
    // Save to file
    fs.writeFileSync(localPath, imageBuffer);
    console.log(`Saved image to ${localPath}`);
    
    // Return web path
    return `/media/tv-shows/${filename}`;
  } catch (error) {
    console.error(`Error downloading image for show ID ${showId}:`, error);
    return null;
  }
}

// Main function to update all image URLs
async function updateAllImagePaths() {
  try {
    // Get all shows with images
    const { rows: shows } = await pool.query(
      "SELECT id, name, image_url FROM tv_shows WHERE image_url IS NOT NULL AND image_url NOT LIKE '/media/tv-shows/%'"
    );
    
    console.log(`Found ${shows.length} shows with non-primary image paths to update`);
    
    let successCount = 0;
    let errorCount = 0;
    
    // Process each show
    for (const show of shows) {
      try {
        const { id, name, image_url } = show;
        
        console.log(`\nProcessing show: ${name} (ID: ${id})`);
        console.log(`Current image URL: ${image_url}`);
        
        let newPath = null;
        
        // Handle remote images
        if (image_url.startsWith('http')) {
          newPath = await downloadImage(image_url, id);
        } 
        // Handle local images that aren't in the primary directory
        else if (image_url.startsWith('/') && !image_url.startsWith('/media/tv-shows/')) {
          // Create filename based on show ID for consistency
          const ext = path.extname(image_url) || '.jpg';
          const filename = `show-${id}${ext}`;
          const targetPath = path.join(PRIMARY_IMAGE_DIR, filename);
          
          // Try to find the source file
          const relativePath = image_url.startsWith('/') ? image_url.substring(1) : image_url;
          const possibleSourcePaths = [
            path.join(__dirname, relativePath),
            path.join(__dirname, 'client/public', relativePath),
            path.join(__dirname, 'public', relativePath),
            path.join(__dirname, 'client/public/custom-images', path.basename(relativePath)),
            path.join(__dirname, 'public/custom-images', path.basename(relativePath)),
            path.join(__dirname, 'public/uploads', path.basename(relativePath)),
            path.join(__dirname, 'public/uploads/optimized', path.basename(relativePath))
          ];
          
          // Find the first path that exists
          let sourcePath = null;
          for (const checkPath of possibleSourcePaths) {
            if (fs.existsSync(checkPath)) {
              sourcePath = checkPath;
              break;
            }
          }
          
          if (sourcePath) {
            // Copy the file to the primary directory
            fs.copyFileSync(sourcePath, targetPath);
            console.log(`Copied image from ${sourcePath} to ${targetPath}`);
            newPath = `/media/tv-shows/${filename}`;
          } else {
            console.log(`Could not find source image for path: ${image_url}`);
          }
        }
        
        // Update the database if we have a new path
        if (newPath) {
          await pool.query(
            'UPDATE tv_shows SET image_url = $1 WHERE id = $2',
            [newPath, id]
          );
          
          console.log(`Updated image path for ${name} to ${newPath}`);
          successCount++;
        } else {
          console.log(`Could not update image path for ${name}`);
          errorCount++;
        }
      } catch (error) {
        console.error(`Error processing show:`, error);
        errorCount++;
      }
    }
    
    console.log('\nUpdate complete:');
    console.log(`- Successfully updated: ${successCount}`);
    console.log(`- Failed to update: ${errorCount}`);
    console.log(`- Total processed: ${shows.length}`);
    
  } catch (error) {
    console.error('Error during update process:', error);
  } finally {
    await pool.end();
  }
}

// Run the main function
updateAllImagePaths().catch(console.error);
</file>

<file path="update-youtube-shows.mjs">
/**
 * Script to update TV shows with YouTube-specific data
 * 
 * This standalone script:
 * 1. Identifies all shows with "YouTube" in their availableOn field
 * 2. Fetches YouTube channel data for each show
 * 3. Updates the database with YouTube-specific information
 */

import { db } from './server/db.ts';
import fetch from 'node-fetch';

// Base URL for YouTube API
const YOUTUBE_API_BASE_URL = 'https://www.googleapis.com/youtube/v3';

/**
 * Get YouTube channel data by name
 */
async function getYouTubeChannelData(channelName) {
  try {
    const apiKey = process.env.YOUTUBE_API_KEY;
    if (!apiKey) {
      console.error('YOUTUBE_API_KEY environment variable is not set');
      return null;
    }

    console.log(`Fetching YouTube data for "${channelName}"`);

    // First search for the channel
    const searchUrl = `${YOUTUBE_API_BASE_URL}/search?part=snippet&q=${encodeURIComponent(channelName)}&type=channel&maxResults=1&key=${apiKey}`;
    const searchResponse = await fetch(searchUrl);
    const searchData = await searchResponse.json();

    if (!searchData?.items || !Array.isArray(searchData.items) || searchData.items.length === 0) {
      console.warn(`No YouTube channel found for "${channelName}"`);
      return null;
    }

    // Get the channel ID from search results
    const channelId = searchData.items[0]?.id?.channelId;
    if (!channelId) {
      console.warn(`Invalid channel ID for "${channelName}"`);
      return null;
    }

    // Get detailed channel information
    const channelUrl = `${YOUTUBE_API_BASE_URL}/channels?part=snippet,statistics&id=${channelId}&key=${apiKey}`;
    const channelResponse = await fetch(channelUrl);
    const channelData = await channelResponse.json();

    if (!channelData?.items || !Array.isArray(channelData.items) || channelData.items.length === 0) {
      console.warn(`Failed to get details for channel "${channelName}"`);
      return null;
    }

    const channel = channelData.items[0];
    
    return {
      title: channel.snippet.title,
      description: channel.snippet.description || '',
      publishedAt: channel.snippet.publishedAt,
      thumbnailUrl: channel.snippet.thumbnails.high?.url || '',
      subscriberCount: channel.statistics?.subscriberCount || '0',
      videoCount: channel.statistics?.videoCount || '0',
      channelId: channelId
    };
  } catch (error) {
    console.error(`Error fetching YouTube data for "${channelName}":`, error);
    return null;
  }
}

/**
 * Extract a release year from YouTube publishedAt date
 */
function extractReleaseYear(publishedAt) {
  if (!publishedAt) return null;
  
  try {
    const date = new Date(publishedAt);
    return date.getFullYear();
  } catch (error) {
    console.error('Error parsing YouTube publishedAt date:', error);
    return null;
  }
}

/**
 * Clean up YouTube description for the database
 */
function getCleanDescription(description) {
  if (!description) return '';
  
  // Remove common YouTube channel boilerplate
  let cleanDesc = description
    .replace(/subscribe to our channel/gi, '')
    .replace(/follow us on/gi, '')
    .replace(/check out our website/gi, '')
    .replace(/click the bell/gi, '')
    .replace(/http(s)?:\/\/[^\s]+/g, '') // Remove URLs
    .replace(/\n\s*\n/g, '\n') // Remove extra newlines
    .trim();
    
  // If description is too long, trim it
  if (cleanDesc.length > 500) {
    cleanDesc = cleanDesc.substring(0, 500) + '...';
  }
  
  return cleanDesc || '';
}

/**
 * Main function to update YouTube shows
 */
async function updateYouTubeShows() {
  try {
    console.log('Starting YouTube show update process...');
    
    // Get all shows with "YouTube" in availableOn
    const result = await db.query(`
      SELECT id, name, available_on, description, creator, release_year, 
             is_youtube_channel, channel_id, subscriber_count, video_count
      FROM tv_shows 
      WHERE available_on::text LIKE '%YouTube%'
    `);
    
    const youtubeShows = result.rows;
    console.log(`Found ${youtubeShows.length} YouTube shows`);
    
    let updated = 0;
    let skipped = 0;
    let failed = 0;
    
    for (const show of youtubeShows) {
      console.log(`\nProcessing: ${show.name}`);
      
      if (show.is_youtube_channel && show.channel_id && show.subscriber_count) {
        console.log(`  Already has YouTube data. Skipping.`);
        skipped++;
        continue;
      }
      
      const youtubeData = await getYouTubeChannelData(show.name);
      if (!youtubeData) {
        console.log(`  No YouTube data found. Failed.`);
        failed++;
        continue;
      }
      
      // Get a clean description
      const cleanDescription = getCleanDescription(youtubeData.description);
      
      // Build update data
      const updates = {
        channel_id: youtubeData.channelId,
        subscriber_count: youtubeData.subscriberCount,
        video_count: youtubeData.videoCount,
        is_youtube_channel: true,
        published_at: youtubeData.publishedAt
      };
      
      // Update description if it's generic
      if ((show.description === 'A children\'s TV show' || !show.description) && cleanDescription) {
        updates.description = cleanDescription;
      }
      
      // Update creator if missing
      if (!show.creator && youtubeData.title) {
        updates.creator = youtubeData.title;
      }
      
      // Update release year if missing
      const releaseYear = extractReleaseYear(youtubeData.publishedAt);
      if (!show.release_year && releaseYear) {
        updates.release_year = releaseYear;
      }
      
      // Format the SET clause for SQL
      const setClause = Object.entries(updates)
        .map(([key, value]) => {
          if (value === null) return `${key} = NULL`;
          if (typeof value === 'boolean') return `${key} = ${value}`;
          if (typeof value === 'number') return `${key} = ${value}`;
          return `${key} = '${value.replace(/'/g, "''")}'`; // Escape single quotes
        })
        .join(', ');
      
      // Update the show
      const updateQuery = `
        UPDATE tv_shows
        SET ${setClause}
        WHERE id = ${show.id}
      `;
      
      try {
        await db.query(updateQuery);
        console.log(`  Successfully updated with YouTube data:`, updates);
        updated++;
      } catch (error) {
        console.error(`  Error updating show:`, error);
        failed++;
      }
      
      // Add a delay to avoid hitting API rate limits
      await new Promise(resolve => setTimeout(resolve, 250));
    }
    
    console.log('\nSummary:');
    console.log(`  Total shows processed: ${youtubeShows.length}`);
    console.log(`  Successfully updated: ${updated}`);
    console.log(`  Skipped (already has data): ${skipped}`);
    console.log(`  Failed: ${failed}`);
    
  } catch (error) {
    console.error('Error in update process:', error);
  }
}

// Run the script
updateYouTubeShows()
  .then(() => {
    console.log('YouTube show update complete');
    process.exit(0);
  })
  .catch(error => {
    console.error('Script failed:', error);
    process.exit(1);
  });
</file>

<file path="UTILITIES.md">
# TV Tantrum Utilities

This document provides an overview of the consolidated utility scripts that have been created to streamline maintenance and updates to the TV Tantrum application.

## Overview

We've consolidated multiple overlapping scripts into a few core utilities to make the codebase more maintainable:

1. **Image Optimizer** - Handles optimization of images for better SEO and performance
2. **API Data Updater** - Updates TV show data from OMDb and YouTube APIs
3. **Image Manager** - Handles mapping, restoration, and consolidation of images
4. **Data Manager** - Consolidates TV show data from multiple sources and updates sensory details

## Image Optimizer (`image-optimizer.js`)

Consolidated from:
- optimize-custom-images.js
- optimize-seo-images.js

This utility optimizes images for better SEO and performance:

```bash
# Run image optimization
node image-optimizer.js
```

Functions:
- `optimizeAllImages()` - Optimizes all images in the database
- `optimizeImage(filePath, showId)` - Optimizes a single image
- `getImage(imageUrl, showId)` - Downloads or copies an image from URL or local path
- `updateShowImage(showId, optimizedUrl)` - Updates a show's image URL in the database

## API Data Updater (`api-data-updater.js`)

Consolidated from:
- update-api-data.js
- update-all-shows-api-data.js
- update-youtube-metadata.js

This utility updates TV show data from OMDb and YouTube APIs:

```bash
# Run full API data update 
node api-data-updater.js

# Run YouTube-only update
node api-data-updater.js --youtube
```

Functions:
- `updateAllShowsApiData()` - Updates all shows with data from OMDb and YouTube APIs
- `updateYouTubeShows()` - Updates only YouTube shows/channels
- `updateShowWithApiData(show)` - Updates a single show with API data

## Image Manager (`image-manager.js`)

Consolidated from:
- map-custom-images.js
- update-custom-images.js
- restore-custom-images.js
- consolidate-images.js

This utility manages image mappings, restoration, and consolidation:

```bash
# Map custom images to TV shows
node image-manager.js --map

# Restore custom images from backup
node image-manager.js --restore

# Consolidate images into a single directory
node image-manager.js --consolidate
```

Functions:
- `mapCustomImages()` - Maps custom images to TV shows
- `restoreCustomImages()` - Restores custom images from backup
- `consolidateImages()` - Consolidates images into a single directory
- `loadCustomImageMap()` - Loads the custom image map from file
- `saveCustomImageMap()` - Saves the custom image map to file

## Data Manager (`data-manager.js`)

Consolidated from:
- consolidate-tv-data.js
- update-sensory-details.js
- update-show-metrics.js

This utility manages TV show data:

```bash
# Consolidate TV show data from multiple sources
node data-manager.js --consolidate

# Update sensory details for TV shows
node data-manager.js --sensory
```

Functions:
- `consolidateTvData()` - Consolidates TV show data from multiple sources
- `updateSensoryDetails()` - Updates sensory details for TV shows
- `loadCustomShowDetails()` - Loads custom show details from file
- `saveCustomShowDetails()` - Saves custom show details to file
- `updateTvShow(id, details)` - Updates a TV show's details in the database

## Usage Examples

### Updating TV Show Data

To completely refresh the TV show data from all sources:

1. Consolidate data from multiple sources:
   ```bash
   node data-manager.js --consolidate
   ```

2. Update with latest API data:
   ```bash
   node api-data-updater.js
   ```

3. Optimize all images:
   ```bash
   node image-optimizer.js
   ```

### Managing Custom Images

To ensure custom images are correctly applied:

1. Map any new custom images:
   ```bash
   node image-manager.js --map
   ```

2. Restore custom images if they've been overwritten:
   ```bash
   node image-manager.js --restore
   ```

## Maintenance Tips

- Run these utilities in the order listed for optimal results
- Always back up data files before running major updates
- The utility scripts maintain consistency with existing data structures
- All utilities export their functions for use in other modules

## Benefits of Consolidation

- Reduced code duplication
- More maintainable codebase
- Consistent error handling
- Better performance through optimized operations
- Clear documentation and usage instructions
</file>

<file path="vite.config.ts">
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import path from "path";
import runtimeErrorOverlay from "@replit/vite-plugin-runtime-error-modal";

export default defineConfig({
  plugins: [
    react(),
    runtimeErrorOverlay(),
    ...(process.env.NODE_ENV !== "production" && process.env.REPL_ID !== undefined
      ? [
          await import("@replit/vite-plugin-cartographer").then((m) =>
            m.cartographer(),
          ),
        ]
      : []),
  ],

  resolve: {
    alias: {
      "@": path.resolve(import.meta.dirname, "client", "src"),
      "@shared": path.resolve(import.meta.dirname, "shared"),
      "@assets": path.resolve(import.meta.dirname, "attached_assets"),
    },
    // 👇 ensures only a single copy of React is bundled
    dedupe: ["react", "react-dom"],
  },

  root: path.resolve(import.meta.dirname, "client"),

  build: {
    outDir: path.resolve(import.meta.dirname, "dist/public"),
    emptyOutDir: true,
  },
});
</file>

<file path="client/src/components/GoogleAd.tsx">
import { useEffect } from 'react';
import { pushAd } from '@/lib/adsense';

interface GoogleAdProps {
  slot: string;
  format?: string;
  width?: number;
  height?: number;
  className?: string;
  responsive?: boolean;
}

const GoogleAd = ({ 
  slot, 
  format = 'auto', 
  width, 
  height, 
  className = '',
  responsive = true 
}: GoogleAdProps) => {
  const adsenseId = import.meta.env.VITE_GOOGLE_ADSENSE_ID;

  useEffect(() => {
    try {
      pushAd();
    } catch (error) {
      console.error('Error pushing ad:', error);
    }
  }, []);

  if (!adsenseId) {
    return null;
  }

  const adStyle: React.CSSProperties = {};
  if (width) adStyle.width = width;
  if (height) adStyle.height = height;

  return (
    <div className={`ad-container ${className}`}>
      <ins
        className="adsbygoogle"
        style={{
          display: 'block',
          ...adStyle
        }}
        data-ad-client={adsenseId}
        data-ad-slot={slot}
        data-ad-format={format}
        data-full-width-responsive={responsive ? 'true' : 'false'}
      />
    </div>
  );
};

export default GoogleAd;
</file>

<file path="client/src/hooks/use-analytics.tsx">
import { useEffect, useRef } from 'react';
import { useLocation } from 'wouter';
import { trackPageView } from '../lib/analytics';

export const useAnalytics = () => {
  const [location] = useLocation();
  const prevLocationRef = useRef<string>(location);
  
  useEffect(() => {
    if (location !== prevLocationRef.current) {
      trackPageView(location);
      prevLocationRef.current = location;
    }
  }, [location]);
};
</file>

<file path="client/src/hooks/use-auth.tsx">
import React, { createContext, ReactNode, useContext, useEffect } from "react";
import {
  useQuery,
  useMutation,
  UseMutationResult,
} from "@tanstack/react-query";
import { User, InsertUser } from "@shared/schema";
import { getQueryFn, queryClient } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";

type AuthContextType = {
  user: User | null;
  isLoading: boolean;
  error: Error | null;
  loginMutation: UseMutationResult<User, Error, LoginData>;
  logoutMutation: UseMutationResult<void, Error, void>;
  registerMutation: UseMutationResult<User, Error, InsertUser>;
  isFavorite: (showId: number) => Promise<boolean>;
  toggleFavorite: (showId: number) => Promise<void>;
  isAdmin: boolean;
  isApproved: boolean;
};

interface LoginData {
  identifier: string; // Can be either email or username
  password: string;
}

export const AuthContext = createContext<AuthContextType | null>(null);

export function AuthProvider({ children }: { children: ReactNode }) {
  const { toast } = useToast();

  // Remove localStorage auth checking - rely only on server sessions
  const hasStoredAuth = () => {
    return false; // Always check with server instead of localStorage
  };
  
  // Fetch current user data
  const {
    data: user,
    error,
    isLoading,
    refetch
  } = useQuery<User | null, Error>({
    queryKey: ["/api/user"],
    queryFn: getQueryFn({ on401: "returnNull" }),
    // This ensures we never have undefined, only null for unauthenticated users
    select: (data) => data ?? null,
    // Initialize with null (not authenticated)
    initialData: null,
    // Always fetch on mount to ensure we have latest auth state
    enabled: true,
    // If auth token is invalid, retry a few times before giving up
    retry: 2,
    // Refresh user data every 30 minutes to reduce server load
    refetchInterval: 30 * 60 * 1000,
    // Only refetch on window focus for important state changes
    refetchOnWindowFocus: false,
    // Keep data for longer to prevent losing auth state during navigation
    staleTime: 5 * 60 * 1000, // 5 minutes
    gcTime: 10 * 60 * 1000, // 10 minutes
    // Never consider the query as background refetch during navigation
    refetchOnMount: "always",
    // Ensure we have a definitive auth state before proceeding
    networkMode: "always"
  });
  
  // Effect to manage authentication state - removed localStorage dependencies

  // Login mutation
  const loginMutation = useMutation({
    mutationFn: async (credentials: LoginData) => {
      try {
        const res = await fetch("/api/login", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(credentials),
          credentials: "include"
        });
        
        if (!res.ok) {
          const errorData = await res.json();
          console.log('Login error response:', errorData);
          
          // Create a custom error object with properties for approval status
          const error = new Error(errorData.message || "Login failed");
          // @ts-ignore - Adding custom property
          error.isPendingApproval = errorData.isPendingApproval || errorData.message?.includes("pending approval") || false;
          throw error;
        }
        
        return await res.json();
      } catch (err) {
        console.log('Login mutation caught error:', err);
        throw err;
      }
    },
    onSuccess: (user: User) => {
      // Only update React Query cache - no localStorage storage
      queryClient.setQueryData(["/api/user"], user);
    },
    onError: (error: Error) => {
      toast({
        title: "Login failed",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  // Register mutation
  const registerMutation = useMutation({
    mutationFn: async (credentials: InsertUser) => {
      const res = await fetch("/api/register", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(credentials),
        credentials: "include"
      });
      
      if (!res.ok) {
        const errorData = await res.json().catch(() => null);
        if (errorData && errorData.message) {
          throw new Error(errorData.message);
        }
        throw new Error("Registration failed");
      }
      
      return await res.json();
    },
    onSuccess: (user: User) => {
      // Update React Query cache with user data
      queryClient.setQueryData(["/api/user"], user);
      
      // Trigger a refetch to ensure we have the latest user data
      refetch();
    },
    onError: (error: Error) => {
      
      toast({
        title: "Registration failed",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  // Logout mutation
  const logoutMutation = useMutation({
    mutationFn: async () => {
      const res = await fetch("/api/logout", {
        method: "POST",
        credentials: "include"
      });
      
      if (!res.ok) {
        const errorText = await res.text();
        throw new Error(errorText || "Logout failed");
      }
    },
    onSuccess: () => {
      // Update React Query cache
      queryClient.setQueryData(["/api/user"], null);
      
      // Invalidate any query keys that depend on user authentication
      queryClient.invalidateQueries({ queryKey: ["/api/favorites"] });
    },
    onError: (error: Error) => {
      toast({
        title: "Logout failed",
        description: error.message,
        variant: "destructive",
      });
    },
  });

  // Check if a show is in user's favorites
  const isFavorite = async (showId: number): Promise<boolean> => {
    if (!user) return false;
    
    try {
      const res = await fetch(`/api/favorites/${showId}`, {
        credentials: "include"
      });
      
      if (!res.ok) {
        return false;
      }
      
      const data = await res.json();
      return data.isFavorite;
    } catch (error) {
      console.error("Error checking favorite status:", error);
      return false;
    }
  };

  // Toggle favorite status for a show with optimistic updates
  const toggleFavorite = async (showId: number, currentStatus?: boolean): Promise<void> => {
    if (!user) {
      throw new Error("User must be logged in to manage favorites");
    }
    
    // Use provided status or check current status
    let isFav = currentStatus;
    if (isFav === undefined) {
      isFav = await isFavorite(showId);
    }
    
    try {
      if (isFav) {
        // Remove from favorites
        const res = await fetch(`/api/favorites/${showId}`, {
          method: "DELETE",
          credentials: "include"
        });
        
        if (!res.ok) {
          const errorText = await res.text();
          throw new Error(errorText || "Failed to remove from favorites");
        }
      } else {
        // Add to favorites
        const res = await fetch("/api/favorites", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ tvShowId: showId }),
          credentials: "include"
        });
        
        if (!res.ok) {
          const errorText = await res.text();
          throw new Error(errorText || "Failed to add to favorites");
        }
      }
      
      // Invalidate relevant queries to refresh data
      queryClient.invalidateQueries({ queryKey: ["/api/favorites"] });
      queryClient.invalidateQueries({ queryKey: ["/api/user/dashboard"] });
      
    } catch (error) {
      // Re-throw error for components to handle
      throw error;
    }
  };

  // Check if the user has admin privileges
  const isAdmin = user?.isAdmin === true;
  
  // Check if the user is approved
  const isApproved = user?.isApproved === true;

  return (
    <AuthContext.Provider
      value={{
        user,
        isLoading,
        error,
        loginMutation,
        logoutMutation,
        registerMutation,
        isFavorite,
        toggleFavorite,
        isAdmin,
        isApproved,
      }}
    >
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error("useAuth must be used within an AuthProvider");
  }
  return context;
}
</file>

<file path="client/src/lib/adsense.ts">
// Google AdSense integration utilities
declare global {
  interface Window {
    adsbygoogle: any[];
  }
}

// Initialize Google AdSense
export const initAdSense = () => {
  const adsenseId = import.meta.env.VITE_GOOGLE_ADSENSE_ID;

  if (!adsenseId) {
    console.warn('Missing required Google AdSense key: VITE_GOOGLE_ADSENSE_ID');
    return;
  }

  // Add Google AdSense script to the head if not already present
  if (!document.querySelector(`script[src*="pagead2.googlesyndication.com"]`)) {
    const script = document.createElement('script');
    script.async = true;
    script.src = `https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=${adsenseId}`;
    script.crossOrigin = 'anonymous';
    document.head.appendChild(script);
  }

  // Initialize adsbygoogle array if not present
  if (!window.adsbygoogle) {
    window.adsbygoogle = [];
  }
};

// Push ad to be displayed
export const pushAd = () => {
  try {
    if (window.adsbygoogle) {
      window.adsbygoogle.push({});
    }
  } catch (error) {
    console.error('AdSense error:', error);
  }
};
</file>

<file path="client/src/lib/analytics.ts">
// Define the gtag function globally
declare global {
  interface Window {
    dataLayer: any[];
    gtag: (...args: any[]) => void;
  }
}

// Initialize Google Analytics
export const initGA = () => {
  const measurementId = import.meta.env.VITE_GA_MEASUREMENT_ID;

  if (!measurementId) {
    console.warn('Missing required Google Analytics key: VITE_GA_MEASUREMENT_ID');
    return;
  }

  // Add Google Analytics script to the head
  const script1 = document.createElement('script');
  script1.async = true;
  script1.src = `https://www.googletagmanager.com/gtag/js?id=${measurementId}`;
  document.head.appendChild(script1);

  // Initialize gtag
  const script2 = document.createElement('script');
  script2.innerHTML = `
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', '${measurementId}');
  `;
  document.head.appendChild(script2);
};

// Track page views - useful for single-page applications
export const trackPageView = (url: string) => {
  if (typeof window === 'undefined' || !window.gtag) return;
  
  const measurementId = import.meta.env.VITE_GA_MEASUREMENT_ID;
  if (!measurementId) return;
  
  window.gtag('config', measurementId, {
    page_path: url
  });
};

// Track events
export const trackEvent = (
  action: string, 
  category?: string, 
  label?: string, 
  value?: number
) => {
  if (typeof window === 'undefined' || !window.gtag) return;
  
  window.gtag('event', action, {
    event_category: category,
    event_label: label,
    value: value,
  });
};
</file>

<file path="client/src/pages/compare.tsx">
import { useState, useEffect } from "react";
import { useQuery } from "@tanstack/react-query";
import { useLocation } from "wouter";
import { Button } from "@/components/ui/button";
import { Skeleton } from "@/components/ui/skeleton";
import { Badge } from "@/components/ui/badge";
import AdContainer from "@/components/AdContainer";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { getStimulationScoreColor } from "@/lib/showUtils";
import RatingBar from "@/components/RatingBar";
import { TvShow } from "@shared/schema";

export default function Compare() {
  const [_, setLocation] = useLocation();
  const [selectedShowIds, setSelectedShowIds] = useState<number[]>([]);
  const [showToAdd, setShowToAdd] = useState<string>("");

  // Fetch all TV shows for the selector directly from tv_shows database
  const { data: allShows, isLoading: loadingShows } = useQuery<TvShow[]>({
    queryKey: ['/api/tv-shows'],
    staleTime: 300000, // 5 minutes cache
  });

  // Fetch details for selected shows
  const { data: selectedShows, isLoading: loadingSelected } = useQuery<TvShow[]>({
    queryKey: ['/api/tv-shows'],
    enabled: selectedShowIds.length > 0,
    select: (data) => {
      if (!data) return [];
      return data.filter(show => selectedShowIds.includes(show.id));
    }
  });

  const handleBackClick = () => {
    setLocation("/");
  };

  const handleRemoveShow = (id: number) => {
    setSelectedShowIds(prev => prev.filter(showId => showId !== id));
  };

  // Update to immediately add show when selected from dropdown
  const handleAddShow = (value: string) => {
    if (value && !selectedShowIds.includes(Number(value))) {
      setSelectedShowIds(prev => [...prev, Number(value)]);
      setShowToAdd("");
    }
  };

  // Load comparison data from localStorage on component mount
  useEffect(() => {
    const savedComparison = localStorage.getItem('tvShowComparison');
    if (savedComparison) {
      try {
        const parsed = JSON.parse(savedComparison);
        if (Array.isArray(parsed)) {
          setSelectedShowIds(parsed);
        }
      } catch (e) {
        console.error("Error parsing saved comparison data", e);
      }
    }
  }, []);

  // Save comparison to localStorage when it changes
  useEffect(() => {
    if (selectedShowIds.length > 0) {
      localStorage.setItem('tvShowComparison', JSON.stringify(selectedShowIds));
    }
  }, [selectedShowIds]);

  const isLoading = loadingShows || loadingSelected;

  // Get available shows that aren't already in the comparison
  const availableShows = allShows?.filter(
    show => !selectedShowIds.includes(show.id)
  );

  // Helper function to get level percentage for bar charts
  const getLevelPercentage = (level: string) => {
    switch(level) {
      case 'Low': return 20;
      case 'Limited': return 20;
      case 'Minimal': return 20;
      case 'Moderate-Low': return 40;
      case 'Moderate': return 60;
      case 'Moderate-High': return 80;
      case 'High': return 100;
      default: return 60;
    }
  };
  
  // Helper function to determine rating level based on text
  const getRatingLevel = (rating: string | null | undefined): number => {
    if (!rating) return 3; // Default to moderate
    
    if (rating.includes('Low-Moderate') || rating.includes('Low to Moderate')) {
      return 2;
    } else if (rating.includes('Moderate-Low')) {
      return 2;
    } else if (rating.includes('Moderate-High') || rating.includes('Moderate to High')) {
      return 4;
    } else if (rating.includes('Mod-High')) {
      return 4;
    } else if (rating === 'Low') {
      return 1;
    } else if (rating === 'Moderate') {
      return 3;
    } else if (rating === 'High') {
      return 5;
    } else if (rating === 'Limited') {
      return 1;
    } else if (rating === 'Minimal') {
      return 1;
    }
    
    return 3; // Default to moderate
  };
  
  // Function to render segmented bar like on the details page
  const renderSegmentedBar = (ratingText: string | null | undefined) => {
    const level = getRatingLevel(ratingText);
    const percentage = level * 20;
    
    return (
      <div className="w-full h-4 relative">
        <div className="w-full h-4 bg-gray-200 rounded-full overflow-hidden flex">
          {[1, 2, 3, 4, 5].map((segment) => {
            const color = 
              segment === 1 ? 'bg-green-500' : 
              segment === 2 ? 'bg-green-400' : 
              segment === 3 ? 'bg-yellow-500' : 
              segment === 4 ? 'bg-orange-500' : 
              'bg-red-500';
            
            return (
              <div
                key={segment}
                className={`h-full w-1/5 ${segment <= level ? color : 'bg-gray-200'}`}
              />
            );
          })}
        </div>
        <div 
          className="absolute h-full flex items-center" 
          style={{ 
            width: '2px', 
            backgroundColor: 'black',
            left: `calc(${percentage}% - 1px)`,
            top: 0
          }}
        ></div>
      </div>
    );
  };

  // Helper function to get stimulation score dots
  const getStimulationScoreDots = (score: number) => {
    return (
      <div className="flex justify-center gap-1 mb-1">
        {[1, 2, 3, 4, 5].map((dot) => {
          let bgColor = '';
          if (dot === 1) bgColor = 'bg-green-500';
          else if (dot === 2) bgColor = 'bg-green-400';
          else if (dot === 3) bgColor = 'bg-yellow-500';
          else if (dot === 4) bgColor = 'bg-orange-500';
          else bgColor = 'bg-red-500';
          
          return (
            <div 
              key={dot} 
              className={`w-3 h-3 rounded-full ${dot <= score ? bgColor : 'border border-gray-300'}`}
            />
          );
        })}
      </div>
    );
  };

  return (
    <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
      <div className="flex items-center justify-between mb-6">
        <div className="flex items-center">
          <Button variant="ghost" className="mr-4 text-primary" onClick={handleBackClick}>
            <i className="fas fa-arrow-left mr-2"></i> Back
          </Button>
          <h2 className="text-2xl font-heading font-bold">Compare Shows</h2>
        </div>
      </div>

      {/* Compare Page Ad */}
      <div className="mb-6">
        <AdContainer size="leaderboard" className="mx-auto" />
      </div>
      
      {isLoading ? (
        <div className="bg-white rounded-xl shadow-md overflow-hidden p-8">
          <Skeleton className="h-96 w-full" />
        </div>
      ) : (
        <div>
          {/* Show selector area in portrait format */}
          <div className="mb-6 grid grid-cols-3 gap-4">
            {[0, 1, 2].map((index) => {
              const show = selectedShows && selectedShows[index];
              return (
                <div key={index} className="bg-white rounded-lg shadow-md p-4">
                  <div className="flex flex-col items-center">
                    <p className="text-sm text-gray-500 mb-2">Show {index + 1}</p>
                    {show ? (
                      <>
                        <div className="relative mb-2">
                          {show.imageUrl ? (
                            <img
                              src={show.imageUrl}
                              alt={show.name}
                              className="w-20 h-20 object-cover rounded-lg"
                            />
                          ) : (
                            <div className="w-20 h-20 bg-gray-200 rounded-lg flex items-center justify-center">
                              <i className="fas fa-tv text-gray-400 text-xl"></i>
                            </div>
                          )}
                          <button
                            onClick={() => handleRemoveShow(show.id)}
                            className="absolute -top-2 -right-2 bg-red-500 text-white rounded-full w-6 h-6 flex items-center justify-center"
                          >
                            <i className="fas fa-times text-xs"></i>
                          </button>
                        </div>
                        <p className="font-medium text-center text-sm">{show.name}</p>
                      </>
                    ) : (
                      <div className="w-full">
                        <Select
                          value={showToAdd}
                          onValueChange={(value) => handleAddShow(value)}
                        >
                          <SelectTrigger className="bg-white text-sm">
                            <SelectValue placeholder="Select a show" />
                          </SelectTrigger>
                          <SelectContent>
                            {availableShows && availableShows.length > 0 ? (
                              availableShows.map(show => (
                                <SelectItem key={show.id} value={String(show.id)}>
                                  {show.name}
                                </SelectItem>
                              ))
                            ) : (
                              <SelectItem value="no-shows" disabled>
                                No more shows available
                              </SelectItem>
                            )}
                          </SelectContent>
                        </Select>
                      </div>
                    )}
                  </div>
                </div>
              );
            })}
          </div>

          {selectedShows && selectedShows.length > 0 ? (
            <div className="bg-white rounded-xl shadow-md overflow-hidden p-6">
              <h3 className="text-xl font-bold mb-6">Compare Shows</h3>
              
              {/* Comparison table with mobile-friendly layout */}
              <div className="mb-8">
                {/* Show names at the top of columns */}
                <div className="grid grid-cols-3 gap-4 mb-4">
                  {selectedShows.map(show => (
                    <div key={`name-${show.id}`} className="font-medium text-center text-lg">
                      {show.name}
                    </div>
                  ))}
                  {selectedShows.length < 3 && (
                    Array(3 - selectedShows.length).fill(0).map((_, i) => (
                      <div key={`empty-name-${i}`} className="font-medium text-center text-lg text-gray-400">-</div>
                    ))
                  )}
                </div>
                
                {/* Target Age */}
                <div className="mb-6">
                  <div className="mb-2">
                    <div className="font-medium text-center py-1 border-b border-gray-200">
                      Target Age
                    </div>
                  </div>
                  <div className="grid grid-cols-3 gap-4">
                    {selectedShows.map(show => (
                      <div key={`age-${show.id}`} className="text-center py-2">
                        {show.ageRange}
                      </div>
                    ))}
                    {selectedShows.length < 3 && (
                      Array(3 - selectedShows.length).fill(0).map((_, i) => (
                        <div key={`empty-age-${i}`} className="text-center py-2 text-gray-400">-</div>
                      ))
                    )}
                  </div>
                </div>
                
                {/* Animation Style */}
                <div className="mb-6">
                  <div className="mb-2">
                    <div className="font-medium text-center py-1 border-b border-gray-200">
                      Animation Style
                    </div>
                  </div>
                  <div className="grid grid-cols-3 gap-4">
                    {selectedShows.map(show => (
                      <div key={`style-${show.id}`} className="text-center py-2">
                        {show.animationStyle || 'Traditional Animation'}
                      </div>
                    ))}
                    {selectedShows.length < 3 && (
                      Array(3 - selectedShows.length).fill(0).map((_, i) => (
                        <div key={`empty-style-${i}`} className="text-center py-2 text-gray-400">-</div>
                      ))
                    )}
                  </div>
                </div>
                
                {/* Themes */}
                <div className="mb-6">
                  <div className="mb-2">
                    <div className="font-medium text-center py-1 border-b border-gray-200">
                      Themes
                    </div>
                  </div>
                  <div className="grid grid-cols-3 gap-4">
                    {selectedShows.map(show => (
                      <div key={`themes-${show.id}`} className="flex flex-wrap justify-center gap-1 py-2">
                        {show.themes && show.themes.map((theme, index) => (
                          <Badge key={index} className="bg-blue-100 text-blue-800 text-xs font-medium">
                            {theme}
                          </Badge>
                        ))}
                      </div>
                    ))}
                    {selectedShows.length < 3 && (
                      Array(3 - selectedShows.length).fill(0).map((_, i) => (
                        <div key={`empty-themes-${i}`} className="text-center py-2 text-gray-400">-</div>
                      ))
                    )}
                  </div>
                </div>
              </div>
              
              {/* Stimulation Score Comparison using dots */}
              <div className="mb-8">
                <h3 className="text-lg font-bold mb-4">Stimulation Score Comparison</h3>
                <div className="mb-2">
                  <div className="font-medium text-center py-1 border-b border-gray-200">
                    Stimulation Score
                  </div>
                </div>
                <div className="grid grid-cols-3 gap-4">
                  {selectedShows.map(show => (
                    <div key={`stim-${show.id}`} className="flex flex-col items-center">
                      <div className="flex flex-col items-center py-2">
                        {getStimulationScoreDots(show.stimulationScore)}
                        <div className="text-center text-sm font-medium">
                          {show.stimulationScore}/5
                        </div>
                      </div>
                    </div>
                  ))}
                  
                  {selectedShows.length < 3 && (
                    Array(3 - selectedShows.length).fill(0).map((_, i) => (
                      <div key={`empty-stim-${i}`} className="flex flex-col">
                        <div className="text-center py-2 text-gray-400">-</div>
                      </div>
                    ))
                  )}
                </div>
              </div>
              
              {/* Sensory Metrics with Bar Charts - Side by side layout */}
              <div className="mb-8">
                <h3 className="text-lg font-bold mb-4">Sensory Metrics Comparison</h3>
                
                {/* Show names at the top of columns */}
                <div className="grid grid-cols-3 gap-4 mb-4">
                  {selectedShows.map(show => (
                    <div key={`name-${show.id}`} className="font-medium text-center text-lg">
                      {show.name}
                    </div>
                  ))}
                  {selectedShows.length < 3 && (
                    Array(3 - selectedShows.length).fill(0).map((_, i) => (
                      <div key={`empty-name-${i}`} className="font-medium text-center text-lg text-gray-400">-</div>
                    ))
                  )}
                </div>
                
                {/* Interactivity Level */}
                <div className="mb-8">
                  <div className="mb-2">
                    <div className="font-medium text-center py-1 border-b border-gray-200">
                      Interaction Level
                    </div>
                  </div>
                  <div className="grid grid-cols-3 gap-4 mb-1">
                    {selectedShows.map(show => (
                      <div key={`interaction-${show.id}`} className="text-center py-1">
                        <span className="text-sm font-medium">{show.interactivityLevel || 'Moderate'}</span>
                      </div>
                    ))}
                    {selectedShows.length < 3 && (
                      Array(3 - selectedShows.length).fill(0).map((_, i) => (
                        <div key={`empty-interaction-${i}`} className="text-center py-1 text-gray-400">-</div>
                      ))
                    )}
                  </div>
                  <div className="grid grid-cols-3 gap-4">
                    {selectedShows.map(show => (
                      <div key={`interaction-bar-${show.id}`}>
                        {renderSegmentedBar(show.interactivityLevel)}
                      </div>
                    ))}
                    {selectedShows.length < 3 && (
                      Array(3 - selectedShows.length).fill(0).map((_, i) => (
                        <div key={`empty-interaction-bar-${i}`} className="h-4"></div>
                      ))
                    )}
                  </div>
                </div>
                
                {/* Dialogue Intensity */}
                <div className="mb-8">
                  <div className="mb-2">
                    <div className="font-medium text-center py-1 border-b border-gray-200">
                      Dialogue Intensity
                    </div>
                  </div>
                  <div className="grid grid-cols-3 gap-4 mb-1">
                    {selectedShows.map(show => (
                      <div key={`dialogue-${show.id}`} className="text-center py-1">
                        <span className="text-sm font-medium">{show.dialogueIntensity || 'Moderate'}</span>
                      </div>
                    ))}
                    {selectedShows.length < 3 && (
                      Array(3 - selectedShows.length).fill(0).map((_, i) => (
                        <div key={`empty-dialogue-${i}`} className="text-center py-1 text-gray-400">-</div>
                      ))
                    )}
                  </div>
                  <div className="grid grid-cols-3 gap-4">
                    {selectedShows.map(show => (
                      <div key={`dialogue-bar-${show.id}`}>
                        {renderSegmentedBar(show.dialogueIntensity)}
                      </div>
                    ))}
                    {selectedShows.length < 3 && (
                      Array(3 - selectedShows.length).fill(0).map((_, i) => (
                        <div key={`empty-dialogue-bar-${i}`} className="h-4"></div>
                      ))
                    )}
                  </div>
                </div>
                
                {/* Sound Effects Level */}
                <div className="mb-8">
                  <div className="mb-2">
                    <div className="font-medium text-center py-1 border-b border-gray-200">
                      Sound Effects Level
                    </div>
                  </div>
                  <div className="grid grid-cols-3 gap-4 mb-1">
                    {selectedShows.map(show => (
                      <div key={`sound-${show.id}`} className="text-center py-1">
                        <span className="text-sm font-medium">{show.soundEffectsLevel || 'Moderate'}</span>
                      </div>
                    ))}
                    {selectedShows.length < 3 && (
                      Array(3 - selectedShows.length).fill(0).map((_, i) => (
                        <div key={`empty-sound-${i}`} className="text-center py-1 text-gray-400">-</div>
                      ))
                    )}
                  </div>
                  <div className="grid grid-cols-3 gap-4">
                    {selectedShows.map(show => (
                      <div key={`sound-bar-${show.id}`}>
                        {renderSegmentedBar(show.soundEffectsLevel)}
                      </div>
                    ))}
                    {selectedShows.length < 3 && (
                      Array(3 - selectedShows.length).fill(0).map((_, i) => (
                        <div key={`empty-sound-bar-${i}`} className="h-4"></div>
                      ))
                    )}
                  </div>
                </div>
                
                {/* Scene Frequency */}
                <div className="mb-8">
                  <div className="mb-2">
                    <div className="font-medium text-center py-1 border-b border-gray-200">
                      Scene Frequency
                    </div>
                  </div>
                  <div className="grid grid-cols-3 gap-4 mb-1">
                    {selectedShows.map(show => (
                      <div key={`scene-${show.id}`} className="text-center py-1">
                        <span className="text-sm font-medium">{show.sceneFrequency || 'Moderate'}</span>
                      </div>
                    ))}
                    {selectedShows.length < 3 && (
                      Array(3 - selectedShows.length).fill(0).map((_, i) => (
                        <div key={`empty-scene-${i}`} className="text-center py-1 text-gray-400">-</div>
                      ))
                    )}
                  </div>
                  <div className="grid grid-cols-3 gap-4">
                    {selectedShows.map(show => (
                      <div key={`scene-bar-${show.id}`}>
                        {renderSegmentedBar(show.sceneFrequency)}
                      </div>
                    ))}
                    {selectedShows.length < 3 && (
                      Array(3 - selectedShows.length).fill(0).map((_, i) => (
                        <div key={`empty-scene-bar-${i}`} className="h-4"></div>
                      ))
                    )}
                  </div>
                </div>
                
                {/* Music Tempo */}
                <div className="mb-8">
                  <div className="mb-2">
                    <div className="font-medium text-center py-1 border-b border-gray-200">
                      Music Tempo
                    </div>
                  </div>
                  <div className="grid grid-cols-3 gap-4 mb-1">
                    {selectedShows.map(show => (
                      <div key={`tempo-${show.id}`} className="text-center py-1">
                        <span className="text-sm font-medium">{show.musicTempo || 'Moderate'}</span>
                      </div>
                    ))}
                    {selectedShows.length < 3 && (
                      Array(3 - selectedShows.length).fill(0).map((_, i) => (
                        <div key={`empty-tempo-${i}`} className="text-center py-1 text-gray-400">-</div>
                      ))
                    )}
                  </div>
                  <div className="grid grid-cols-3 gap-4">
                    {selectedShows.map(show => (
                      <div key={`tempo-bar-${show.id}`}>
                        {renderSegmentedBar(show.musicTempo)}
                      </div>
                    ))}
                    {selectedShows.length < 3 && (
                      Array(3 - selectedShows.length).fill(0).map((_, i) => (
                        <div key={`empty-tempo-bar-${i}`} className="h-4"></div>
                      ))
                    )}
                  </div>
                </div>
                
                {/* Total Music Level */}
                <div className="mb-8">
                  <div className="mb-2">
                    <div className="font-medium text-center py-1 border-b border-gray-200">
                      Total Music Level
                    </div>
                  </div>
                  <div className="grid grid-cols-3 gap-4 mb-1">
                    {selectedShows.map(show => (
                      <div key={`music-${show.id}`} className="text-center py-1">
                        <span className="text-sm font-medium">{show.totalMusicLevel || 'Moderate'}</span>
                      </div>
                    ))}
                    {selectedShows.length < 3 && (
                      Array(3 - selectedShows.length).fill(0).map((_, i) => (
                        <div key={`empty-music-${i}`} className="text-center py-1 text-gray-400">-</div>
                      ))
                    )}
                  </div>
                  <div className="grid grid-cols-3 gap-4">
                    {selectedShows.map(show => (
                      <div key={`music-bar-${show.id}`}>
                        {renderSegmentedBar(show.totalMusicLevel)}
                      </div>
                    ))}
                    {selectedShows.length < 3 && (
                      Array(3 - selectedShows.length).fill(0).map((_, i) => (
                        <div key={`empty-music-bar-${i}`} className="h-4"></div>
                      ))
                    )}
                  </div>
                </div>
              </div>
            </div>
          ) : (
            <div className="p-8 text-center bg-white rounded-xl shadow-md">
              <div className="mb-4 text-gray-400">
                <i className="fas fa-tv text-6xl"></i>
              </div>
              <h3 className="text-lg font-medium mb-2">No Shows Selected</h3>
              <p className="text-gray-500 mb-4">Select shows from the dropdown menus above to compare them.</p>
            </div>
          )}
        </div>
      )}
    </main>
  );
}
</file>

<file path="client/src/pages/privacy-policy.tsx">
export default function PrivacyPolicy() {
  return (
    <div className="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
      <div className="bg-white rounded-xl shadow-md p-8">
        <h1 className="text-3xl font-heading font-bold text-primary-800 mb-6">Privacy Policy</h1>
        <p className="text-gray-600 mb-8">Last updated: {new Date().toLocaleDateString()}</p>

        <div className="space-y-6 text-gray-700">
          <section>
            <h2 className="text-xl font-semibold text-primary-700 mb-3">1. Information We Collect</h2>
            <p className="mb-4">
              We collect information you provide directly to us, such as when you create an account, 
              write reviews, or contact us. This may include your name, email address, and any content 
              you submit to our platform.
            </p>
            <p>
              We also automatically collect certain information about your device and how you interact 
              with our service, including your IP address, browser type, and pages visited.
            </p>
          </section>

          <section>
            <h2 className="text-xl font-semibold text-primary-700 mb-3">2. How We Use Your Information</h2>
            <p className="mb-4">We use the information we collect to:</p>
            <ul className="list-disc pl-6 space-y-2">
              <li>Provide, maintain, and improve our services</li>
              <li>Process transactions and send related information</li>
              <li>Send you technical notices and support messages</li>
              <li>Respond to your comments and questions</li>
              <li>Monitor and analyze trends and usage</li>
            </ul>
          </section>

          <section>
            <h2 className="text-xl font-semibold text-primary-700 mb-3">3. Information Sharing</h2>
            <p>
              We do not sell, trade, or otherwise transfer your personal information to third parties 
              without your consent, except as described in this policy. We may share your information 
              in certain limited circumstances, such as to comply with legal obligations or protect 
              our rights.
            </p>
          </section>

          <section>
            <h2 className="text-xl font-semibold text-primary-700 mb-3">4. Advertising</h2>
            <p className="mb-4">
              We use third-party advertising companies to serve ads when you visit our website. 
              These companies may use information about your visits to this and other websites 
              in order to provide advertisements about goods and services of interest to you.
            </p>
            <p>
              We use Google AdSense to display ads on our site. Google's use of advertising cookies 
              enables it and its partners to serve ads based on your visit to our site and/or other 
              sites on the Internet. You may opt out of personalized advertising by visiting 
              Google's Ads Settings.
            </p>
          </section>

          <section>
            <h2 className="text-xl font-semibold text-primary-700 mb-3">5. Cookies and Tracking</h2>
            <p>
              We use cookies and similar tracking technologies to collect and use personal information 
              about you. You can control cookies through your browser settings, but disabling cookies 
              may affect the functionality of our site.
            </p>
          </section>

          <section>
            <h2 className="text-xl font-semibold text-primary-700 mb-3">6. Data Security</h2>
            <p>
              We implement appropriate security measures to protect your personal information against 
              unauthorized access, alteration, disclosure, or destruction. However, no method of 
              transmission over the Internet is 100% secure.
            </p>
          </section>

          <section>
            <h2 className="text-xl font-semibold text-primary-700 mb-3">7. Children's Privacy</h2>
            <p>
              Our service is not directed to children under 13. We do not knowingly collect personal 
              information from children under 13. If you become aware that a child has provided us 
              with personal information, please contact us.
            </p>
          </section>

          <section>
            <h2 className="text-xl font-semibold text-primary-700 mb-3">8. Your Rights</h2>
            <p className="mb-4">You have the right to:</p>
            <ul className="list-disc pl-6 space-y-2">
              <li>Access, update, or delete your personal information</li>
              <li>Object to processing of your personal information</li>
              <li>Request that we limit the processing of your personal information</li>
              <li>Request portability of your personal information</li>
            </ul>
          </section>

          <section>
            <h2 className="text-xl font-semibold text-primary-700 mb-3">9. Changes to This Policy</h2>
            <p>
              We may update this privacy policy from time to time. We will notify you of any changes 
              by posting the new privacy policy on this page and updating the "Last updated" date.
            </p>
          </section>

          <section>
            <h2 className="text-xl font-semibold text-primary-700 mb-3">10. Contact Us</h2>
            <p>
              If you have any questions about this privacy policy, please contact us at:
            </p>
            <p className="mt-2 font-medium">
              Email: privacy@tvtantrum.com
            </p>
          </section>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="client/src/pages/research.tsx">
import React, { useState } from 'react';
import { useQuery } from '@tanstack/react-query';
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Skeleton } from '@/components/ui/skeleton';
import { useAuth } from '@/hooks/use-auth';
import { Link } from 'wouter';
import { BookOpen, BookText, ArrowRight, Lock } from 'lucide-react';

const Research = () => {
  const { user, isLoading: isLoadingAuth } = useAuth();
  const [activeCategory, setActiveCategory] = useState('all');
  // Using Link component for navigation instead of useLocation

  const { data: summaries, isLoading: isLoadingSummaries } = useQuery({
    queryKey: ['/api/research'],
    enabled: !!user,
    staleTime: 0, // Always fetch fresh data to show read status updates
  });

  // Define categories based on actual database categories
  const categories = [
    { id: 'all', name: 'All Research' },
    { id: 'Child Psychology', name: 'Child Psychology' },
    { id: 'Cognitive Development', name: 'Cognitive Development' },
    { id: 'Learning Outcomes', name: 'Learning Outcomes' },
    { id: 'Media Effects', name: 'Media Effects' },
    { id: 'Parental Guidance', name: 'Parental Guidance' },
    { id: 'Social Development', name: 'Social Development' },
  ];

  if (isLoadingAuth) {
    return (
      <div className="container py-8">
        <div className="space-y-4">
          <Skeleton className="h-12 w-[250px]" />
          <Skeleton className="h-[200px] w-full" />
          <Skeleton className="h-[200px] w-full" />
        </div>
      </div>
    );
  }

  if (!user) {
    return (
      <div className="container py-12">
        <Card className="max-w-md mx-auto text-center">
          <CardHeader>
            <Lock className="w-12 h-12 mx-auto text-gray-400 mb-2" />
            <CardTitle>Exclusive Content</CardTitle>
            <CardDescription>
              Research summaries are available only to registered users.
            </CardDescription>
          </CardHeader>
          <CardFooter className="flex justify-center">
            <Button onClick={() => window.location.href = '/api/login'}>Sign In to Access</Button>
          </CardFooter>
        </Card>
      </div>
    );
  }

  if (isLoadingSummaries) {
    return (
      <div className="container py-8">
        <div className="space-y-4">
          <Skeleton className="h-12 w-[250px]" />
          <div className="flex gap-2 overflow-x-auto py-2">
            {categories.map((_, i) => (
              <Skeleton key={i} className="h-8 w-[120px]" />
            ))}
          </div>
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            {[...Array(6)].map((_, i) => (
              <Skeleton key={i} className="h-[250px] w-full rounded-lg" />
            ))}
          </div>
        </div>
      </div>
    );
  }

  // Group research by category
  const categorizedSummaries = summaries && Array.isArray(summaries) ? summaries.reduce((acc: Record<string, any[]>, summary: any) => {
    const categoryId = summary.category || 'uncategorized';
    if (!acc[categoryId]) {
      acc[categoryId] = [];
    }
    acc[categoryId].push(summary);
    return acc;
  }, {} as Record<string, any[]>) : {};

  // Count items per category
  const categoryCounts: Record<string, number> = {};
  if (summaries && Array.isArray(summaries)) {
    categories.forEach(category => {
      if (category.id === 'all') {
        categoryCounts[category.id] = summaries.length;
      } else {
        categoryCounts[category.id] = categorizedSummaries[category.id]?.length || 0;
      }
    });
  }

  // Get all unique categories from the data
  const dataCategories = new Set(
    summaries && Array.isArray(summaries) 
      ? summaries.map((summary: any) => summary.category || 'uncategorized')
      : []
  );

  // Filter summaries based on active category
  const filteredSummaries = activeCategory === 'all'
    ? (summaries || [])
    : (categorizedSummaries[activeCategory] || []);

  const handleReadMore = (summaryId: number) => {
    // Use window.location instead of navigate for consistent navigation approach
    window.location.href = `/research/${summaryId}`;
  };

  return (
    <div className="container max-w-[1100px] py-8 px-6 md:px-8">
      <div className="flex flex-col md:flex-row justify-between items-start md:items-center gap-4 mb-8">
        <div>
          <h1 className="text-3xl font-bold mb-2">Research Summaries</h1>
          <p className="text-gray-500">
            Discover the latest research on children's media and development
          </p>
        </div>
        <Badge variant="outline" className="bg-blue-50 text-blue-500 border-blue-200">
          <BookOpen className="w-3 h-3 mr-1" /> Earn 5 points for each summary you read
        </Badge>
      </div>

      {/* Mobile: Dropdown selector */}
      <div className="block md:hidden mb-8">
        <Select value={activeCategory} onValueChange={setActiveCategory}>
          <SelectTrigger className="w-full">
            <SelectValue placeholder="Select a category">
              {categories.find(cat => cat.id === activeCategory)?.name}
              {categoryCounts && categoryCounts[activeCategory] > 0 && (
                <span className="ml-2 text-xs bg-gray-200 text-gray-700 px-1.5 py-0.5 rounded-full">
                  {categoryCounts[activeCategory]}
                </span>
              )}
            </SelectValue>
          </SelectTrigger>
          <SelectContent>
            {categories.map((category) => (
              <SelectItem key={category.id} value={category.id}>
                <div className="flex items-center justify-between w-full">
                  <span>{category.name}</span>
                  {categoryCounts && categoryCounts[category.id] > 0 && (
                    <span className="ml-2 text-xs bg-gray-200 text-gray-700 px-1.5 py-0.5 rounded-full">
                      {categoryCounts[category.id]}
                    </span>
                  )}
                </div>
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
      </div>

      {/* Desktop: Tab interface */}
      <Tabs 
        defaultValue="all" 
        value={activeCategory} 
        onValueChange={setActiveCategory} 
        className="hidden md:block mb-14"
      >
        <TabsList className="flex flex-wrap mb-10 px-1 justify-center gap-2">
          {categories.map((category) => (
            <TabsTrigger 
              key={category.id}
              value={category.id}
              className={`flex flex-col items-center py-2 px-3 ${category.id === 'all' ? 'min-w-[100px]' : 'min-w-[150px]'} h-auto`}
            >
              <span className="text-center">
                {category.id === 'all' ? category.name : 
                  category.name.split(' and ').map((part, i) => (
                    <span key={i} className="block">
                      {part}{i < category.name.split(' and ').length - 1 && ' &'}
                    </span>
                  ))
                }
              </span>
              {categoryCounts && categoryCounts[category.id] > 0 && 
                <span className="mt-1 text-xs bg-gray-200 text-gray-700 px-1.5 py-0.5 rounded-full">
                  {categoryCounts[category.id]}
                </span>
              }
            </TabsTrigger>
          ))}
        </TabsList>
      </Tabs>

      {/* Content display for both mobile and desktop */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        {isLoadingSummaries ? (
          // Loading placeholder for research cards
          <>
            {Array.from({ length: 6 }).map((_, index) => (
              <Card key={`skeleton-${index}`} className="h-[280px]">
                <CardHeader className="pb-3">
                  <div className="flex items-center justify-between mb-2">
                    <Skeleton className="h-4 w-20" />
                    <Skeleton className="h-5 w-5 rounded-full" />
                  </div>
                  <Skeleton className="h-6 w-full mb-1" />
                  <Skeleton className="h-6 w-3/4" />
                </CardHeader>
                <CardContent className="pb-3">
                  <Skeleton className="h-4 w-full mb-2" />
                  <Skeleton className="h-4 w-full mb-2" />
                  <Skeleton className="h-4 w-2/3" />
                </CardContent>
                <CardFooter className="pt-0">
                  <Skeleton className="h-9 w-full" />
                </CardFooter>
              </Card>
            ))}
          </>
        ) : activeCategory === 'all' ? (
          summaries && Array.isArray(summaries) ? summaries.map((summary: any) => (
            <ResearchCard key={summary.id} summary={summary} onReadMore={handleReadMore} />
          )) : (
            <div className="col-span-full text-center py-12 text-gray-500">
              <BookText className="w-12 h-12 mx-auto mb-4 opacity-20" />
              <p>No research summaries available</p>
            </div>
          )
        ) : (
          categorizedSummaries[activeCategory] && Array.isArray(categorizedSummaries[activeCategory]) 
            ? categorizedSummaries[activeCategory].map((summary: any) => (
                <ResearchCard key={summary.id} summary={summary} onReadMore={handleReadMore} />
              ))
            : (
              <div className="col-span-full text-center py-12 text-gray-500">
                <BookText className="w-12 h-12 mx-auto mb-4 opacity-20" />
                <p>No research summaries found in this category</p>
              </div>
            )
        )}
      </div>
    </div>
  );
};

interface ResearchCardProps {
  summary: any;
  onReadMore: (id: number) => void;
}

const ResearchCard = ({ summary, onReadMore }: ResearchCardProps) => {
  // Debug: Log the summary data to see if hasRead is being passed
  console.log('ResearchCard summary:', summary.id, summary.title, 'hasRead:', summary.hasRead);
  
  // Format category name for display
  const formatCategoryName = (category: string) => {
    if (!category) return 'General';
    return category.split(' ').map(word => 
      word.charAt(0).toUpperCase() + word.slice(1)
    ).join(' ');
  };
  
  // Format date for display
  const formatDate = (dateString: string) => {
    if (!dateString) return '';
    const date = new Date(dateString);
    return new Intl.DateTimeFormat('en-US', { 
      year: 'numeric', 
      month: 'long', 
      day: 'numeric' 
    }).format(date);
  };

  return (
    <Card className={`h-full flex flex-col ${summary.hasRead ? 'bg-gray-50 border-gray-200' : ''}`}>
      {summary.imageUrl && (
        <div className="relative w-full h-48 overflow-hidden">
          <img 
            src={summary.imageUrl} 
            alt={summary.title}
            className={`w-full h-full object-contain bg-gray-50 transition-transform hover:scale-105 ${summary.hasRead ? 'opacity-75' : ''}`}
          />
          {summary.hasRead && (
            <div className="absolute top-2 right-2">
              <Badge className="bg-green-500 text-white border-green-600 shadow-sm">
                ✓ Read
              </Badge>
            </div>
          )}
        </div>
      )}
      <CardHeader>
        <div className="flex justify-between items-start mb-2">
          <Badge variant="outline" className="mb-2">
            {formatCategoryName(summary.category)}
          </Badge>
          {summary.hasRead && !summary.imageUrl && (
            <Badge className="bg-green-500 text-white border-green-600">
              ✓ Read
            </Badge>
          )}
        </div>
        <CardTitle className="text-xl">{summary.title}</CardTitle>
        {summary.publishedDate && (
          <CardDescription className="mt-1 text-sm text-gray-500">
            {formatDate(summary.publishedDate)}
          </CardDescription>
        )}
      </CardHeader>
      <CardContent className="flex-grow">
        <p className="text-gray-500 line-clamp-3">
          {summary.summary}
        </p>
      </CardContent>
      <CardFooter>
        <Button 
          variant="outline" 
          className="w-full flex items-center justify-between"
          onClick={() => onReadMore(summary.id)}
        >
          <span>Read More</span>
          <ArrowRight className="w-4 h-4 ml-2" />
        </Button>
      </CardFooter>
    </Card>
  );
};

export default Research;
</file>

<file path="client/index.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1980242774753631" crossorigin="anonymous"></script>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
    <!-- This is a replit script which adds a banner on the top of the page when opened in development mode outside the replit environment -->
    <script type="text/javascript" src="https://replit.com/public/js/replit-dev-banner.js"></script>
  </body>
</html>
</file>

<file path="COMPLETE_CODEBASE_MERGED.md">
# TV Tantrum - Complete Codebase Repository

<file_summary>
This file contains a packed representation of the ENTIRE TV Tantrum repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

<purpose>
This file will contain a packed representation of the ENTIRE repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files 
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - FULL contents of the file
</file_format>
</file_summary>

## Repository Information

**Name**: TV Tantrum
**Description**: A gamified web platform that transforms children's media discovery into an intelligent, socially-driven experience
**Technology Stack**: React, TypeScript, Express.js, PostgreSQL, Drizzle ORM
**Architecture**: Full-stack web application with client-side React frontend and Express.js backend

## Directory Structure

```
├── client/                    # Frontend React application
│   ├── src/
│   │   ├── components/        # Reusable UI components
│   │   ├── pages/            # Page components
│   │   ├── hooks/            # Custom React hooks
│   │   └── lib/              # Utility libraries
├── server/                   # Backend Express.js application
├── shared/                   # Shared types and schemas
├── public/                   # Static assets
├── attached_assets/          # Development assets and screenshots
├── data/                     # Data files and migrations
├── migrations/               # Database migration files
└── [utility scripts]        # Various data management scripts
```

## Repository Files

### Configuration Files

#### package.json
```json
{
  "name": "rest-express",
  "version": "1.0.0",
  "type": "module",
  "license": "MIT",
  "scripts": {
    "dev": "NODE_ENV=development tsx server/index.ts",
    "build": "vite build && esbuild server/index.ts --platform=node --packages=external --bundle --format=esm --outdir=dist",
    "start": "NODE_ENV=production node dist/index.js",
    "check": "tsc",
    "db:push": "drizzle-kit push"
  },
  "dependencies": {
    "@anthropic-ai/sdk": "^0.37.0",
    "@hookform/resolvers": "^3.10.0",
    "@jridgewell/trace-mapping": "^0.3.25",
    "@neondatabase/serverless": "^0.10.4",
    "@radix-ui/react-accordion": "^1.2.4",
    "@radix-ui/react-alert-dialog": "^1.1.7",
    "@radix-ui/react-aspect-ratio": "^1.1.3",
    "@radix-ui/react-avatar": "^1.1.4",
    "@radix-ui/react-checkbox": "^1.1.5",
    "@radix-ui/react-collapsible": "^1.1.4",
    "@radix-ui/react-context-menu": "^2.2.7",
    "@radix-ui/react-dialog": "^1.1.7",
    "@radix-ui/react-dropdown-menu": "^2.1.7",
    "@radix-ui/react-hover-card": "^1.1.7",
    "@radix-ui/react-label": "^2.1.3",
    "@radix-ui/react-menubar": "^1.1.7",
    "@radix-ui/react-navigation-menu": "^1.2.6",
    "@radix-ui/react-popover": "^1.1.7",
    "@radix-ui/react-progress": "^1.1.3",
    "@radix-ui/react-radio-group": "^1.2.4",
    "@radix-ui/react-scroll-area": "^1.2.4",
    "@radix-ui/react-select": "^2.1.7",
    "@radix-ui/react-separator": "^1.1.3",
    "@radix-ui/react-slider": "^1.2.4",
    "@radix-ui/react-slot": "^1.2.0",
    "@radix-ui/react-switch": "^1.1.4",
    "@radix-ui/react-tabs": "^1.1.4",
    "@radix-ui/react-toast": "^1.2.7",
    "@radix-ui/react-toggle": "^1.1.3",
    "@radix-ui/react-toggle-group": "^1.1.3",
    "@radix-ui/react-tooltip": "^1.2.0",
    "@sendgrid/mail": "^8.1.5",
    "@tailwindcss/vite": "^4.1.3",
    "@tanstack/react-query": "^5.60.5",
    "@types/bcrypt": "^5.0.2",
    "@types/memoizee": "^0.4.12",
    "@types/multer": "^1.4.12",
    "adm-zip": "^0.5.16",
    "bcrypt": "^6.0.0",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^1.1.1",
    "connect-pg-simple": "^10.0.0",
    "csv-parse": "^5.6.0",
    "date-fns": "^3.6.0",
    "dotenv": "^16.5.0",
    "drizzle-orm": "^0.39.1",
    "drizzle-zod": "^0.7.0",
    "embla-carousel-react": "^8.6.0",
    "express": "^4.21.2",
    "express-session": "^1.18.1",
    "framer-motion": "^11.13.1",
    "html2canvas": "^1.4.1",
    "input-otp": "^1.4.2",
    "lucide-react": "^0.453.0",
    "memoizee": "^0.4.17",
    "memorystore": "^1.6.7",
    "multer": "^1.4.5-lts.2",
    "next-themes": "^0.4.6",
    "node-fetch": "^3.3.2",
    "octokit": "^4.1.3",
    "openid-client": "^6.5.0",
    "passport": "^0.7.0",
    "passport-local": "^1.0.0",
    "pg": "^8.16.0",
    "puppeteer": "^24.9.0",
    "react": "^18.3.1",
    "react-day-picker": "^8.10.1",
    "react-dom": "^18.3.1",
    "react-hook-form": "^7.55.0",
    "react-icons": "^5.4.0",
    "react-resizable-panels": "^2.1.7",
    "recharts": "^2.15.2",
    "sharp": "^0.34.1",
    "tailwind-merge": "^2.6.0",
    "tailwindcss-animate": "^1.0.7",
    "tw-animate-css": "^1.2.5",
    "vaul": "^1.1.2",
    "wouter": "^3.3.5",
    "ws": "^8.18.0",
    "zod": "^3.24.2",
    "zod-validation-error": "^3.4.0"
  },
  "devDependencies": {
    "@replit/vite-plugin-cartographer": "^0.1.2",
    "@replit/vite-plugin-runtime-error-modal": "^0.0.3",
    "@tailwindcss/typography": "^0.5.15",
    "@types/connect-pg-simple": "^7.0.3",
    "@types/express": "4.17.21",
    "@types/express-session": "^1.18.1",
    "@types/node": "20.16.11",
    "@types/passport": "^1.0.17",
    "@types/passport-local": "^1.0.38",
    "@types/react": "^18.3.11",
    "@types/react-dom": "^18.3.1",
    "@types/ws": "^8.5.13",
    "@vitejs/plugin-react": "^4.3.2",
    "autoprefixer": "^10.4.20",
    "drizzle-kit": "^0.30.4",
    "esbuild": "^0.25.0",
    "postcss": "^8.4.47",
    "tailwindcss": "^3.4.17",
    "tsx": "^4.19.1",
    "typescript": "5.6.3",
    "vite": "^5.4.14"
  },
  "optionalDependencies": {
    "bufferutil": "^4.0.8"
  }
}
```

#### tsconfig.json
```json
{
  "include": ["client/src/**/*", "shared/**/*", "server/**/*"],
  "exclude": ["node_modules", "build", "dist", "**/*.test.ts"],
  "compilerOptions": {
    "incremental": true,
    "tsBuildInfoFile": "./node_modules/typescript/tsbuildinfo",
    "noEmit": true,
    "module": "ESNext",
    "strict": true,
    "lib": ["esnext", "dom", "dom.iterable"],
    "jsx": "preserve",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "allowImportingTsExtensions": true,
    "moduleResolution": "bundler",
    "baseUrl": ".",
    "types": ["node", "vite/client"],
    "paths": {
      "@/*": ["./client/src/*"],
      "@shared/*": ["./shared/*"]
    }
  }
}
```

#### vite.config.ts
```typescript
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import path from "path";
import runtimeErrorOverlay from "@replit/vite-plugin-runtime-error-modal";

export default defineConfig({
  plugins: [
    react(),
    runtimeErrorOverlay(),
    ...(process.env.NODE_ENV !== "production" && process.env.REPL_ID !== undefined
      ? [
          await import("@replit/vite-plugin-cartographer").then((m) =>
            m.cartographer(),
          ),
        ]
      : []),
  ],

  resolve: {
    alias: {
      "@": path.resolve(import.meta.dirname, "client", "src"),
      "@shared": path.resolve(import.meta.dirname, "shared"),
      "@assets": path.resolve(import.meta.dirname, "attached_assets"),
    },
    // 👇 ensures only a single copy of React is bundled
    dedupe: ["react", "react-dom"],
  },

  root: path.resolve(import.meta.dirname, "client"),

  build: {
    outDir: path.resolve(import.meta.dirname, "dist/public"),
    emptyOutDir: true,
  },
});
```

#### tailwind.config.ts
```typescript
import type { Config } from "tailwindcss";

export default {
  darkMode: ["class"],
  content: ["./client/index.html", "./client/src/**/*.{js,jsx,ts,tsx}"],
  theme: {
    extend: {
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      colors: {
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        chart: {
          "1": "hsl(var(--chart-1))",
          "2": "hsl(var(--chart-2))",
          "3": "hsl(var(--chart-3))",
          "4": "hsl(var(--chart-4))",
          "5": "hsl(var(--chart-5))",
        },
        sidebar: {
          DEFAULT: "hsl(var(--sidebar-background))",
          foreground: "hsl(var(--sidebar-foreground))",
          primary: "hsl(var(--sidebar-primary))",
          "primary-foreground": "hsl(var(--sidebar-primary-foreground))",
          accent: "hsl(var(--sidebar-accent))",
          "accent-foreground": "hsl(var(--sidebar-accent-foreground))",
          border: "hsl(var(--sidebar-border))",
          ring: "hsl(var(--sidebar-ring))",
        },
      },
      keyframes: {
        "accordion-down": {
          from: {
            height: "0",
          },
          to: {
            height: "var(--radix-accordion-content-height)",
          },
        },
        "accordion-up": {
          from: {
            height: "var(--radix-accordion-content-height)",
          },
          to: {
            height: "0",
          },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
    },
  },
  plugins: [require("tailwindcss-animate"), require("@tailwindcss/typography")],
} satisfies Config;
```

#### drizzle.config.ts
```typescript
import { defineConfig } from "drizzle-kit";

if (!process.env.DATABASE_URL) {
  throw new Error("DATABASE_URL, ensure the database is provisioned");
}

export default defineConfig({
  out: "./migrations",
  schema: "./shared/schema.ts",
  dialect: "postgresql",
  dbCredentials: {
    url: process.env.DATABASE_URL,
  },
});
```
</file>

<file path="test-webhook.js">
// Quick test script to verify webhook endpoint
const fetch = require('node-fetch');

async function testWebhook() {
  try {
    console.log('Testing webhook endpoint...');
    
    const response = await fetch('http://localhost:5000/api/ghl-webhook', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        first_name: 'TestWebhook',
        email: 'testwebhook@example.com'
      })
    });
    
    const result = await response.text();
    console.log('Response status:', response.status);
    console.log('Response body:', result);
    
  } catch (error) {
    console.error('Error testing webhook:', error);
  }
}

testWebhook();
</file>

<file path="TV_TANTRUM_ARCHITECTURE_REPORT.md">
# TV Tantrum Application - Comprehensive Architecture Report

## Executive Summary

TV Tantrum is a gamified web platform that transforms children's media discovery into an intelligent, socially-driven experience. The application provides parents with advanced content recommendations, personalized filtering, and interactive design to support informed media consumption decisions.

## Current Technology Stack

### Frontend
- **Framework**: React 18 with TypeScript
- **Styling**: Tailwind CSS with shadcn/ui components
- **Routing**: Wouter (lightweight React router)
- **State Management**: TanStack React Query v5
- **Build Tool**: Vite
- **UI Components**: Radix UI primitives with custom styling

### Backend
- **Runtime**: Node.js with Express.js
- **Language**: TypeScript
- **Database**: PostgreSQL with Drizzle ORM
- **Authentication**: Express sessions with Passport.js
- **File Processing**: Sharp for image optimization

### Third-Party Integrations
- **Analytics**: Google Analytics 4
- **Monetization**: Google AdSense
- **APIs**: OMDb API, YouTube Data API v3
- **Email**: SendGrid (configured but not actively used)

## Database Schema Analysis

### Core Tables (15 tables total)

#### User Management
1. **users** - Main user accounts with gamification features
2. **sessions** - Express session storage
3. **temp_ghl_users** - Temporary registrations from external forms

#### Content Management
4. **tv_shows** - Core content with stimulation metrics and metadata
5. **themes** - Categorization system for content themes
6. **platforms** - Streaming platform information
7. **tv_show_themes** - Many-to-many relationship for show themes
8. **tv_show_platforms** - Many-to-many relationship for platform availability
9. **youtube_channels** - YouTube-specific metadata

#### User Interaction
10. **favorites** - User favorited shows
11. **tv_show_reviews** - User reviews and ratings
12. **review_upvotes** - Community engagement on reviews

#### Analytics & Tracking
13. **tv_show_searches** - Search analytics
14. **tv_show_views** - View count tracking
15. **user_points_history** - Gamification point tracking

#### Content Requests
16. **show_submissions** - User-requested shows with priority system

#### Research Content
17. **research_summaries** - Educational content for parents
18. **user_read_research** - Reading tracking for research content

#### Referral System
19. **user_referrals** - User referral tracking
20. **referral_clicks** - Click tracking for shared content
21. **short_urls** - URL shortening for professional sharing

## Page-by-Page Feature Analysis

### 1. Token Entry Page (/) - Landing/Access Control
**Purpose**: Primary entry point with token-based access control
**Database Connections**: None (localStorage-based token validation)
**Features**:
- Early access token validation
- Redirect to main application after validation
- Marketing messaging for waitlist users

### 2. Home Page (/home) - Main Dashboard
**Purpose**: Primary content discovery hub
**Database Connections**: 
- tv_shows (featured content)
- tv_show_views (tracking)
- users (personalization)
**Features**:
- Featured show carousel
- Category browsing
- Search functionality
- Personalized recommendations
- Google AdSense integration

### 3. Browse Page (/browse) - Content Exploration
**Purpose**: Advanced content filtering and discovery
**Database Connections**:
- tv_shows (all shows with filters)
- themes (filter options)
- platforms (filter options)
- tv_show_themes, tv_show_platforms (relationships)
**Features**:
- Multi-criteria filtering (age, themes, platforms, stimulation level)
- Infinite scroll pagination
- Sort by popularity, rating, date
- Search with real-time results

### 4. Show Detail Pages (/shows/:id, /detail/:id) - Individual Content
**Purpose**: Comprehensive show information and user interaction
**Database Connections**:
- tv_shows (show details)
- tv_show_reviews (user reviews)
- favorites (user favorites)
- review_upvotes (community engagement)
- tv_show_views (analytics)
- Similar shows algorithm
**Features**:
- Complete show metadata display
- Stimulation level visualization
- User reviews and ratings system
- Favorite/unfavorite functionality
- Similar show recommendations
- Share functionality with referral tracking
- OMDb and YouTube API integration for enhanced metadata

### 5. Compare Page (/compare) - Content Comparison
**Purpose**: Side-by-side show comparison
**Database Connections**:
- tv_shows (multiple shows)
- themes, platforms (comparison metrics)
**Features**:
- Multi-show comparison interface
- Stimulation level comparison charts
- Theme and platform comparison
- Export comparison results

### 6. User Dashboard (/dashboard, /user-dashboard) - Personal Hub
**Purpose**: User's personal activity and progress center
**Database Connections**:
- users (profile data)
- user_points_history (gamification)
- tv_show_reviews (user's reviews)
- favorites (user's favorites)
- research_summaries (recommended reading)
**Features**:
- Points and rank display
- Activity history
- Personal review management
- Favorite shows grid
- Achievement system
- Recommended research articles

### 7. User Profile (/user/:userId) - Public Profile
**Purpose**: Public user profiles for community features
**Database Connections**:
- users (profile information)
- tv_show_reviews (user's public reviews)
- favorites (public favorites if enabled)
- user_points_history (public achievements)
**Features**:
- Public profile display
- User's review history with show names
- Community ranking
- Profile customization (background colors)

### 8. Authentication (/auth, /login) - User Management
**Purpose**: User registration and login
**Database Connections**:
- users (authentication)
- sessions (session management)
- user_points_history (welcome points)
**Features**:
- User registration with approval system
- Login/logout functionality
- Password encryption with bcrypt
- Session management
- Admin approval workflow

### 9. Submit Show (/submit-show) - Content Requests
**Purpose**: User-driven content expansion
**Database Connections**:
- show_submissions (new requests)
- users (request tracking)
- user_points_history (points for submissions)
**Features**:
- Show request form
- Duplicate detection
- Priority scoring system
- Admin approval workflow
- Points reward system

### 10. Research Section (/research, /research/:id) - Educational Content
**Purpose**: Parent education and industry insights
**Database Connections**:
- research_summaries (articles)
- user_read_research (reading tracking)
- user_points_history (reading points)
**Features**:
- Article browsing with categories
- Full-text article reading
- Reading progress tracking
- Points for engagement
- Search functionality

### 11. Admin Panel (/admin) - Content Management
**Purpose**: Administrative control and content management
**Database Connections**:
- All tables (full admin access)
- show_submissions (approval workflow)
- users (user management)
**Features**:
- User approval management
- Content moderation
- Show submission review
- System analytics
- Data management tools

### 12. Share System (/share/:id) - Referral Marketing
**Purpose**: User referral and content sharing
**Database Connections**:
- short_urls (link tracking)
- referral_clicks (click analytics)
- user_referrals (referral relationships)
- user_points_history (referral rewards)
**Features**:
- Professional short URL generation
- Click tracking and analytics
- Referral point system
- Social media optimization

## API Endpoints Analysis (73 total endpoints)

### Content APIs
- GET /api/tv-shows - Main content feed
- GET /api/shows/:id - Individual show details
- GET /api/shows/popular - Trending content
- GET /api/shows/featured - Curated content
- GET /api/shows/:id/similar - Recommendation engine

### User Management APIs
- GET /api/auth/user - Authentication status
- GET /api/user/dashboard - Personal dashboard data
- GET /api/user/profile/:userId - Public profile data
- POST /api/auth/register - User registration
- POST /api/auth/login - User authentication

### Interaction APIs
- POST /api/shows/:id/reviews - Review submission
- POST /api/favorites - Favorite management
- GET /api/recommendations - Personalized suggestions
- POST /api/review-upvote - Community engagement

### Analytics APIs
- POST /api/track-view - View tracking
- POST /api/track-search - Search analytics
- GET /api/analytics/* - Usage statistics

### Admin APIs
- POST /api/admin/* - Administrative functions
- POST /api/update-metadata - Content management
- POST /api/optimize-images - Asset optimization

## Current Performance Optimizations

### Frontend Optimizations
1. **Optimistic UI Updates** - Immediate feedback for user actions
2. **React Query Caching** - Intelligent data caching and invalidation
3. **Infinite Scroll** - Efficient content loading
4. **Image Optimization** - Sharp-based image processing
5. **Code Splitting** - Component-level lazy loading

### Backend Optimizations
1. **Database Indexing** - Optimized queries for performance
2. **Connection Pooling** - Efficient database connections
3. **Batch Operations** - Reduced database round trips
4. **Optimized Join Queries** - Single-query data fetching

### SEO Current State
1. **Basic Meta Tags** - Title and description
2. **Google Analytics** - User behavior tracking
3. **Sitemap Generation** - Basic crawlability
4. **URL Structure** - SEO-friendly routes

## Identified Performance Issues

### Critical Issues
1. **No Server-Side Rendering** - Poor initial page load and SEO
2. **Client-Side Only Routing** - Search engines can't crawl content
3. **No Static Generation** - Missing opportunities for performance
4. **Large Bundle Size** - Monolithic client application
5. **No Image CDN** - Images served from application server
6. **Missing Meta Tags** - Individual pages lack proper SEO

### Database Issues
1. **N+1 Query Problems** - Multiple database calls for related data
2. **Missing Database Indexes** - Slow queries on large datasets
3. **Inefficient Pagination** - Full table scans for large result sets
4. **No Database Connection Pooling Optimization** - Suboptimal connection management

### SEO Issues
1. **No Dynamic Meta Tags** - Pages don't have unique titles/descriptions
2. **No Open Graph Tags** - Poor social media sharing
3. **No Schema Markup** - Missing structured data
4. **No Sitemap** - Search engines can't discover all content
5. **Client-Side Rendering** - Content not available for crawlers

---

# Recommended Rebuild Strategy

## 1. Architecture Migration: Full-Stack Next.js 14

### Why Next.js 14?
- **App Router**: Modern routing with layouts and nested routes
- **Server Components**: Zero JavaScript for static content
- **Static Site Generation**: Pre-built pages for optimal performance
- **Image Optimization**: Built-in next/image with CDN support
- **SEO First**: Server-side rendering out of the box
- **API Routes**: Integrated backend functionality
- **Streaming**: Partial page rendering for faster perceived performance

### Migration Strategy
```
Phase 1: Foundation (Week 1-2)
├── Next.js 14 project setup with App Router
├── Database migration to Prisma ORM
├── Authentication system with NextAuth.js
└── Core UI component library migration

Phase 2: Core Features (Week 3-4)
├── TV show pages with SSG/ISR
├── Browse functionality with server-side filtering
├── User dashboard with streaming
└── Search with server-side implementation

Phase 3: Advanced Features (Week 5-6)
├── Admin panel with real-time updates
├── Research system with MDX support
├── Referral system with analytics
└── Performance optimization

Phase 4: SEO & Performance (Week 7-8)
├── Complete SEO implementation
├── Image optimization pipeline
├── Cache optimization
└── Analytics integration
```

## 2. Database Optimization Strategy

### Prisma Migration Benefits
- **Type Safety**: Auto-generated TypeScript types
- **Query Optimization**: Intelligent query planning
- **Connection Pooling**: Built-in connection management
- **Schema Migration**: Versioned database changes
- **Real-time Subscriptions**: WebSocket support for live updates

### Performance Improvements
```sql
-- Critical Indexes to Add
CREATE INDEX idx_tv_shows_stimulation_score ON tv_shows(stimulation_score);
CREATE INDEX idx_tv_shows_age_range ON tv_shows(age_range);
CREATE INDEX idx_tv_shows_themes_gin ON tv_shows USING gin(themes);
CREATE INDEX idx_reviews_tv_show_id ON tv_show_reviews(tv_show_id);
CREATE INDEX idx_favorites_user_id ON favorites(user_id);
CREATE INDEX idx_user_points_history_user_id ON user_points_history(user_id);
```

### Query Optimization
- **Pagination**: Cursor-based pagination for infinite scroll
- **Aggregations**: Pre-computed statistics for dashboards
- **Full-Text Search**: PostgreSQL full-text search for content
- **Materialized Views**: Pre-computed complex queries

## 3. SEO Optimization Strategy

### Page-Level SEO Implementation
```typescript
// Dynamic meta tags for each page
export async function generateMetadata({ params }: { params: { id: string } }) {
  const show = await getShow(params.id);
  
  return {
    title: `${show.name} - TV Show Review | TV Tantrum`,
    description: `${show.description.slice(0, 150)}...`,
    openGraph: {
      title: `${show.name} - Perfect for ${show.ageRange}`,
      description: show.description,
      images: [show.imageUrl],
      type: 'article',
    },
    twitter: {
      card: 'summary_large_image',
      title: show.name,
      description: show.description,
      images: [show.imageUrl],
    },
  };
}
```

### Structured Data Implementation
```json
{
  "@context": "https://schema.org",
  "@type": "TVSeries",
  "name": "Show Name",
  "description": "Show description",
  "genre": ["Children", "Educational"],
  "contentRating": "TV-Y",
  "aggregateRating": {
    "@type": "AggregateRating",
    "ratingValue": "4.5",
    "ratingCount": "127"
  }
}
```

### Technical SEO Features
- **XML Sitemap**: Auto-generated with all show pages
- **Robots.txt**: Optimized crawling instructions
- **Canonical URLs**: Prevent duplicate content issues
- **Internal Linking**: Strategic cross-linking between related shows
- **Page Speed**: Optimized Core Web Vitals scores

## 4. Performance Architecture

### Frontend Performance
```typescript
// Component-level optimizations
import { Suspense, lazy } from 'react';
import { Image } from 'next/image';

// Lazy loading for heavy components
const AdminPanel = lazy(() => import('./AdminPanel'));
const Charts = lazy(() => import('./Charts'));

// Optimized image loading
<Image
  src={show.imageUrl}
  alt={show.name}
  width={300}
  height={400}
  placeholder="blur"
  blurDataURL="data:image/jpeg;base64,..."
  priority={isAboveFold}
/>
```

### Backend Performance
```typescript
// Efficient data fetching with Prisma
const getShowWithRelations = async (id: string) => {
  return await prisma.tvShow.findUnique({
    where: { id: parseInt(id) },
    include: {
      reviews: {
        include: { user: true },
        orderBy: { createdAt: 'desc' },
        take: 10,
      },
      themes: true,
      platforms: true,
      _count: {
        select: {
          reviews: true,
          favorites: true,
        },
      },
    },
  });
};
```

### Caching Strategy
```typescript
// Multi-level caching
export default async function ShowPage({ params }: { params: { id: string } }) {
  // Static generation for popular shows
  const show = await getShow(params.id);
  
  return (
    <div>
      {/* Static content */}
      <ShowHeader show={show} />
      
      {/* Dynamic content with Suspense */}
      <Suspense fallback={<ReviewsSkeleton />}>
        <Reviews showId={show.id} />
      </Suspense>
    </div>
  );
}

// ISR for dynamic content
export const revalidate = 3600; // Revalidate every hour
```

## 5. Enhanced User Experience

### Real-time Features
```typescript
// WebSocket integration for live updates
import { useSocket } from '@/hooks/useSocket';

export function Reviews({ showId }: { showId: number }) {
  const { data: reviews, mutate } = useSWR(`/api/reviews/${showId}`);
  
  useSocket('review-added', (newReview) => {
    if (newReview.showId === showId) {
      mutate(); // Refresh reviews
    }
  });
  
  return (
    <div>
      {reviews.map(review => <ReviewCard key={review.id} review={review} />)}
    </div>
  );
}
```

### Progressive Web App Features
```typescript
// PWA configuration
const withPWA = require('next-pwa')({
  dest: 'public',
  register: true,
  skipWaiting: true,
});

module.exports = withPWA({
  // Next.js config
});
```

## 6. Analytics & Monitoring Enhancement

### Advanced Analytics
```typescript
// Enhanced tracking with custom events
import { track } from '@/lib/analytics';

export function ShowCard({ show }: { show: TvShow }) {
  const handleClick = () => {
    track('show_clicked', {
      show_id: show.id,
      show_name: show.name,
      age_range: show.ageRange,
      stimulation_score: show.stimulationScore,
      user_id: user?.id,
    });
  };
  
  return <Card onClick={handleClick}>...</Card>;
}
```

### Performance Monitoring
```typescript
// Real User Monitoring
import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';

function sendToAnalytics(metric) {
  // Send to your analytics provider
  gtag('event', metric.name, {
    value: Math.round(metric.name === 'CLS' ? metric.value * 1000 : metric.value),
    event_category: 'Web Vitals',
  });
}

getCLS(sendToAnalytics);
getFID(sendToAnalytics);
getFCP(sendToAnalytics);
getLCP(sendToAnalytics);
getTTFB(sendToAnalytics);
```

## 7. Estimated Performance Improvements

### Page Load Performance
- **Current**: 3-5 seconds initial load
- **After Rebuild**: 0.8-1.2 seconds initial load
- **Improvement**: 70-80% faster loading

### SEO Performance
- **Current**: Limited search engine visibility
- **After Rebuild**: Full search engine indexing
- **Improvement**: 10x increase in organic traffic potential

### User Experience
- **Current**: Client-side only, loading states
- **After Rebuild**: Instant page loads, progressive enhancement
- **Improvement**: Significantly improved user satisfaction

### Development Velocity
- **Current**: Manual optimizations, complex state management
- **After Rebuild**: Built-in optimizations, simplified development
- **Improvement**: 50% faster feature development

## 8. Migration Timeline & Approach

### Phase 1: Foundation Setup (2 weeks)
1. **New Next.js 14 Project**: App router, TypeScript, Tailwind
2. **Database Migration**: Prisma schema, data migration scripts
3. **Authentication**: NextAuth.js with existing user data
4. **Core Components**: UI library migration to Next.js compatible

### Phase 2: Core Feature Migration (2 weeks)
1. **Show Pages**: Static generation for all TV shows
2. **Browse System**: Server-side filtering and search
3. **User System**: Dashboard, profiles, authentication flows
4. **API Migration**: REST endpoints to Next.js API routes

### Phase 3: Advanced Features (2 weeks)
1. **Admin Panel**: Real-time updates, content management
2. **Research System**: MDX content, reading tracking
3. **Gamification**: Points system, achievements
4. **Referral System**: Analytics, URL shortening

### Phase 4: Optimization & Launch (2 weeks)
1. **SEO Implementation**: Meta tags, sitemaps, structured data
2. **Performance Optimization**: Image optimization, caching
3. **Analytics Integration**: Enhanced tracking, monitoring
4. **Testing & Deployment**: Comprehensive testing, gradual rollout

## Conclusion

The rebuild strategy focuses on modern web standards, performance optimization, and SEO excellence while maintaining all existing functionality. The migration to Next.js 14 with proper database optimization and SEO implementation will result in significantly improved user experience, search engine visibility, and development efficiency.

The estimated total development time is 8 weeks with a team of 2-3 developers, resulting in a production-ready application that matches current functionality while providing substantial improvements in performance, SEO, and maintainability.
</file>

<file path="client/src/components/CookieConsent.tsx">
import { useState, useEffect } from "react";
import { Button } from "@/components/ui/button";
import { X } from "lucide-react";

export default function CookieConsent() {
  const [showBanner, setShowBanner] = useState(false);

  useEffect(() => {
    // Check if user has already made a choice
    const consentGiven = localStorage.getItem('cookie-consent');
    if (!consentGiven) {
      setShowBanner(true);
    }
  }, []);

  const handleAccept = () => {
    localStorage.setItem('cookie-consent', 'accepted');
    setShowBanner(false);
    
    // Enable Google Analytics/AdSense tracking here
    if (typeof window !== 'undefined' && window.gtag) {
      window.gtag('consent', 'update', {
        'analytics_storage': 'granted',
        'ad_storage': 'granted'
      });
    }
  };

  const handleDecline = () => {
    localStorage.setItem('cookie-consent', 'declined');
    setShowBanner(false);
    
    // Disable tracking
    if (typeof window !== 'undefined' && window.gtag) {
      window.gtag('consent', 'update', {
        'analytics_storage': 'denied',
        'ad_storage': 'denied'
      });
    }
  };

  if (!showBanner) return null;

  return (
    <div className="fixed bottom-0 left-0 right-0 bg-white border-t border-gray-200 shadow-lg z-50 p-4">
      <div className="max-w-7xl mx-auto flex flex-col sm:flex-row items-start sm:items-center justify-between gap-4">
        <div className="flex-1">
          <div className="mb-2">
            <h3 className="text-sm font-semibold text-gray-900 mb-1">Help us improve your experience</h3>
            <p className="text-sm text-gray-700">
              We use cookies to show you more relevant content and keep our free service running. 
              Accepting helps us understand what parents find most useful so we can improve our recommendations.{" "}
              <a 
                href="/privacy-policy" 
                className="text-primary hover:underline font-medium"
              >
                Privacy details
              </a>
            </p>
          </div>
          <div className="text-xs text-gray-600">
            ✓ Better show recommendations • ✓ Free service stays free • ✓ Data stays anonymous
          </div>
        </div>
        
        <div className="flex gap-3 flex-shrink-0">
          <Button 
            variant="outline" 
            size="sm" 
            onClick={handleDecline}
            className="text-gray-600 border-gray-300 hover:bg-gray-50"
          >
            Decline
          </Button>
          <Button 
            size="sm" 
            onClick={handleAccept}
            className="bg-primary hover:bg-primary/90"
          >
            Accept All
          </Button>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="client/src/components/Footer.tsx">
import { Link } from "wouter";
import { useAuth } from "@/hooks/use-auth";

export default function Footer() {
  const { user, isApproved } = useAuth();
  
  // Use the standard about page URL for all users
  const aboutPageUrl = "/about";
  
  return (
    <footer className="bg-primary text-white py-8 mt-12">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div className="md:flex md:justify-between">
          <div className="mb-8 md:mb-0">
            <h2 className="text-xl font-heading font-bold mb-4">TV Tantrum</h2>
            <p className="text-white/80 max-w-md">
              Helping parents make informed decisions about the children's TV shows their kids watch. 
              Compare, review, and discover new content.
            </p>
          </div>
          
          <div className="grid grid-cols-2 md:grid-cols-3 gap-8">
            <div>
              <h3 className="text-sm font-semibold text-white/90 uppercase tracking-wider mb-4">Explore</h3>
              <ul className="space-y-2">
                <li><Link href="/" className="text-white/80 hover:text-white">Home</Link></li>
                <li><Link href="/browse" className="text-white/80 hover:text-white">Browse Shows</Link></li>
                <li><Link href="/compare" className="text-white/80 hover:text-white">Compare Shows</Link></li>
                <li><Link href="/browse?sortBy=popular" className="text-white/80 hover:text-white">Popular Shows</Link></li>
              </ul>
            </div>
            
            <div>
              <h3 className="text-sm font-semibold text-white/90 uppercase tracking-wider mb-4">Resources</h3>
              <ul className="space-y-2">
                <li><Link href={aboutPageUrl} className="text-white/80 hover:text-white">About Us</Link></li>
              </ul>
            </div>

            <div>
              <h3 className="text-sm font-semibold text-white/90 uppercase tracking-wider mb-4">Legal</h3>
              <ul className="space-y-2">
                <li><Link href="/privacy-policy" className="text-white/80 hover:text-white">Privacy Policy</Link></li>
                <li><Link href="/terms-of-service" className="text-white/80 hover:text-white">Terms of Service</Link></li>
              </ul>
            </div>
            
            <div>
              <h3 className="text-sm font-semibold text-white/90 uppercase tracking-wider mb-4">Connect</h3>
              <ul className="space-y-2">
                <li><Link href={aboutPageUrl} className="text-white/80 hover:text-white">Contact Us</Link></li>
              </ul>
            </div>
          </div>
        </div>
        
        <div className="mt-8 pt-8 border-t border-white/20 md:flex md:items-center md:justify-between">
          <div className="flex space-x-6 md:order-2">
            <a 
              href="#" 
              className="text-white/70 hover:text-white"
            >
              <i className="fas fa-envelope"></i>
            </a>
          </div>
          <p className="mt-8 md:mt-0 md:order-1 text-white/70">
            &copy; {new Date().getFullYear()} TV Tantrum. All rights reserved.
          </p>
        </div>
      </div>
    </footer>
  );
}
</file>

<file path="client/src/pages/browse.tsx">
import { useState, useEffect, useRef } from "react";
import { useQuery } from "@tanstack/react-query";
import { useLocation, useSearch } from "wouter";
import ShowFilters from "@/components/ShowFilters";
import ShowCard from "@/components/ShowCard";
import SimpleShowCard from "@/components/SimpleShowCard";
import AdContainer from "@/components/AdContainer";
import { Button } from "@/components/ui/button";
import { Skeleton } from "@/components/ui/skeleton";
import {
  Pagination,
  PaginationContent,
  PaginationEllipsis,
  PaginationItem,
  PaginationLink,
  PaginationNext,
  PaginationPrevious
} from "@/components/ui/pagination";
import { TvShow } from "@shared/schema";

export default function Browse() {
  const [_, setLocation] = useLocation();
  const search = useSearch();
  const [isMobile, setIsMobile] = useState(false);
  const resultsRef = useRef<HTMLDivElement>(null); // Ref for the results section
  const [activeFilters, setActiveFilters] = useState<{
    ageGroup?: string;
    ageRange?: {min: number, max: number};
    tantrumFactor?: string;
    sortBy?: string;
    search?: string;
    themes?: string[];
    themeMatchMode?: 'AND' | 'OR';
    interactionLevel?: string;
    dialogueIntensity?: string;
    soundFrequency?: string;
    stimulationScoreRange?: {min: number, max: number};
  }>({});
  const [viewMode, setViewMode] = useState<"grid" | "list">("grid");
  const [currentPage, setCurrentPage] = useState(1);
  const showsPerPage = 12;

  // Parse URL search params to set initial filters
  useEffect(() => {
    const searchParams = new URLSearchParams(search);
    const initialFilters: typeof activeFilters = {};
    
    // Get search query from URL
    const searchQuery = searchParams.get('search');
    if (searchQuery) {
      initialFilters.search = searchQuery;
    }
    
    // Get age group from URL (legacy support)
    const ageGroup = searchParams.get('ageGroup');
    if (ageGroup) {
      initialFilters.ageGroup = ageGroup;
    }
    
    // Get age range from URL - handle both JSON format and individual min/max params
    try {
      // First try to read individual min/max parameters
      const minAge = searchParams.get('ageRange.min') || searchParams.get('ageRangeMin');
      const maxAge = searchParams.get('ageRange.max') || searchParams.get('ageRangeMax');
      
      if (minAge && maxAge) {
        initialFilters.ageRange = {
          min: parseInt(minAge, 10),
          max: parseInt(maxAge, 10)
        };
        console.log('Parsed age range from individual params:', initialFilters.ageRange);
      } else {
        // Fall back to JSON format
        const ageRange = searchParams.get('ageRange');
        if (ageRange) {
          const parsedRange = JSON.parse(decodeURIComponent(ageRange));
          if (parsedRange && typeof parsedRange === 'object' && 'min' in parsedRange && 'max' in parsedRange) {
            initialFilters.ageRange = parsedRange;
            console.log('Parsed age range from JSON:', parsedRange);
          }
        }
      }
    } catch (e) {
      console.error('Error parsing age range:', e);
    }
    
    // Get themes from URL
    const themes = searchParams.get('themes');
    if (themes) {
      initialFilters.themes = themes.split(',');
    }
    
    // Get theme match mode from URL (AND or OR)
    const themeMatchMode = searchParams.get('themeMatchMode');
    if (themeMatchMode && (themeMatchMode === 'AND' || themeMatchMode === 'OR')) {
      initialFilters.themeMatchMode = themeMatchMode;
    }
    
    // Get sort option from URL
    const sortBy = searchParams.get('sortBy');
    if (sortBy) {
      initialFilters.sortBy = sortBy;
    }
    
    // Get tantrumFactor from URL
    const tantrumFactor = searchParams.get('tantrumFactor');
    if (tantrumFactor) {
      initialFilters.tantrumFactor = tantrumFactor;
    }
    
    // Get interactivity level from URL
    const interactionLevel = searchParams.get('interactionLevel');
    if (interactionLevel) {
      initialFilters.interactionLevel = interactionLevel;
    }
    
    // Also check for interactivityLevel (for consistency)
    const interactivityLevel = searchParams.get('interactivityLevel');
    if (interactivityLevel) {
      initialFilters.interactionLevel = interactivityLevel;
    }
    
    // Get dialogue intensity from URL
    const dialogueIntensity = searchParams.get('dialogueIntensity');
    if (dialogueIntensity) {
      initialFilters.dialogueIntensity = dialogueIntensity;
    }
    
    // Get sound frequency from URL
    const soundFrequency = searchParams.get('soundFrequency');
    if (soundFrequency) {
      initialFilters.soundFrequency = soundFrequency;
    }
    
    // Get stimulation score range from URL
    const stimulationScoreRange = searchParams.get('stimulationScoreRange');
    if (stimulationScoreRange) {
      try {
        const parsedRange = JSON.parse(decodeURIComponent(stimulationScoreRange));
        if (parsedRange && typeof parsedRange === 'object' && 'min' in parsedRange && 'max' in parsedRange) {
          initialFilters.stimulationScoreRange = parsedRange;
          console.log('Parsed stimulation score range:', parsedRange);
        }
      } catch (e) {
        console.error('Error parsing stimulation score range:', e);
      }
    }
    
    // Apply filters from URL immediately if any exist
    if (Object.keys(initialFilters).length > 0) {
      console.log('BROWSE PAGE: Auto-applying filters from URL:', initialFilters);
      setActiveFilters(initialFilters);
    } else {
      // If no URL filters, ensure we still trigger a fetch for default view
      setActiveFilters({});
    }
    // Mark filters as initialized so fetch can proceed
    setFiltersInitialized(true);
  }, [search]);

  // Use direct fetch instead of React Query to avoid timestamp issues
  const [shows, setShows] = useState<TvShow[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);
  const [filtersInitialized, setFiltersInitialized] = useState(false);
  
  // Direct fetch implementation for maximum reliability
  useEffect(() => {
    // Don't fetch until URL filters have been parsed
    if (!filtersInitialized) return;
    async function fetchShows() {
      setIsLoading(true);
      setError(null);
      try {
        console.log('BROWSE PAGE: Fetching TV shows with filters:', activeFilters);
        
        // Build query string for API request
        const params = new URLSearchParams();
        
        // Add simple string filters
        if (activeFilters.search) params.append('search', activeFilters.search);
        if (activeFilters.ageGroup) params.append('ageGroup', activeFilters.ageGroup);
        if (activeFilters.tantrumFactor) params.append('tantrumFactor', activeFilters.tantrumFactor);
        if (activeFilters.sortBy) params.append('sortBy', activeFilters.sortBy);
        if (activeFilters.interactionLevel) params.append('interactionLevel', activeFilters.interactionLevel);
        if (activeFilters.dialogueIntensity) params.append('dialogueIntensity', activeFilters.dialogueIntensity);
        if (activeFilters.soundFrequency) params.append('soundFrequency', activeFilters.soundFrequency);
        
        // Add arrays as comma-separated strings
        if (activeFilters.themes && activeFilters.themes.length > 0) {
          params.append('themes', activeFilters.themes.join(','));
        }
        
        // Add match mode for themes
        if (activeFilters.themeMatchMode) {
          params.append('themeMatchMode', activeFilters.themeMatchMode);
        }
        
        // Add stimulation score range as JSON string
        if (activeFilters.stimulationScoreRange) {
          params.append('stimulationScoreRange', JSON.stringify(activeFilters.stimulationScoreRange));
        }
        
        // Add age range as JSON string
        if (activeFilters.ageRange) {
          params.append('ageRange', JSON.stringify(activeFilters.ageRange));
        }
        
        // Use fetch directly
        const response = await fetch(`/api/tv-shows?${params.toString()}`);
        
        if (!response.ok) {
          throw new Error(`API error ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        console.log('BROWSE PAGE: Received', data.length, 'shows');
        console.log('BROWSE PAGE: First show data:', data[0]);
        setShows(data);
      } catch (err) {
        console.error('BROWSE PAGE: Error fetching shows:', err);
        setError(err instanceof Error ? err : new Error('Failed to fetch shows'));
      } finally {
        setIsLoading(false);
      }
    }
    
    fetchShows();
  }, [activeFilters, filtersInitialized]);
  
  // Handler for navigating to show details
  const handleShowClick = (id: number) => {
    // Scroll to top first, then navigate
    window.scrollTo(0, 0);
    setLocation(`/shows/${id}`);
  };
  
  // Log the results separately
  useEffect(() => {
    if (shows) {
      console.log('Query success! Number of shows received:', shows.length);
      if (shows.length > 0) {
        console.log('First few shows:', shows.slice(0, 3).map(show => show.name));
      }
    }
    
    if (error) {
      console.error('Query error:', error);
    }
  }, [shows, error]);
  
  // Effect to detect mobile screen size
  useEffect(() => {
    const checkMobile = () => {
      const isMobileView = window.innerWidth < 640; // sm breakpoint in Tailwind
      console.log('Window width:', window.innerWidth, 'isMobile:', isMobileView);
      setIsMobile(isMobileView);
    };
    
    // Check initially
    checkMobile();
    
    // Add resize listener
    window.addEventListener('resize', checkMobile);
    
    // Clean up
    return () => window.removeEventListener('resize', checkMobile);
  }, []);

  const handleFilterChange = (filters: typeof activeFilters) => {
    setActiveFilters(filters);
    setCurrentPage(1); // Reset to first page when filters change
    
    // Update URL with new filters
    const searchParams = new URLSearchParams();
    if (filters.search) searchParams.set('search', filters.search);
    
    // Handle age filters - use individual parameters for better compatibility
    if (filters.ageRange) {
      searchParams.set('ageRangeMin', filters.ageRange.min.toString());
      searchParams.set('ageRangeMax', filters.ageRange.max.toString());
    } else if (filters.ageGroup) {
      // Legacy support for ageGroup parameter
      searchParams.set('ageGroup', filters.ageGroup);
    }
    
    if (filters.themes && filters.themes.length > 0) {
      searchParams.set('themes', filters.themes.join(','));
      // Also pass the theme match mode (AND/OR) if provided
      if (filters.themeMatchMode) searchParams.set('themeMatchMode', filters.themeMatchMode);
    }
    if (filters.sortBy) searchParams.set('sortBy', filters.sortBy);
    if (filters.tantrumFactor) searchParams.set('tantrumFactor', filters.tantrumFactor);
    if (filters.interactionLevel) searchParams.set('interactionLevel', filters.interactionLevel);
    if (filters.dialogueIntensity) searchParams.set('dialogueIntensity', filters.dialogueIntensity);
    if (filters.soundFrequency) searchParams.set('soundFrequency', filters.soundFrequency);
    if (filters.stimulationScoreRange) searchParams.set('stimulationScoreRange', 
        encodeURIComponent(JSON.stringify(filters.stimulationScoreRange)));
    
    const newSearch = searchParams.toString() ? `?${searchParams.toString()}` : '';
    setLocation(`/browse${newSearch}`);
  };

  const clearFilters = () => {
    setActiveFilters({});
    setCurrentPage(1);
    setLocation('/browse');
  };

  // Calculate pagination
  const indexOfLastShow = currentPage * showsPerPage;
  const indexOfFirstShow = indexOfLastShow - showsPerPage;
  const currentShows = shows ? shows.slice(indexOfFirstShow, indexOfLastShow) : [];
  const totalPages = shows ? Math.ceil(shows.length / showsPerPage) : 0;
  const totalShows = shows?.length || 0;

  // Debug current shows data
  console.log('BROWSE PAGE: Current shows for display:', currentShows.length);

  const handlePageChange = (page: number) => {
    setCurrentPage(page);
    
    // Scroll to the results section instead of the top of the page
    if (resultsRef.current) {
      // Adding a small offset to position just above the results
      const yOffset = -20; 
      const y = resultsRef.current.getBoundingClientRect().top + window.pageYOffset + yOffset;
      
      window.scrollTo({
        top: y,
        behavior: 'smooth'
      });
    }
  };

  // Generate pagination items
  const renderPaginationItems = () => {
    const items = [];
    
    // Always show first page
    items.push(
      <PaginationItem key="page-1">
        <PaginationLink 
          onClick={() => handlePageChange(1)} 
          isActive={currentPage === 1}
        >
          1
        </PaginationLink>
      </PaginationItem>
    );
    
    // Add ellipsis if needed
    if (currentPage > 3) {
      items.push(
        <PaginationItem key="ellipsis-1">
          <PaginationEllipsis />
        </PaginationItem>
      );
    }
    
    // Add pages around current page
    for (let i = Math.max(2, currentPage - 1); i <= Math.min(currentPage + 1, totalPages - 1); i++) {
      items.push(
        <PaginationItem key={`page-${i}`}>
          <PaginationLink 
            onClick={() => handlePageChange(i)} 
            isActive={currentPage === i}
          >
            {i}
          </PaginationLink>
        </PaginationItem>
      );
    }
    
    // Add ellipsis if needed
    if (currentPage < totalPages - 2) {
      items.push(
        <PaginationItem key="ellipsis-2">
          <PaginationEllipsis />
        </PaginationItem>
      );
    }
    
    // Always show last page if there are multiple pages
    if (totalPages > 1) {
      items.push(
        <PaginationItem key={`page-${totalPages}`}>
          <PaginationLink 
            onClick={() => handlePageChange(totalPages)} 
            isActive={currentPage === totalPages}
          >
            {totalPages}
          </PaginationLink>
        </PaginationItem>
      );
    }
    
    return items;
  };

  return (
    <div className="bg-gray-50 min-h-screen">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        {/* Page Header */}
        <h1 className="text-2xl font-heading font-bold text-primary-800 mb-4">
          Browse Shows
        </h1>
        {/* Results count - only show on desktop */}
        <p className="text-gray-600 mb-6 hidden md:block">
          Showing {indexOfFirstShow + 1}-{Math.min(indexOfLastShow, totalShows)} of {totalShows} results
        </p>

        {/* Top Browse Ad */}
        <div className="mb-6">
          <AdContainer size="leaderboard" className="mx-auto" />
        </div>
        
        <div className="flex flex-col md:flex-row gap-6">
          {/* Left Column - Filters */}
          <div className="md:w-1/4">
            <ShowFilters 
              activeFilters={activeFilters} 
              onFilterChange={handleFilterChange}
              onClearFilters={clearFilters}
            />
          </div>
          
          {/* Mobile Results Count - shown below filters on mobile */}
          <div className="md:hidden">
            <p className="text-gray-600 text-sm mb-4">
              Showing {indexOfFirstShow + 1}-{Math.min(indexOfLastShow, totalShows)} of {totalShows} results
            </p>
          </div>
          
          {/* Right Column - Show Grid */}
          <div className="md:w-3/4">
            {isLoading ? (
              // Loading skeleton grid
              <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6">
                {[...Array(6)].map((_, index) => (
                  <div key={index} className="bg-white rounded-xl shadow-md overflow-hidden">
                    <Skeleton className="h-48 w-full" />
                    <div className="p-4">
                      <Skeleton className="h-6 w-3/4 mb-4" />
                      <Skeleton className="h-4 w-full mb-2" />
                      <Skeleton className="h-4 w-full mb-2" />
                      <Skeleton className="h-4 w-full mb-2" />
                    </div>
                  </div>
                ))}
              </div>
            ) : error ? (
              <div className="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded">
                <p>Error loading TV shows. Please try again later.</p>
              </div>
            ) : shows?.length === 0 ? (
              <div className="bg-yellow-50 border border-yellow-200 text-yellow-700 px-4 py-3 rounded">
                <p>No TV shows found matching your filters. Try adjusting your criteria.</p>
                {Object.keys(activeFilters).length > 0 && (
                  <Button variant="outline" size="sm" onClick={clearFilters} className="mt-2">
                    Clear All Filters
                  </Button>
                )}
              </div>
            ) : (
              <div ref={resultsRef}>
                {/* Show Cards Grid - Mobile uses portrait, desktop uses landscape */}
                {isMobile ? (
                  <div className="grid grid-cols-3 gap-3">
                    {/* Mobile grid layout with portrait cards */}
                    {currentShows.map(show => (
                      <ShowCard 
                        key={show.id} 
                        show={show} 
                        viewMode="grid"
                        isMobile={true}
                        onClick={() => handleShowClick(show.id)}
                      />
                    ))}
                  </div>
                ) : (
                  <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6">
                    {currentShows.map((show, index) => (
                      <ShowCard 
                        key={show.id} 
                        show={show} 
                        viewMode="grid"
                        onClick={() => handleShowClick(show.id)}
                      />
                    ))}
                  </div>
                )}
                
                {/* Pagination */}
                {totalPages > 1 && (
                  <div className="mt-8 flex justify-center">
                    <Pagination>
                      <PaginationContent>
                        <PaginationItem>
                          <PaginationPrevious 
                            onClick={() => currentPage > 1 && handlePageChange(currentPage - 1)}
                            className={currentPage === 1 ? "pointer-events-none opacity-50" : "cursor-pointer"}
                          />
                        </PaginationItem>
                        
                        {renderPaginationItems()}
                        
                        <PaginationItem>
                          <PaginationNext 
                            onClick={() => currentPage < totalPages && handlePageChange(currentPage + 1)}
                            className={currentPage === totalPages ? "pointer-events-none opacity-50" : "cursor-pointer"}
                          />
                        </PaginationItem>
                      </PaginationContent>
                    </Pagination>
                  </div>
                )}
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="client/src/pages/terms-of-service.tsx">
export default function TermsOfService() {
  return (
    <div className="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
      <div className="bg-white rounded-xl shadow-md p-8">
        <h1 className="text-3xl font-heading font-bold text-primary-800 mb-6">Terms of Service</h1>
        <p className="text-gray-600 mb-8">Last updated: {new Date().toLocaleDateString()}</p>

        <div className="space-y-6 text-gray-700">
          <section>
            <h2 className="text-xl font-semibold text-primary-700 mb-3">1. Acceptance of Terms</h2>
            <p>
              By accessing and using TV Tantrum, you accept and agree to be bound by the terms 
              and provision of this agreement. If you do not agree to abide by the above, 
              please do not use this service.
            </p>
          </section>

          <section>
            <h2 className="text-xl font-semibold text-primary-700 mb-3">2. Description of Service</h2>
            <p className="mb-4">
              TV Tantrum is a platform that provides information about children's television shows 
              and content, including reviews, ratings, and sensory information to help parents 
              make informed decisions about appropriate content for their children.
            </p>
            <p>
              Our service includes user-generated content such as reviews and ratings, which 
              reflect the opinions of individual users and not necessarily those of TV Tantrum.
            </p>
          </section>

          <section>
            <h2 className="text-xl font-semibold text-primary-700 mb-3">3. User Accounts</h2>
            <p className="mb-4">
              To access certain features of our service, you may be required to create an account. 
              You agree to:
            </p>
            <ul className="list-disc pl-6 space-y-2">
              <li>Provide accurate and complete information when creating your account</li>
              <li>Maintain the security of your password and account</li>
              <li>Notify us immediately of any unauthorized use of your account</li>
              <li>Accept responsibility for all activities that occur under your account</li>
            </ul>
          </section>

          <section>
            <h2 className="text-xl font-semibold text-primary-700 mb-3">4. User Content and Conduct</h2>
            <p className="mb-4">
              When using our service, you agree not to:
            </p>
            <ul className="list-disc pl-6 space-y-2">
              <li>Post content that is illegal, harmful, threatening, or offensive</li>
              <li>Violate any applicable laws or regulations</li>
              <li>Infringe on the intellectual property rights of others</li>
              <li>Attempt to gain unauthorized access to our systems</li>
              <li>Interfere with or disrupt our service</li>
              <li>Post spam or unsolicited promotional material</li>
            </ul>
            <p className="mt-4">
              You retain ownership of content you submit, but grant us a license to use, 
              display, and distribute your content in connection with our service.
            </p>
          </section>

          <section>
            <h2 className="text-xl font-semibold text-primary-700 mb-3">5. Content Accuracy</h2>
            <p>
              While we strive to provide accurate information about television shows and content, 
              we make no warranties about the completeness, reliability, or accuracy of this information. 
              Users should use their own judgment when making decisions about appropriate content for their children.
            </p>
          </section>

          <section>
            <h2 className="text-xl font-semibold text-primary-700 mb-3">6. Third-Party Content and Links</h2>
            <p>
              Our service may contain links to third-party websites or services. We are not 
              responsible for the content, privacy policies, or practices of these third-party sites. 
              We also display third-party advertisements, which are not endorsements of the 
              products or services advertised.
            </p>
          </section>

          <section>
            <h2 className="text-xl font-semibold text-primary-700 mb-3">7. Intellectual Property</h2>
            <p>
              The TV Tantrum platform, including its design, functionality, and original content, 
              is protected by copyright and other intellectual property laws. You may not reproduce, 
              distribute, or create derivative works without our explicit permission.
            </p>
          </section>

          <section>
            <h2 className="text-xl font-semibold text-primary-700 mb-3">8. Privacy</h2>
            <p>
              Your privacy is important to us. Our Privacy Policy explains how we collect, 
              use, and protect your information when you use our service. By using our service, 
              you agree to our Privacy Policy.
            </p>
          </section>

          <section>
            <h2 className="text-xl font-semibold text-primary-700 mb-3">9. Disclaimer of Warranties</h2>
            <p>
              Our service is provided "as is" without warranties of any kind, either express or implied. 
              We do not warrant that the service will be uninterrupted, secure, or error-free.
            </p>
          </section>

          <section>
            <h2 className="text-xl font-semibold text-primary-700 mb-3">10. Limitation of Liability</h2>
            <p>
              In no event shall TV Tantrum be liable for any indirect, incidental, special, 
              or consequential damages arising out of or in connection with your use of our service.
            </p>
          </section>

          <section>
            <h2 className="text-xl font-semibold text-primary-700 mb-3">11. Termination</h2>
            <p>
              We reserve the right to terminate or suspend your account and access to our service 
              at our sole discretion, without notice, for conduct that we believe violates these 
              terms or is harmful to other users or our service.
            </p>
          </section>

          <section>
            <h2 className="text-xl font-semibold text-primary-700 mb-3">12. Changes to Terms</h2>
            <p>
              We reserve the right to modify these terms at any time. We will notify users of 
              significant changes by posting a notice on our website. Your continued use of 
              our service after such modifications constitutes acceptance of the updated terms.
            </p>
          </section>

          <section>
            <h2 className="text-xl font-semibold text-primary-700 mb-3">13. Governing Law</h2>
            <p>
              These terms shall be governed by and construed in accordance with applicable laws, 
              without regard to conflict of law principles.
            </p>
          </section>

          <section>
            <h2 className="text-xl font-semibold text-primary-700 mb-3">14. Contact Information</h2>
            <p>
              If you have any questions about these Terms of Service, please contact us at:
            </p>
            <p className="mt-2 font-medium">
              Email: hello@tvtantrum.com
            </p>
          </section>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="server/auth.ts">
import passport from "passport";
import { Strategy as LocalStrategy } from "passport-local";
import { Express } from "express";
import session from "express-session";
import { scrypt, randomBytes, timingSafeEqual } from "crypto";
import { promisify } from "util";
import { storage, DatabaseStorage } from "./database-storage";
import { users } from "@shared/schema";
import connectPg from "connect-pg-simple";
import { pool } from "./db";
import { db } from "./db";
import { trackReferral } from "./referral-system";
import bcrypt from "bcrypt";

// Database session store
const PostgresSessionStore = connectPg(session);
export const sessionStore = new PostgresSessionStore({ 
  pool, 
  createTableIfMissing: true 
});

// No need to import User here as types are explicitly defined
declare global {
  namespace Express {
    // Define what fields from the User schema should be available in req.user
    interface User {
      id: number;
      email: string;
      username: string | null;
      isAdmin: boolean | null;
      createdAt: string;
      isApproved: boolean | null;
    }
  }
}

const scryptAsync = promisify(scrypt);

async function hashPassword(password: string) {
  const salt = randomBytes(16).toString("hex");
  const buf = (await scryptAsync(password, salt, 64)) as Buffer;
  return `${buf.toString("hex")}.${salt}`;
}

export async function comparePasswords(supplied: string, stored: string) {
  console.log('comparePasswords called with supplied password and stored hash');
  
  try {
    // Check if it's a bcrypt hash (starts with $2b$)
    if (stored.startsWith('$2b$')) {
      console.log('Using bcrypt comparison');
      const result = await bcrypt.compare(supplied, stored);
      console.log('Password comparison result:', result);
      return result;
    }
    
    // Legacy scrypt format
    console.log('Using legacy scrypt comparison');
    const [hashed, salt] = stored.split(".");
    
    if (!salt) {
      console.error('Invalid password format, no salt found in:', stored);
      return false;
    }
    
    console.log('Password hash parts:', { 
      hashedLength: hashed ? hashed.length : 0,
      saltLength: salt ? salt.length : 0
    });
    
    const hashedBuf = Buffer.from(hashed, "hex");
    const suppliedBuf = (await scryptAsync(supplied, salt, 64)) as Buffer;
    
    const result = timingSafeEqual(hashedBuf, suppliedBuf);
    console.log('Password comparison result:', result);
    
    return result;
  } catch (error) {
    console.error('Error comparing passwords:', error);
    return false;
  }
}

export function setupAuth(app: Express) {
  if (!process.env.SESSION_SECRET) {
    // Use a default session secret for development
    process.env.SESSION_SECRET = 'tv-tantrum-development-secret';
    console.warn('Warning: SESSION_SECRET environment variable not set, using insecure default');
  }

  const sessionSettings: session.SessionOptions = {
    secret: process.env.SESSION_SECRET,
    resave: false,
    saveUninitialized: false,
    store: sessionStore, // Use PostgreSQL store for both dev and production
    cookie: {
      secure: false, // Allow cookies to work without strict HTTPS requirements for Replit deployment
      maxAge: 30 * 24 * 60 * 60 * 1000, // 30 days
      httpOnly: true,
      sameSite: 'lax', // Add sameSite for better compatibility
      // Don't set domain to allow cookies to work on any domain (Replit deployment)
      domain: undefined
    }
  };

  app.use(session(sessionSettings));
  app.use(passport.initialize());
  app.use(passport.session());

  passport.use(
    new LocalStrategy(
      { 
        usernameField: 'identifier', // This will accept either email or username
        passwordField: 'password'
      },
      async (identifier, password, done) => {
        try {
          // Check if the identifier is an email (contains @) or a username
          const isEmail = identifier.includes('@');
          console.log('Login attempt with identifier:', { identifier, isEmail });
          
          // Try to find the user by email or username
          let user;
          if (isEmail) {
            user = await storage.getUserByEmail(identifier);
          } else {
            user = await storage.getUserByUsername(identifier);
          }
          
          console.log('User found:', user ? { id: user.id, email: user.email, exists: true } : 'No user found');
          
          // Handle authentication failure
          if (!user) {
            return done(null, false, { message: "Invalid credentials" });
          }
          
          const passwordValid = await comparePasswords(password, user.password);
          console.log('Password validation:', { passwordValid });
          
          if (!passwordValid) {
            return done(null, false, { message: "Invalid credentials" });
          } 
          // Check if user account is approved
          else if (!user.isAdmin && !user.isApproved) {
            return done(null, false, { message: "Your account is pending approval" });
          } 
          // Authentication success
          else {
            // Don't send back password with the user object
            const { password: _, ...safeUser } = user;
            return done(null, safeUser as Express.User);
          }
        } catch (error) {
          return done(error);
        }
      }
    ),
  );

  passport.serializeUser((user, done) => {
    done(null, user.id);
  });

  passport.deserializeUser(async (id: number, done) => {
    try {
      const user = await storage.getUser(id);
      if (!user) {
        return done(null, false);
      }
      // Don't include password in the user object
      const { password: _, ...safeUser } = user;
      done(null, safeUser as Express.User);
    } catch (error) {
      console.error('Error during user deserialization:', error);
      done(error);
    }
  });

  app.post("/api/register", async (req, res, next) => {
    try {
      const { username, password, email, country, referrerId } = req.body;
      
      console.log('Registration attempt:', { email, username, country, referrerId });
      
      if (!email || !password) {
        return res.status(400).send({ message: "Email and password are required" });
      }
      
      // Username is required by database schema
      if (!username) {
        return res.status(400).send({ message: "Username is required" });
      }

      // Check for duplicate email
      const existingUserByEmail = await storage.getUserByEmail(email);
      if (existingUserByEmail) {
        return res.status(400).send({ message: "Email already registered" });
      }

      // Check for duplicate username
      const existingUserByUsername = await storage.getUserByUsername(username);
      if (existingUserByUsername) {
        return res.status(400).send({ message: "Username already taken" });
      }

      try {
        // Use direct database insertion with transaction
        const client = await pool.connect();
        let user;
        
        try {
          await client.query('BEGIN');
          
          const hashedPassword = await hashPassword(password);
          const now = new Date().toISOString();
          
          // Direct SQL insert with transaction
          const result = await client.query(`
            INSERT INTO users (email, password, username, is_admin, country, created_at, is_approved) 
            VALUES ($1, $2, $3, $4, $5, $6, $7) 
            RETURNING *
          `, [
            email,
            hashedPassword,
            username,
            false, // isAdmin
            country || '',
            now,
            false // isApproved
          ]);
          
          await client.query('COMMIT');
          
          // Map result to user object
          user = {
            id: result.rows[0].id,
            email: result.rows[0].email,
            password: result.rows[0].password,
            username: result.rows[0].username,
            isAdmin: result.rows[0].is_admin,
            country: result.rows[0].country,
            createdAt: result.rows[0].created_at,
            isApproved: result.rows[0].is_approved
          };
          
          console.log('User successfully inserted into database:', { id: user.id });
        } catch (dbErr) {
          await client.query('ROLLBACK');
          throw dbErr;
        } finally {
          client.release();
        }

        // Don't send back password with the user object
        const { password: _, ...safeUser } = user;

        console.log('User registered successfully:', { id: user.id, email: user.email, username: user.username });

        // Handle referral tracking if referrerId was provided
        if (referrerId) {
          console.log('Processing referral for new user:', { referrerId, newUserId: user.id });
          try {
            await trackReferral(referrerId, user.id.toString());
            console.log('Referral tracking completed successfully');
          } catch (referralError) {
            console.error('Error tracking referral:', referralError);
            // Don't fail registration if referral tracking fails
          }
        }

        req.login(safeUser as Express.User, (err) => {
          if (err) {
            console.error('Error during login after registration:', err);
            return next(err);
          }
          
          // Force session save to ensure it persists
          req.session.save((saveErr) => {
            if (saveErr) {
              console.error('Error saving session after registration:', saveErr);
              return next(saveErr);
            }
            console.log('Session saved successfully for new user:', { userId: safeUser.id, sessionId: req.sessionID });
            res.status(201).json(safeUser);
          });
        });
      } catch (dbError) {
        console.error('Database error during user creation:', dbError);
        return res.status(500).send({ message: "Error creating user account. Please try again." });
      }
    } catch (error) {
      console.error('Unexpected error during registration:', error);
      next(error);
    }
  });

  app.post("/api/login", (req, res, next) => {
    passport.authenticate("local", async (err: Error | null, user: Express.User | false, info: { message: string } | undefined) => {
      console.log('Login attempt:', { err, user: !!user, info });
      
      if (err) return next(err);
      if (!user) {
        // Pass along the specific error message from the authentication strategy
        console.log('Login failed:', info);
        
        // Check if the message is about pending approval
        if (info?.message && info.message.includes("pending approval")) {
          return res.status(403).json({ 
            message: info.message,
            isPendingApproval: true
          });
        }
        
        return res.status(401).json({ 
          message: info?.message || "Invalid username, email, or password",
          isPendingApproval: false
        });
      }
      
      req.login(user, async (err) => {
        if (err) return next(err);
        
        // Force session save to ensure it persists
        req.session.save((saveErr) => {
          if (saveErr) {
            console.error('Error saving session after login:', saveErr);
            return next(saveErr);
          }
          console.log('Session saved successfully after login:', { userId: user.id, sessionId: req.sessionID });
          
          // Award login points after session is saved
          awardLoginPoints(user.id).catch((pointsError) => {
            console.error('Error awarding login points:', pointsError);
          });
          
          res.status(200).json(user);
        });
      });
    })(req, res, next);
  });
  
  // Helper function to award login points (once per day)
  async function awardLoginPoints(userId: number) {
    try {
      console.log(`Checking login rewards for user ID: ${userId}`);
      
      // Import the database pool for direct access
      const { pool } = await import('./db');
      
      // DIRECT DATABASE ACCESS: For more reliable login rewards
      const checkResult = await pool.query(
        `SELECT last_login FROM users WHERE id = $1`,
        [userId]
      );
      
      if (checkResult.rows.length === 0) {
        console.log(`User not found for ID: ${userId}, can't award login points`);
        return;
      }
      
      const now = new Date();
      let shouldAwardPoints = true;
      
      if (checkResult.rows[0].last_login) {
        const lastLogin = new Date(checkResult.rows[0].last_login);
        
        // Check if last login was on a different day
        const lastLoginDay = lastLogin.toDateString();
        const todayDay = now.toDateString();
        
        console.log(`Last login: ${lastLoginDay}, Today: ${todayDay}`);
        
        if (lastLoginDay === todayDay) {
          console.log(`User ${userId} already logged in today, no additional points`);
          shouldAwardPoints = false;
        }
      }
      
      // Update last login date
      await pool.query(
        `UPDATE users SET last_login = $1 WHERE id = $2`,
        [now, userId]
      );
      
      // Award points if eligible using direct SQL for maximum reliability
      if (shouldAwardPoints) {
        console.log(`Directly awarding 5 login points to user ${userId}`);
        
        // 1. Add to points history
        await pool.query(
          `INSERT INTO user_points_history(user_id, points, activity_type, description, created_at)
           VALUES($1, $2, $3, $4, $5)`,
          [userId, 5, 'login_reward', 'Daily login reward', now]
        );
        
        // 2. Update user total points in a single operation
        const updateResult = await pool.query(
          `UPDATE users SET 
            total_points = COALESCE(total_points, 0) + 5
           WHERE id = $1
           RETURNING total_points`,
          [userId]
        );
        
        // 3. Update user rank based on new total
        if (updateResult.rows.length > 0) {
          const newTotal = parseInt(updateResult.rows[0].total_points || '0');
          console.log(`User ${userId} now has ${newTotal} total points`);
          
          // Calculate new rank based on total points
          let newRank = 'TV Watcher';
          if (newTotal >= 10000) newRank = 'TV Guru';
          else if (newTotal >= 5000) newRank = 'TV Expert';
          else if (newTotal >= 1000) newRank = 'TV Enthusiast';
          else if (newTotal >= 500) newRank = 'TV Fan';
          else if (newTotal >= 100) newRank = 'TV Viewer';
          
          // Update rank
          await pool.query(
            `UPDATE users SET rank = $1 WHERE id = $2`,
            [newRank, userId]
          );
          
          console.log(`Successfully awarded 5 points to user ${userId} for daily login. New rank: ${newRank}`);
        }
      }
    } catch (error) {
      console.error('Error in login points processing:', error);
      console.error(error);
    }
  }

  app.post("/api/logout", (req, res, next) => {
    req.logout((err) => {
      if (err) return next(err);
      res.sendStatus(200);
    });
  });

  app.get("/api/user", (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Not authenticated" });
    }
    res.json(req.user);
  });
  
  // Check if a username is available
  app.get("/api/check-username", async (req, res) => {
    try {
      const { username } = req.query;
      
      if (!username || typeof username !== 'string') {
        return res.status(400).json({ 
          message: "Username parameter is required", 
          available: false 
        });
      }
      
      const existingUser = await storage.getUserByUsername(username);
      
      res.json({ 
        available: !existingUser,
        message: existingUser ? "Username is already taken" : "Username is available"
      });
    } catch (error) {
      console.error("Error checking username availability:", error);
      res.status(500).json({ 
        message: "Failed to check username availability", 
        available: false 
      });
    }
  });
  
  // Check if an email is available
  app.get("/api/check-email", async (req, res) => {
    try {
      const { email } = req.query;
      
      if (!email || typeof email !== 'string') {
        return res.status(400).json({ 
          message: "Email parameter is required", 
          available: false 
        });
      }
      
      const existingUser = await storage.getUserByEmail(email);
      
      res.json({ 
        available: !existingUser,
        message: existingUser ? "Email is already registered" : "Email is available"
      });
    } catch (error) {
      console.error("Error checking email availability:", error);
      res.status(500).json({ 
        message: "Failed to check email availability", 
        available: false 
      });
    }
  });
  
  // User management endpoints (admin only)
  app.get("/api/users", async (req, res) => {
    // Enhanced logging to debug authentication issues
    console.log('User requesting /api/users:', {
      isAuthenticated: req.isAuthenticated(),
      user: req.isAuthenticated() ? { 
        id: req.user?.id, 
        isAdmin: req.user?.isAdmin, 
        username: req.user?.username 
      } : 'Not authenticated'
    });
    
    // Special handling to ensure we can verify admin status even if session is questionable
    // First, try the standard session check
    if (!req.isAuthenticated()) {
      console.log('User not authenticated via session for /api/users endpoint');
      
      // Check if auth was provided in the query for debugging
      const debug = req.query.debug === 'true';
      if (debug) {
        console.log('Debug mode enabled for user management, bypassing auth check');
        // In debug mode, proceed anyway but log a warning
        console.warn('WARNING: Debug mode enabled for user management - not for production use');
      } else {
        return res.status(401).json({ message: "Not authenticated" });
      }
    }
    
    // Verify admin privileges
    if (req.isAuthenticated() && !req.user?.isAdmin) {
      console.log('User authenticated but not admin');
      return res.status(403).json({ message: "Unauthorized - Admin privileges required" });
    }
    
    try {
      console.log('Fetching all users from database');
      const users = await storage.getAllUsers();
      console.log(`Successfully fetched ${users.length} users from database`);
      
      // Remove passwords before sending the response
      const safeUsers = users.map(user => {
        const { password, ...safeUser } = user;
        return safeUser;
      });
      
      // Return user data with 200 status
      res.status(200).json(safeUsers);
    } catch (error) {
      console.error('Error fetching users:', error);
      res.status(500).json({ message: "Error fetching users" });
    }
  });
  
  app.patch("/api/users/:userId/approve", async (req, res) => {
    // Enhanced logging to debug authentication issues
    console.log('User attempting to approve/reject another user:', {
      isAuthenticated: req.isAuthenticated(),
      user: req.isAuthenticated() ? { 
        id: req.user?.id, 
        isAdmin: req.user?.isAdmin, 
        username: req.user?.username 
      } : 'Not authenticated'
    });
    
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Not authenticated" });
    }
    
    if (!req.user?.isAdmin) {
      return res.status(403).json({ message: "Unauthorized - Admin privileges required" });
    }
    
    const userId = parseInt(req.params.userId, 10);
    const { isApproved } = req.body;
    
    if (typeof isApproved !== 'boolean') {
      return res.status(400).json({ message: "Invalid approval status" });
    }
    
    try {
      console.log(`Admin user ${req.user.id} is ${isApproved ? 'approving' : 'rejecting'} user ${userId}`);
      const updatedUser = await storage.updateUserApproval(userId, isApproved);
      
      if (!updatedUser) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Remove password before sending the response
      const { password, ...safeUser } = updatedUser;
      
      console.log(`User ${userId} approval status updated successfully to ${isApproved}`);
      res.json(safeUser);
    } catch (error) {
      console.error('Error updating user approval status:', error);
      res.status(500).json({ message: "Error updating user approval status" });
    }
  });
}
</file>

<file path="client/src/components/AdContainer.tsx">
import React from 'react';
import GoogleAd from './GoogleAd';

interface AdContainerProps {
  size: 'banner' | 'rectangle' | 'leaderboard' | 'mobile-banner';
  className?: string;
  label?: string;
}

const AdContainer: React.FC<AdContainerProps> = ({ size, className = '', label = 'Advertisement' }) => {
  // AdSense ad slot IDs - using auto ads format for now
  const adSlots = {
    banner: 'auto', // Auto ads - AdSense will optimize placement
    rectangle: 'auto', // Auto ads - AdSense will optimize placement  
    leaderboard: 'auto', // Auto ads - AdSense will optimize placement
    'mobile-banner': 'auto' // Auto ads - AdSense will optimize placement
  };

  const adDimensions = {
    banner: { width: 728, height: 90 },
    rectangle: { width: 300, height: 250 },
    leaderboard: { width: 728, height: 90 },
    'mobile-banner': { width: 320, height: 50 }
  };

  // Check if AdSense is configured
  const adsenseId = import.meta.env.VITE_GOOGLE_ADSENSE_ID;
  
  if (!adsenseId) {
    // Fallback to placeholder when AdSense not configured
    const sizeClasses = {
      banner: 'w-full h-24 md:h-32',
      rectangle: 'w-full max-w-sm h-64',
      leaderboard: 'w-full h-24',
      'mobile-banner': 'w-full h-16'
    };

    return (
      <div className={`${sizeClasses[size]} ${className} bg-gray-50 border border-gray-200 rounded-lg flex items-center justify-center`}>
        <div className="text-center">
          <div className="text-xs text-gray-400 uppercase tracking-wide">{label}</div>
          <div className="text-xs text-gray-300 mt-1">Ad Space Ready</div>
        </div>
      </div>
    );
  }

  return (
    <div className={className}>
      <GoogleAd
        slot={adSlots[size]}
        width={adDimensions[size].width}
        height={adDimensions[size].height}
        format="auto"
        responsive={true}
      />
    </div>
  );
};

export default AdContainer;
</file>

<file path="client/src/components/ShareModal.tsx">
import { useState, useRef, useEffect } from "react";
import { 
  Dialog, 
  DialogContent, 
  DialogHeader, 
  DialogTitle,
  DialogFooter,
  DialogClose
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Badge } from "@/components/ui/badge";
import { 
  Copy, 
  Share2, 
  Check, 
  Facebook, 
  Twitter, 
  Mail, 
  Linkedin, 
  Instagram, 
  Camera,
  Download,
  Image
} from "lucide-react";
import { useToast } from "@/hooks/use-toast";
import { useAuth } from "@/hooks/use-auth";
import html2canvas from "html2canvas";

interface ShareModalProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  show: {
    id: number;
    name: string;
    imageUrl?: string;
    stimulationScore: number;
  };
}

export default function ShareModal({ open, onOpenChange, show }: ShareModalProps) {
  const [copied, setCopied] = useState(false);
  const [imageDownloading, setImageDownloading] = useState(false);
  const [shortUrl, setShortUrl] = useState<string>('');
  const [shortCode, setShortCode] = useState<string>('');
  const shareCardRef = useRef<HTMLDivElement>(null);
  const { toast } = useToast();
  
  // Generate the share URL with referral parameter if user is logged in
  const { user } = useAuth();
  const shareUrl = user && user.id
    ? `${window.location.origin}/share/${show.id}?ref=${user.id}` 
    : `${window.location.origin}/share/${show.id}`;

  // Create short URL when modal opens
  useEffect(() => {
    if (open && show.id) {
      createShortUrl();
    }
  }, [open, show.id, user]);

  const createShortUrl = async () => {
    try {
      const response = await fetch('/api/short-url', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
          showId: show.id,
          originalUrl: shareUrl
        }),
      });

      if (response.ok) {
        const data = await response.json();
        setShortUrl(data.shortUrl);
        setShortCode(data.shortCode);
      } else {
        // Fallback to regular URL if short URL creation fails
        setShortUrl(shareUrl);
      }
    } catch (error) {
      console.error('Error creating short URL:', error);
      setShortUrl(shareUrl);
    }
  };
    
  // Use short URL for display, fallback to regular URL
  const displayUrl = shortUrl || shareUrl;
  const shortShareUrl = shortCode ? `tvtantrum.app/s/${shortCode}` : `tvtantrum.app/share/${show.id}`;
  
  // Social media share URLs - use short URL for better sharing
  const urlForSharing = displayUrl || shareUrl;
  const facebookShareUrl = `https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(urlForSharing)}`;
  const twitterShareUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(`Check out ${show.name} on TV Tantrum! Stimulation Score: ${show.stimulationScore}/5`)}&url=${encodeURIComponent(urlForSharing)}`;
  const linkedinShareUrl = `https://www.linkedin.com/sharing/share-offsite/?url=${encodeURIComponent(urlForSharing)}`;
  const emailShareUrl = `mailto:?subject=${encodeURIComponent(`Check out ${show.name} on TV Tantrum`)}&body=${encodeURIComponent(`I thought you might be interested in this show: ${show.name} on TV Tantrum. It has a stimulation score of ${show.stimulationScore}/5.\n\nCheck it out here: ${urlForSharing}`)}`;
  const whatsappShareUrl = `https://api.whatsapp.com/send?text=${encodeURIComponent(`Check out ${show.name} on TV Tantrum! Stimulation score: ${show.stimulationScore}/5. ${urlForSharing}`)}`;
  
  // Additional social platform share URLs
  const instagramShareText = `Check out ${show.name} on TV Tantrum! Stimulation score: ${show.stimulationScore}/5.\n\n${urlForSharing}`;
  const snapchatShareUrl = `https://www.snapchat.com/scan?attachmentUrl=${encodeURIComponent(shareUrl)}`;
  const tiktokShareText = `#TVTantrum #KidsShows #${show.name.replace(/\s+/g, '')} ${shareUrl}`;
  
  // Handle copy to clipboard
  const handleCopy = async () => {
    try {
      await navigator.clipboard.writeText(displayUrl);
      setCopied(true);
      
      toast({
        title: "Link copied!",
        description: "Share link has been copied to clipboard",
      });
      
      // Reset copied state after 2 seconds
      setTimeout(() => setCopied(false), 2000);
    } catch (err) {
      console.error("Failed to copy:", err);
      toast({
        title: "Copy failed",
        description: "Could not copy to clipboard. Please try again.",
        variant: "destructive",
      });
    }
  };
  
  // Open social media share in new window
  const openShareWindow = (url: string) => {
    window.open(url, '_blank', 'width=600,height=600');
    
    toast({
      title: "Opening share window",
      description: "Share window opened in a new tab",
    });
  };
  
  // Create and download share card image in different formats
  const handleDownloadImage = async (format: 'square' | 'portrait') => {
    if (!shareCardRef.current) return;
    
    try {
      setImageDownloading(true);
      
      const canvas = await html2canvas(shareCardRef.current, {
        scale: 2, // Higher resolution
        useCORS: true, // Allow cross-origin images
        backgroundColor: "#ffffff", // White background
        logging: false
      });
      
      // Create a new canvas with the desired dimensions
      const newCanvas = document.createElement('canvas');
      const ctx = newCanvas.getContext('2d');
      
      if (format === 'square') {
        // Square format: 1080x1080 (Instagram posts)
        newCanvas.width = 1080;
        newCanvas.height = 1080;
      } else {
        // Portrait format: 1080x1920 (Instagram stories/reels)
        newCanvas.width = 1080;
        newCanvas.height = 1920;
      }
      
      if (ctx) {
        // Fill with white background
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, newCanvas.width, newCanvas.height);
        
        // Calculate scaling and positioning to center the content
        const sourceWidth = canvas.width;
        const sourceHeight = canvas.height;
        const targetWidth = newCanvas.width;
        const targetHeight = newCanvas.height;
        
        // Calculate scale to fit while maintaining aspect ratio
        const scale = Math.min(targetWidth / sourceWidth, targetHeight / sourceHeight) * 0.9; // 0.9 for padding
        const scaledWidth = sourceWidth * scale;
        const scaledHeight = sourceHeight * scale;
        
        // Center the image
        const x = (targetWidth - scaledWidth) / 2;
        const y = (targetHeight - scaledHeight) / 2;
        
        // Draw the original image centered and scaled
        ctx.drawImage(canvas, x, y, scaledWidth, scaledHeight);
      }
      
      // Convert the new canvas to a data URL
      const imageData = newCanvas.toDataURL("image/png");
      
      // Create a link element to download the image
      const link = document.createElement("a");
      link.href = imageData;
      const formatSuffix = format === 'square' ? '_Square_Post' : '_Portrait_Story';
      link.download = `${show.name.replace(/\s+/g, '_')}_TVTantrum${formatSuffix}.png`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      
      const formatName = format === 'square' ? 'square (posts)' : 'portrait (stories/reels)';
      toast({
        title: "Image downloaded!",
        description: `${formatName} format ready for social media. Remember to include your referral link!`,
      });
    } catch (err) {
      console.error("Image download failed:", err);
      toast({
        title: "Download failed",
        description: "Could not create image. Please try again.",
        variant: "destructive",
      });
    } finally {
      setImageDownloading(false);
    }
  };
  
  // Handle native device sharing
  const handleNativeShare = async () => {
    if (navigator.share) {
      try {
        await navigator.share({
          title: `Check out ${show.name} on TV Tantrum`,
          text: `Learn about ${show.name} and its stimulation level (${show.stimulationScore}/5) for kids on TV Tantrum!`,
          url: shareUrl,
        });
        
        toast({
          title: "Shared successfully!",
          description: "Thanks for sharing TV Tantrum",
        });
      } catch (err) {
        console.error("Share failed:", err);
      }
    } else {
      // Fallback for browsers that don't support the Web Share API
      handleCopy();
    }
  };
  
  // Get stimulation level text
  const getStimulationLevelText = (score: number) => {
    switch (score) {
      case 1: return "Gentle pacing with minimal scene changes. Soft sounds and music. Calm dialogue and predictable content. Ideal for very young children, bedtime viewing, or children sensitive to stimulation.";
      case 2: return "Moderate pacing with occasional transitions. Mild sound effects and harmonious music. Engaging but not overwhelming content. Good for longer viewing sessions and younger children.";
      case 3: return "Balanced pacing with regular scene changes. Moderate sound effects and varied music. Mix of calm and exciting moments. Suitable for most children but monitor younger viewers for signs of overstimulation.";
      case 4: return "Fast-paced with frequent scene changes. Prominent sound effects and dynamic music. Energetic dialogue and action. Better for older children and shorter viewing sessions. May feel intense to younger viewers.";
      case 5: return "Rapid pacing with constant scene changes. Loud sound effects and intense music. Highly energetic content with many elements competing for attention. Use with caution.";
      default: return "This show's stimulation level helps you understand its intensity in terms of visual pace, audio, and overall sensory input.";
    }
  };
  
  // Get stimulation level color
  const getStimulationLevelColor = (score: number) => {
    switch (score) {
      case 1: return "bg-green-100 text-green-800";
      case 2: return "bg-lime-100 text-lime-800";
      case 3: return "bg-yellow-100 text-yellow-800";
      case 4: return "bg-orange-100 text-orange-800";
      case 5: return "bg-red-100 text-red-800";
      default: return "bg-blue-100 text-blue-800";
    }
  };
  
  // Get stimulation level name
  const getStimulationLevelName = (score: number) => {
    switch (score) {
      case 1: return "Low";
      case 2: return "Low-Medium";
      case 3: return "Medium";
      case 4: return "Medium-High";
      case 5: return "High";
      default: return "Medium";
    }
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-md max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle>Share "{show.name}"</DialogTitle>
        </DialogHeader>
        
        {/* Shareable image card - This will be captured for sharing */}
        <div 
          ref={shareCardRef} 
          className="border rounded-lg p-5 bg-white mb-4 mt-2"
        >
          <div className="flex flex-col items-center space-y-4">
            <h3 className="text-2xl font-semibold text-center">{show.name}</h3>
            
            {show.imageUrl ? (
              <div>
                <img 
                  src={show.imageUrl} 
                  alt={show.name} 
                  className="w-64 object-contain rounded-md" 
                />
              </div>
            ) : (
              <div className="w-64 h-64 bg-gray-200 flex items-center justify-center rounded-md">
                <i className="fas fa-tv text-gray-400 text-4xl"></i>
              </div>
            )}
            
            <div className="mt-2 w-full flex flex-col items-center">
              <Badge className={`${getStimulationLevelColor(show.stimulationScore)} px-2 py-0.5 text-sm mx-auto inline-flex items-center justify-center rounded-full`}>
                {getStimulationLevelName(show.stimulationScore)} Stimulation
              </Badge>
              
              <div className="h-2 w-full max-w-56 bg-gray-200 rounded-full overflow-hidden flex mt-3">
                {[1, 2, 3, 4, 5].map((segment) => {
                  const color = 
                    segment === 1 ? 'bg-green-500' : 
                    segment === 2 ? 'bg-lime-500' : 
                    segment === 3 ? 'bg-yellow-500' : 
                    segment === 4 ? 'bg-orange-500' : 
                    'bg-red-500';
                  
                  return (
                    <div
                      key={segment}
                      className={`h-full w-1/5 ${segment <= show.stimulationScore ? color : 'bg-gray-200'}`}
                    />
                  );
                })}
              </div>
            </div>
            
            <div className="w-full mt-2 mb-2">
              <p className="text-sm text-gray-600 text-center leading-relaxed mx-auto">
                {getStimulationLevelText(show.stimulationScore)}
              </p>
            </div>
            
            <div className="text-xs text-gray-500 font-medium mt-1">
              tvtantrum.com
            </div>
          </div>
        </div>
        
        {/* Download shareable image buttons */}
        <div className="space-y-2 mb-4">
          <div className="flex gap-2">
            <Button 
              variant="outline" 
              className="flex-1"
              onClick={() => handleDownloadImage('square')}
              disabled={imageDownloading}
            >
              {imageDownloading ? (
                <span className="flex items-center">
                  <svg className="animate-spin -ml-1 mr-2 h-4 w-4 text-primary" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                  </svg>
                  Creating...
                </span>
              ) : (
                <>
                  <Download className="mr-2 h-4 w-4" />
                  Square (Posts)
                </>
              )}
            </Button>
            
            <Button 
              variant="outline" 
              className="flex-1"
              onClick={() => handleDownloadImage('portrait')}
              disabled={imageDownloading}
            >
              {imageDownloading ? (
                <span className="flex items-center">
                  <svg className="animate-spin -ml-1 mr-2 h-4 w-4 text-primary" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                  </svg>
                  Creating...
                </span>
              ) : (
                <>
                  <Download className="mr-2 h-4 w-4" />
                  Portrait (Stories)
                </>
              )}
            </Button>
          </div>
          <div className="text-center text-xs text-gray-500">
            Square format for posts (1080x1080) • Portrait format for stories & reels (1080x1920)
          </div>
        </div>
        
        <div className="text-center text-xs text-gray-500 px-2 mb-4">
          {user ? (
            "Download and share these images with your referral link to earn points when people click your link!"
          ) : (
            "Anyone can share, but only registered users earn points when people click their referral links. Register now to start earning!"
          )}
        </div>
        
        {/* We've moved the share link input to the instruction section */}
        
        {/* Referral link explanation */}
        <div className="flex flex-col space-y-2 bg-gray-50 p-3 rounded-md">
          <p className="text-center text-sm font-medium">How to share and earn referral points</p>
          {user ? (
            <ol className="text-xs text-gray-600 list-decimal pl-5">
              <li>Download your preferred image format using the buttons above</li>
              <li>Share the image on your social media accounts</li>
              <li>Include your referral link in your post - you earn points when people click your link:</li>
            </ol>
          ) : (
            <div className="text-xs text-gray-600 space-y-1">
              <p>Anyone can share, but only registered users earn points:</p>
              <ol className="list-decimal pl-5 space-y-1">
                <li>Register for a free account to get your referral link</li>
                <li>Share images with your referral link</li>
                <li>Earn points when people click your links</li>
              </ol>
            </div>
          )}
          <div className="flex mt-1 items-center">
            <Input
              value={displayUrl}
              readOnly
              className="text-xs h-8"
            />
            <Button size="sm" className="ml-2 h-8" onClick={handleCopy}>
              {copied ? <Check className="h-4 w-4" /> : <Copy className="h-4 w-4" />}
            </Button>
          </div>
        </div>

        <DialogFooter className="flex justify-center mt-2">
          <DialogClose asChild>
            <Button variant="outline">Close</Button>
          </DialogClose>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="client/src/pages/detail.tsx">
import { useQuery, useMutation } from "@tanstack/react-query";
import { useParams, useLocation } from "wouter";
import { Button } from "@/components/ui/button";
import { Skeleton } from "@/components/ui/skeleton";
import { Badge } from "@/components/ui/badge";
import RatingBar from "@/components/RatingBar";
import { TvShow, TvShowReview } from "@shared/schema";
import { useAuth } from "@/hooks/use-auth";
import { useToast } from "@/hooks/use-toast";
import { apiRequest, queryClient } from "@/lib/queryClient";
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from "@/components/ui/form";
import { Textarea } from "@/components/ui/textarea";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { useState, useEffect } from "react";
import { Heart, Share2 } from "lucide-react";
import ShareModal from "@/components/ShareModal";
import { 
  Carousel,
  CarouselContent,
  CarouselItem,
  CarouselNext,
  CarouselPrevious,
} from "@/components/ui/carousel";
import ShowCard from "@/components/ShowCard";
import AdContainer from "@/components/AdContainer";
import { Link } from "wouter";

// Define OMDb data type
interface OmdbData {
  runtime: string;
  rated: string;
  totalSeasons: string;
  language: string;
  country: string;
  director: string;
  writer: string;
  imdbRating: string;
  awards: string;
  poster: string;
  imdbId: string;
}

interface YouTubeData {
  title: string;
  description: string;
  subscriberCount: string;
  videoCount: string;
  viewCount: string;
  publishedAt: string;
  thumbnailUrl: string;
  channelId: string;
}

// Enhanced review type with upvotes
interface EnhancedReview extends TvShowReview {
  upvoteCount?: number;
  userHasUpvoted?: boolean;
}

type ShowDetailResponse = TvShow & { 
  reviews: EnhancedReview[];
  omdb?: OmdbData | null;
  youtube?: YouTubeData | null;
  externalData?: {
    omdb?: OmdbData | null;
    youtube?: YouTubeData | null;
  }
};

type DetailProps = {
  id: number;
}

// Review form schema
const reviewSchema = z.object({
  rating: z.number().min(1).max(5),
  review: z.string().min(5, "Review must be at least 5 characters").max(1000, "Review must be less than 1000 characters"),
});

type ReviewFormValues = z.infer<typeof reviewSchema>;

export default function Detail({ id }: DetailProps) {
  const [_, setLocation] = useLocation();
  const { user, toggleFavorite: toggleFav } = useAuth();
  const { toast } = useToast();
  const [isMobile, setIsMobile] = useState(false);
  const [isFavorite, setIsFavorite] = useState(false);
  const [shareModalOpen, setShareModalOpen] = useState(false);
  
  // Check if device is mobile
  useEffect(() => {
    const checkIfMobile = () => {
      const mobileWidth = 768;
      const width = window.innerWidth;
      setIsMobile(width < mobileWidth);
      console.log("Detail page - Window width:", width, "isMobile:", width < mobileWidth);
    };
    
    // Check on mount
    checkIfMobile();
    
    // Add resize listener
    window.addEventListener('resize', checkIfMobile);
    
    // Clean up
    return () => window.removeEventListener('resize', checkIfMobile);
  }, []);
  
  // Check if show is in favorites when component mounts or user changes
  useEffect(() => {
    const checkFavoriteStatus = async () => {
      if (user && id) {
        try {
          const isFav = await fetch(`/api/favorites/${id}`)
            .then(res => res.json())
            .then(data => data.isFavorite);
          setIsFavorite(isFav);
        } catch (error) {
          console.error("Failed to check favorite status:", error);
        }
      }
    };
    
    checkFavoriteStatus();
  }, [user, id]);
  
  const { data: showDetail, isLoading, error } = useQuery<ShowDetailResponse>({
    queryKey: [`/api/shows/${id}`],
  });
  
  // Review form
  const reviewForm = useForm<ReviewFormValues>({
    resolver: zodResolver(reviewSchema),
    defaultValues: {
      rating: 5,
      review: "",
    },
  });
  
  // Stars selection
  const [selectedRating, setSelectedRating] = useState(5);
  
  // Delete review mutation
  const deleteReviewMutation = useMutation({
    mutationFn: async (reviewId: number) => {
      return await apiRequest("DELETE", `/api/admin/reviews/${reviewId}`);
    },
    onSuccess: (data) => {
      toast({
        title: "Review deleted",
        description: `Successfully removed review. ${data.pointsDeducted} points have been deducted.`,
        variant: "destructive",
      });
      
      // Refresh show data to update reviews
      queryClient.invalidateQueries({ queryKey: [`/api/shows/${id}`] });
    },
    onError: (error) => {
      console.error("Error deleting review:", error);
      toast({
        title: "Error",
        description: "Failed to delete review. Please try again.",
        variant: "destructive",
      });
    }
  });
  
  // Handle delete review
  const handleDeleteReview = (reviewId: number) => {
    if (window.confirm("Are you sure you want to delete this review? This will also deduct the points awarded to the user.")) {
      deleteReviewMutation.mutate(reviewId);
    }
  };
  
  // Upvote review mutation with optimistic updates
  const upvoteReviewMutation = useMutation({
    mutationFn: async (reviewId: number) => {
      const response = await apiRequest("POST", `/api/reviews/${reviewId}/upvote`);
      if (!response.ok) {
        throw new Error("Failed to upvote review");
      }
      const data = await response.json();
      return data;
    },
    onMutate: async (reviewId) => {
      // Cancel any outgoing refetches so they don't overwrite our optimistic update
      await queryClient.cancelQueries({ queryKey: [`/api/shows/${id}`] });
      
      // Snapshot the previous value
      const previousData = queryClient.getQueryData([`/api/shows/${id}`]);
      
      // Optimistically update to the new value
      queryClient.setQueryData([`/api/shows/${id}`], (old: any) => {
        if (!old) return old;
        
        return {
          ...old,
          reviews: old.reviews.map((review: any) => 
            review.id === reviewId
              ? { 
                  ...review, 
                  upvoteCount: (review.upvoteCount || 0) + 1,
                  userHasUpvoted: true
                }
              : review
          )
        };
      });
      
      // Return a context object with the snapshot
      return { previousData };
    },
    onSuccess: (data) => {
      // Only show toast if we actually upvoted (not if it was already upvoted)
      if (!data.already_upvoted) {
        toast({
          title: "Upvoted",
          description: "You've upvoted this review. Thank you for the feedback!",
        });
      }
      
      // Also update the user dashboard to reflect points earned
      queryClient.invalidateQueries({ queryKey: ["/api/user/dashboard"] });
    },
    onError: (error: any, _, context) => {
      // If the mutation fails, use the context returned from onMutate to roll back
      if (context?.previousData) {
        queryClient.setQueryData([`/api/shows/${id}`], context.previousData);
      }
      
      toast({
        title: "Error",
        description: error?.message || "Failed to upvote review. Please try again.",
        variant: "destructive",
      });
    },
    // Deliberately not refetching after success to preserve optimistic update
  });
  
  // Remove upvote mutation with optimistic updates
  const removeUpvoteMutation = useMutation({
    mutationFn: async (reviewId: number) => {
      const response = await apiRequest("DELETE", `/api/reviews/${reviewId}/upvote`);
      if (!response.ok) {
        throw new Error("Failed to remove upvote");
      }
      const data = await response.json();
      return data;
    },
    onMutate: async (reviewId) => {
      // Cancel any outgoing refetches so they don't overwrite our optimistic update
      await queryClient.cancelQueries({ queryKey: [`/api/shows/${id}`] });
      
      // Snapshot the previous value
      const previousData = queryClient.getQueryData([`/api/shows/${id}`]);
      
      // Optimistically update to the new value
      queryClient.setQueryData([`/api/shows/${id}`], (old: any) => {
        if (!old) return old;
        
        return {
          ...old,
          reviews: old.reviews.map((review: any) => 
            review.id === reviewId
              ? { 
                  ...review, 
                  upvoteCount: Math.max((review.upvoteCount || 0) - 1, 0),
                  userHasUpvoted: false
                }
              : review
          )
        };
      });
      
      // Return a context object with the snapshot
      return { previousData };
    },
    onSuccess: () => {
      toast({
        title: "Upvote removed",
        description: "Your upvote has been removed.",
      });
      
      // Also update the user dashboard to reflect points changes
      queryClient.invalidateQueries({ queryKey: ["/api/user/dashboard"] });
    },
    onError: (error, _, context) => {
      // If the mutation fails, use the context returned from onMutate to roll back
      if (context?.previousData) {
        queryClient.setQueryData([`/api/shows/${id}`], context.previousData);
      }
      
      toast({
        title: "Error",
        description: "Failed to remove upvote. Please try again.",
        variant: "destructive",
      });
    },
    // Deliberately not refetching to preserve optimistic update
  });
  
  // Handle toggling upvote status
  const handleToggleUpvote = (reviewId: number, hasUpvoted: boolean) => {
    if (!user) {
      toast({
        title: "Sign in required",
        description: "You need to be signed in to upvote reviews.",
        variant: "default",
      });
      return;
    }
    
    if (hasUpvoted) {
      removeUpvoteMutation.mutate(reviewId);
    } else {
      upvoteReviewMutation.mutate(reviewId);
    }
  };
  
  // Add review mutation
  const addReviewMutation = useMutation({
    mutationFn: async (data: ReviewFormValues) => {
      return await apiRequest("POST", `/api/shows/${id}/reviews`, {
        ...data,
        userName: user?.username || "Anonymous",
        tvShowId: id,
      });
    },
    onSuccess: () => {
      toast({
        title: "Review added",
        description: "Your review has been added successfully! You earned 5 points for your review.",
      });
      reviewForm.reset();
      setSelectedRating(5);
      
      // Refresh both the show details and the user dashboard
      queryClient.invalidateQueries({ queryKey: [`/api/shows/${id}`] });
      queryClient.invalidateQueries({ queryKey: ['/api/user/dashboard'] });
    },
    onError: (error) => {
      toast({
        title: "Error",
        description: "Failed to add review. Please try again.",
        variant: "destructive",
      });
    },
  });

  // Toggle favorite function
  const toggleFavorite = async (e: React.MouseEvent) => {
    e.stopPropagation();
    
    // Check if user is logged in
    if (!user) {
      toast({
        title: "Authentication required",
        description: "Please log in or register to save shows to your favorites.",
        variant: "default",
      });
      setLocation("/auth");
      return;
    }
    
    // Use the auth context toggle favorite function
    try {
      await toggleFav(parseInt(id));
      // Update local state (optimistic update)
      setIsFavorite(!isFavorite);
      
      toast({
        title: isFavorite ? "Removed from favorites" : "Added to favorites",
        description: isFavorite 
          ? `${showDetail?.name} has been removed from your favorites.` 
          : `${showDetail?.name} has been added to your favorites.`,
        variant: "default",
      });
      
      // Invalidate related queries
      queryClient.invalidateQueries({ queryKey: ["/api/user/favorites"] });
      queryClient.invalidateQueries({ queryKey: ["/api/user/dashboard"] });
    } catch (error) {
      console.error("Failed to toggle favorite:", error);
      toast({
        title: "Error",
        description: "Failed to update favorites. Please try again.",
        variant: "destructive",
      });
    }
  };

  const handleBackClick = () => {
    setLocation("/");
  };

  const handleCompareClick = () => {
    // Add to comparison and redirect to compare page
    // For now, just navigate to the compare page
    setLocation("/compare");
  };

  if (isLoading) {
    return (
      <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <div className="mb-6 flex items-center">
          <Button variant="ghost" className="mr-4 text-primary" onClick={handleBackClick}>
            <i className="fas fa-arrow-left mr-2"></i> Back to Shows
          </Button>
          <Skeleton className="h-8 w-56" />
        </div>
        
        <div className="bg-white rounded-xl shadow-md overflow-hidden">
          <div className="md:flex">
            <div className="md:flex-shrink-0 md:w-1/3">
              <Skeleton className="h-64 w-full md:h-full" />
            </div>
            
            <div className="p-6 md:w-2/3">
              <div className="flex justify-between items-start">
                <div>
                  <Skeleton className="h-8 w-40 mb-2" />
                  <Skeleton className="h-4 w-60" />
                </div>
              </div>
              
              <div className="mt-6">
                <Skeleton className="h-4 w-full mb-2" />
                <Skeleton className="h-4 w-full mb-2" />
                <Skeleton className="h-4 w-4/5" />
              </div>
            </div>
          </div>
        </div>
      </main>
    );
  }

  if (error || !showDetail) {
    return (
      <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <div className="mb-6 flex items-center">
          <Button variant="ghost" className="mr-4 text-primary" onClick={handleBackClick}>
            <i className="fas fa-arrow-left mr-2"></i> Back to Shows
          </Button>
          <h2 className="text-2xl font-heading font-bold">Error</h2>
        </div>
        
        <div className="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded">
          <p>Failed to load show details. Please try again later.</p>
          <Button variant="outline" onClick={handleBackClick} className="mt-2">
            Return to Browse
          </Button>
        </div>
      </main>
    );
  }

  return (
    <main className="max-w-5xl mx-auto px-4 sm:px-6 lg:px-8 py-8 bg-gray-50">
      <div className="mb-4 flex items-center">
        <Button variant="ghost" className="text-primary hover:text-primary-700" onClick={handleBackClick}>
          <i className="fas fa-arrow-left mr-2"></i> Back to Catalog
        </Button>
      </div>
      
      <div className="bg-white rounded-md shadow overflow-hidden mb-8">
        <div className="md:flex p-6">
          {/* Left column - Show image and key info */}
          <div className="md:w-1/4 flex-shrink-0 mb-4 md:mb-0 md:mr-6">
            {/* Use OMDb poster if available, otherwise use our image or placeholder */}
            {showDetail.omdb?.poster && showDetail.omdb.poster !== 'N/A' ? (
              <div className="mb-4 rounded border border-gray-200 overflow-hidden" style={{ maxHeight: '400px' }}>
                <img 
                  className="w-full h-full object-contain" 
                  src={showDetail.omdb.poster} 
                  alt={showDetail.name}
                />
              </div>
            ) : showDetail.imageUrl ? (
              <div className="mb-4 rounded border border-gray-200 overflow-hidden" style={{ maxHeight: '400px' }}>
                <img 
                  className="w-full h-full object-contain" 
                  src={showDetail.imageUrl} 
                  alt={showDetail.name}
                />
              </div>
            ) : (
              <div className="w-full h-auto aspect-square mb-4 bg-gray-200 flex items-center justify-center rounded border border-gray-200">
                <i className="fas fa-tv text-gray-400 text-4xl"></i>
              </div>
            )}
            
            <div className="space-y-4">
              <div>
                <h3 className="text-sm font-semibold text-gray-700">Key Information</h3>
                <div className="mt-2 space-y-2">
                  <div>
                    <div className="text-sm font-medium text-gray-600">Target Age Range:</div>
                    <div className="text-sm">{showDetail.ageRange || '10-14'}</div>
                  </div>
                  
                  <div>
                    <div className="text-sm font-medium text-gray-600">Platform(s):</div>
                    <div className="text-sm">{showDetail.availableOn?.join(", ") || 'TV'}</div>
                  </div>
                  
                  <div>
                    <div className="text-sm font-medium text-gray-600">Avg. Episode Length:</div>
                    <div className="text-sm">{showDetail.episodeLength ? `${showDetail.episodeLength} min` : 'Long (20-30m)'}</div>
                  </div>
                  
                  <div>
                    <div className="text-sm font-medium text-gray-600">Seasons:</div>
                    <div className="text-sm">{showDetail.seasons || '4 seasons'}</div>
                  </div>
                </div>
              </div>
              
              {/* IMDb Data Section */}
              {(showDetail.omdb || showDetail.externalData?.omdb) && (
                <div className="mt-4">
                  <h3 className="text-sm font-semibold text-gray-700 flex items-center">
                    <img src="https://m.media-amazon.com/images/G/01/imdb/images/desktop-favicon-2165806970._CB485933742_.ico" 
                         alt="IMDb" 
                         className="w-4 h-4 mr-1" />
                    IMDb Information
                  </h3>
                  <div className="mt-2 space-y-2">
                    {/* IMDb Rating */}
                    {showDetail.externalData?.omdb?.imdbRating && (
                      <div>
                        <div className="text-sm font-medium text-gray-600">IMDb Rating:</div>
                        <div className="text-sm flex items-center">
                          <span className="text-yellow-500 mr-1">★</span>
                          {showDetail.externalData.omdb.imdbRating}/10
                        </div>
                      </div>
                    )}
                    
                    {/* Rated */}
                    {showDetail.externalData?.omdb?.rated && (
                      <div>
                        <div className="text-sm font-medium text-gray-600">Rated:</div>
                        <div className="text-sm">
                          {showDetail.externalData.omdb.rated}
                        </div>
                      </div>
                    )}
                    
                    {/* Runtime */}
                    {showDetail.externalData?.omdb?.runtime && (
                      <div>
                        <div className="text-sm font-medium text-gray-600">Runtime:</div>
                        <div className="text-sm">
                          {showDetail.externalData.omdb.runtime}
                        </div>
                      </div>
                    )}
                    
                    {/* Seasons */}
                    {showDetail.externalData?.omdb?.totalSeasons && (
                      <div>
                        <div className="text-sm font-medium text-gray-600">Seasons:</div>
                        <div className="text-sm">
                          {showDetail.externalData.omdb.totalSeasons}
                        </div>
                      </div>
                    )}
                    
                    {/* Language */}
                    {showDetail.externalData?.omdb?.language && (
                      <div>
                        <div className="text-sm font-medium text-gray-600">Language:</div>
                        <div className="text-sm">
                          {showDetail.externalData.omdb.language}
                        </div>
                      </div>
                    )}
                    
                    {/* Country */}
                    {showDetail.externalData?.omdb?.country && (
                      <div>
                        <div className="text-sm font-medium text-gray-600">Country:</div>
                        <div className="text-sm">
                          {showDetail.externalData.omdb.country}
                        </div>
                      </div>
                    )}
                    
                    {/* Writer */}
                    {showDetail.externalData?.omdb?.writer && (
                      <div>
                        <div className="text-sm font-medium text-gray-600">Writer:</div>
                        <div className="text-sm">
                          {showDetail.externalData.omdb.writer}
                        </div>
                      </div>
                    )}
                    
                    {/* Awards */}
                    {showDetail.externalData?.omdb?.awards && (
                      <div>
                        <div className="text-sm font-medium text-gray-600">Awards:</div>
                        <div className="text-sm">
                          {showDetail.externalData.omdb.awards}
                        </div>
                      </div>
                    )}
                    
                    {/* Show IMDb link if ID is available from either source */}
                    {(showDetail.omdb?.imdbId || showDetail.externalData?.omdb?.imdbId) && (
                      <div className="mt-2">
                        <a 
                          href={`https://www.imdb.com/title/${showDetail.omdb?.imdbId || showDetail.externalData?.omdb?.imdbId}`} 
                          target="_blank" 
                          rel="noopener noreferrer"
                          className="text-xs text-blue-600 hover:text-blue-800 flex items-center"
                        >
                          View on IMDb 
                          <i className="fas fa-external-link-alt ml-1"></i>
                        </a>
                      </div>
                    )}
                  </div>
                </div>
              )}
              
              {/* YouTube Data Section */}
              {(showDetail.isYouTubeChannel || showDetail.subscriberCount || 
                showDetail.videoCount || showDetail.externalData?.youtube) && (
                <div className="mt-4 border-t pt-4">
                  <h3 className="text-sm font-semibold text-gray-700 flex items-center">
                    <i className="fab fa-youtube text-red-600 mr-1"></i>
                    YouTube Channel Information
                  </h3>
                  <div className="mt-2 space-y-2">
                    {/* Subscriber count - from either source */}
                    {(showDetail.subscriberCount || showDetail.externalData?.youtube?.subscriberCount) && (
                      <div>
                        <div className="text-sm font-medium text-gray-600">Subscribers:</div>
                        <div className="text-sm">
                          {parseInt(showDetail.subscriberCount || 
                            showDetail.externalData?.youtube?.subscriberCount || '0').toLocaleString()}
                        </div>
                      </div>
                    )}
                    
                    {/* Video count - from either source */}
                    {(showDetail.videoCount || showDetail.externalData?.youtube?.videoCount) && (
                      <div>
                        <div className="text-sm font-medium text-gray-600">Videos:</div>
                        <div className="text-sm">
                          {parseInt(showDetail.videoCount || 
                            showDetail.externalData?.youtube?.videoCount || '0').toLocaleString()}
                        </div>
                      </div>
                    )}
                    
                    {/* Channel creation date - from either source */}
                    {(showDetail.publishedAt || showDetail.externalData?.youtube?.publishedAt) && (
                      <div>
                        <div className="text-sm font-medium text-gray-600">Channel Since:</div>
                        <div className="text-sm">
                          {new Date(showDetail.publishedAt || 
                            showDetail.externalData?.youtube?.publishedAt || '').toLocaleDateString()}
                        </div>
                      </div>
                    )}
                    
                    {/* Show YouTube link if channel ID is available from either source */}
                    {(showDetail.channelId || showDetail.externalData?.youtube?.channelId) && (
                      <div className="mt-2">
                        <a 
                          href={`https://www.youtube.com/channel/${showDetail.channelId || showDetail.externalData?.youtube?.channelId}`} 
                          target="_blank" 
                          rel="noopener noreferrer"
                          className="text-xs text-red-600 hover:text-red-800 flex items-center"
                        >
                          View on YouTube 
                          <i className="fas fa-external-link-alt ml-1"></i>
                        </a>
                      </div>
                    )}
                    
                    {/* Add search link when no direct channel ID is available */}
                    {!showDetail.channelId && !showDetail.externalData?.youtube?.channelId && (
                      <div className="mt-2">
                        <a 
                          href={`https://www.youtube.com/results?search_query=${encodeURIComponent(showDetail.name)}`} 
                          target="_blank" 
                          rel="noopener noreferrer"
                          className="text-xs text-red-600 hover:text-red-800 flex items-center"
                        >
                          Search on YouTube 
                          <i className="fas fa-search ml-1"></i>
                        </a>
                      </div>
                    )}
                  </div>
                </div>
              )}
              
              {/* Overall Stimulation Score - Desktop only */}
              <div className="hidden md:block">
                <h3 className="text-sm font-semibold text-gray-700">Overall Stimulation Score:</h3>
                <div className="flex items-center space-x-2 mt-1">
                  {Array.from({ length: 5 }).map((_, i) => {
                    const score = i + 1; // 1-5 score range
                    const bgColor = 
                      score === 1 ? 'bg-green-500' : // green for 1
                      score === 2 ? 'bg-yellow-500' : // yellow for 2
                      score === 3 ? 'bg-orange-500' : // orange for 3
                      score === 4 ? 'bg-orange-600' : // redish orange for 4
                      'bg-red-500'; // red for 5
                    
                    const borderColor = 
                      score === 1 ? 'border-green-500' : // green for 1
                      score === 2 ? 'border-yellow-500' : // yellow for 2
                      score === 3 ? 'border-orange-500' : // orange for 3
                      score === 4 ? 'border-orange-600' : // redish orange for 4
                      'border-red-500'; // red for 5
                    
                    return (
                      <div 
                        key={i} 
                        className={`w-4 h-4 rounded-full ${
                          // Active dots show their own color
                          i < showDetail.stimulationScore 
                            ? bgColor 
                            // Inactive dots are outlined with their corresponding color
                            : `border-2 ${borderColor} bg-white`
                        }`} 
                      />
                    );
                  })}
                  <span className="text-sm font-medium">{showDetail.stimulationScore}/5</span>
                </div>
              </div>
              
              <div>
                <h3 className="text-sm font-semibold text-gray-700">Themes:</h3>
                <div className="flex flex-wrap gap-1 mt-1">
                  {showDetail.themes && showDetail.themes.length > 0 ? (
                    showDetail.themes.map((theme, index) => (
                      <Badge 
                        key={index} 
                        className="px-2 py-1 text-xs bg-blue-100 text-blue-800 hover:bg-blue-200 rounded-md"
                      >
                        {theme}
                      </Badge>
                    ))
                  ) : (
                    <span className="text-xs text-gray-500 italic">No themes specified</span>
                  )}
                </div>
              </div>
            </div>
          </div>
          
          {/* Right column - Title and content */}
          <div className="md:w-3/4">
            <div>
              <h1 className="text-3xl font-bold text-teal-700 mb-2">
                {showDetail.name}
                {(showDetail.releaseYear || showDetail.endYear) && 
                  <span className="text-gray-600 font-normal text-xl ml-2">
                    ({showDetail.releaseYear || "Unknown"}-{showDetail.isOngoing ? "present" : (showDetail.endYear || "Unknown")})
                  </span>
                }
              </h1>
              <div className="mb-4 flex space-x-2">
                <Button 
                  variant="ghost" 
                  size="sm"
                  className={`px-2 py-1 ${isFavorite ? 'text-red-500' : 'text-gray-400 hover:text-red-500'}`}
                  onClick={(e) => toggleFavorite(e)}
                >
                  <Heart className={`w-5 h-5 mr-1 ${isFavorite ? 'fill-red-500 text-red-500' : ''}`} />
                  {isFavorite ? 'Saved' : 'Add to Favorites'}
                </Button>
                
                <Button
                  variant="ghost"
                  size="sm"
                  className="px-2 py-1 text-blue-500"
                  onClick={() => setShareModalOpen(true)}
                >
                  <Share2 className="w-5 h-5 mr-1" />
                  Share
                </Button>
              </div>
              
              {/* Overall Stimulation Score - Mobile only (below favorites/share buttons) */}
              <div className="md:hidden mt-4 mb-6">
                <h3 className="text-sm font-semibold text-gray-700">Overall Stimulation Score:</h3>
                <div className="flex items-center space-x-2 mt-1">
                  {Array.from({ length: 5 }).map((_, i) => {
                    const score = i + 1; // 1-5 score range
                    const bgColor = 
                      score === 1 ? 'bg-green-500' : // green for 1
                      score === 2 ? 'bg-yellow-500' : // yellow for 2
                      score === 3 ? 'bg-orange-500' : // orange for 3
                      score === 4 ? 'bg-orange-600' : // redish orange for 4
                      'bg-red-500'; // red for 5
                    
                    const borderColor = 
                      score === 1 ? 'border-green-500' : // green for 1
                      score === 2 ? 'border-yellow-500' : // yellow for 2
                      score === 3 ? 'border-orange-500' : // orange for 3
                      score === 4 ? 'border-orange-600' : // redish orange for 4
                      'border-red-500'; // red for 5
                    
                    return (
                      <div 
                        key={i} 
                        className={`w-4 h-4 rounded-full ${
                          // Active dots show their own color
                          i < showDetail.stimulationScore 
                            ? bgColor 
                            // Inactive dots are outlined with their corresponding color
                            : `border-2 ${borderColor} bg-white`
                        }`} 
                      />
                    );
                  })}
                  <span className="text-sm font-medium">{showDetail.stimulationScore}/5</span>
                </div>
              </div>
              
              {/* Sensory Details Section */}
              <div className="mt-8">
                <h2 className="text-xl font-bold text-gray-800 border-b border-gray-200 pb-2 mb-4">Sensory Details</h2>
                
                <div className="space-y-5">
                  {/* Dialogue Intensity Bar */}
                  <div>
                    <div className="flex justify-between mb-1">
                      <div className="text-gray-600">Dialogue Intensity:</div>
                      <div className="font-medium">{showDetail.dialogueIntensity || 'Not Available'}</div>
                    </div>
                    <div className="h-4 w-full bg-gray-200 rounded-full overflow-hidden flex">
                      {[1, 2, 3, 4, 5].map((segment) => {
                        let level = 1; // Default to low if no data
                        
                        // Handle all possible rating values from the database
                        if (showDetail.dialogueIntensity) {
                          if (showDetail.dialogueIntensity.includes('Low-Moderate') || 
                              showDetail.dialogueIntensity.includes('Low to Moderate')) {
                            level = 2;
                          } else if (showDetail.dialogueIntensity.includes('Moderate-Low')) {
                            level = 2;
                          } else if (showDetail.dialogueIntensity.includes('Moderate-High') || 
                                    showDetail.dialogueIntensity.includes('Moderate to High')) {
                            level = 4;
                          } else if (showDetail.dialogueIntensity.includes('Mod-High')) {
                            level = 4;
                          } else if (showDetail.dialogueIntensity === 'Low') {
                            level = 1;
                          } else if (showDetail.dialogueIntensity === 'Moderate') {
                            level = 3;
                          } else if (showDetail.dialogueIntensity === 'High') {
                            level = 5;
                          }
                        }
                          
                        const color = 
                          segment === 1 ? 'bg-green-500' : 
                          segment === 2 ? 'bg-yellow-500' : 
                          segment === 3 ? 'bg-orange-500' : 
                          segment === 4 ? 'bg-orange-600' : 
                          'bg-red-500';
                        
                        return (
                          <div
                            key={segment}
                            className={`h-full w-1/5 ${segment <= level ? color : 'bg-gray-200'}`}
                          />
                        );
                      })}
                    </div>
                  </div>
                  
                  {/* Scene Frequency Bar */}
                  <div>
                    <div className="flex justify-between mb-1">
                      <div className="text-gray-600">Scene Frequency:</div>
                      <div className="font-medium">{showDetail.sceneFrequency || 'Moderate'}</div>
                    </div>
                    <div className="h-4 w-full bg-gray-200 rounded-full overflow-hidden flex">
                      {[1, 2, 3, 4, 5].map((segment) => {
                        let level = 3; // Default to moderate
                        
                        // Handle all possible rating values from the spreadsheet
                        if (showDetail.sceneFrequency) {
                          if (showDetail.sceneFrequency.includes('Low-Moderate') || 
                              showDetail.sceneFrequency.includes('Low to Moderate')) {
                            level = 2;
                          } else if (showDetail.sceneFrequency.includes('Moderate-Low')) {
                            level = 2;
                          } else if (showDetail.sceneFrequency.includes('Moderate-High') || 
                                     showDetail.sceneFrequency.includes('Moderate to High')) {
                            level = 4;
                          } else if (showDetail.sceneFrequency.includes('Mod-High')) {
                            level = 4;
                          } else if (showDetail.sceneFrequency === 'Low') {
                            level = 1;
                          } else if (showDetail.sceneFrequency === 'Moderate') {
                            level = 3;
                          } else if (showDetail.sceneFrequency === 'High') {
                            level = 5;
                          } else if (showDetail.sceneFrequency === 'Limited') {
                            level = 1;
                          } else if (showDetail.sceneFrequency === 'Minimal') {
                            level = 1;
                          }
                        }
                          
                        const color = 
                          segment === 1 ? 'bg-green-500' : 
                          segment === 2 ? 'bg-yellow-500' : 
                          segment === 3 ? 'bg-orange-500' : 
                          segment === 4 ? 'bg-orange-600' : 
                          'bg-red-500';
                        
                        return (
                          <div
                            key={segment}
                            className={`h-full w-1/5 ${segment <= level ? color : 'bg-gray-200'}`}
                          />
                        );
                      })}
                    </div>
                  </div>
                  
                  {/* Sound Effects Level Bar */}
                  <div>
                    <div className="flex justify-between mb-1">
                      <div className="text-gray-600">Sound Effects Level:</div>
                      <div className="font-medium">{showDetail.soundEffectsLevel || 'Moderate'}</div>
                    </div>
                    <div className="h-4 w-full bg-gray-200 rounded-full overflow-hidden flex">
                      {[1, 2, 3, 4, 5].map((segment) => {
                        let level = 3; // Default to moderate
                        
                        // Handle all possible rating values from the spreadsheet
                        if (showDetail.soundEffectsLevel) {
                          if (showDetail.soundEffectsLevel.includes('Low-Moderate') || 
                              showDetail.soundEffectsLevel.includes('Low to Moderate')) {
                            level = 2;
                          } else if (showDetail.soundEffectsLevel.includes('Moderate-Low')) {
                            level = 2;
                          } else if (showDetail.soundEffectsLevel.includes('Moderate-High') || 
                                     showDetail.soundEffectsLevel.includes('Moderate to High')) {
                            level = 4;
                          } else if (showDetail.soundEffectsLevel.includes('Mod-High')) {
                            level = 4;
                          } else if (showDetail.soundEffectsLevel === 'Low') {
                            level = 1;
                          } else if (showDetail.soundEffectsLevel === 'Moderate') {
                            level = 3;
                          } else if (showDetail.soundEffectsLevel === 'High') {
                            level = 5;
                          } else if (showDetail.soundEffectsLevel === 'Limited') {
                            level = 1;
                          } else if (showDetail.soundEffectsLevel === 'Minimal') {
                            level = 1;
                          }
                        }
                          
                        const color = 
                          segment === 1 ? 'bg-green-500' : 
                          segment === 2 ? 'bg-yellow-500' : 
                          segment === 3 ? 'bg-orange-500' : 
                          segment === 4 ? 'bg-orange-600' : 
                          'bg-red-500';
                        
                        return (
                          <div
                            key={segment}
                            className={`h-full w-1/5 ${segment <= level ? color : 'bg-gray-200'}`}
                          />
                        );
                      })}
                    </div>
                  </div>

                  {/* Total Sound Effect Time Level Bar */}
                  <div>
                    <div className="flex justify-between mb-1">
                      <div className="text-gray-600">Total Sound Effect Time:</div>
                      <div className="font-medium">{showDetail.totalSoundEffectTimeLevel || 'Moderate'}</div>
                    </div>
                    <div className="h-4 w-full bg-gray-200 rounded-full overflow-hidden flex">
                      {[1, 2, 3, 4, 5].map((segment) => {
                        let level = 3; // Default to moderate
                        
                        // Handle all possible rating values from the spreadsheet
                        if (showDetail.totalSoundEffectTimeLevel) {
                          if (showDetail.totalSoundEffectTimeLevel.includes('Low-Moderate') || 
                              showDetail.totalSoundEffectTimeLevel.includes('Low to Moderate')) {
                            level = 2;
                          } else if (showDetail.totalSoundEffectTimeLevel.includes('Moderate-Low')) {
                            level = 2;
                          } else if (showDetail.totalSoundEffectTimeLevel.includes('Moderate-High') || 
                                     showDetail.totalSoundEffectTimeLevel.includes('Moderate to High')) {
                            level = 4;
                          } else if (showDetail.totalSoundEffectTimeLevel.includes('Mod-High')) {
                            level = 4;
                          } else if (showDetail.totalSoundEffectTimeLevel === 'Low') {
                            level = 1;
                          } else if (showDetail.totalSoundEffectTimeLevel === 'Moderate') {
                            level = 3;
                          } else if (showDetail.totalSoundEffectTimeLevel === 'High') {
                            level = 5;
                          } else if (showDetail.totalSoundEffectTimeLevel === 'Limited') {
                            level = 1;
                          } else if (showDetail.totalSoundEffectTimeLevel === 'Minimal') {
                            level = 1;
                          }
                        }
                          
                        const color = 
                          segment === 1 ? 'bg-green-500' : 
                          segment === 2 ? 'bg-yellow-500' : 
                          segment === 3 ? 'bg-orange-500' : 
                          segment === 4 ? 'bg-orange-600' : 
                          'bg-red-500';
                        
                        return (
                          <div
                            key={segment}
                            className={`h-full w-1/5 ${segment <= level ? color : 'bg-gray-200'}`}
                          />
                        );
                      })}
                    </div>
                  </div>
                  
                  {/* Music Tempo Bar */}
                  <div>
                    <div className="flex justify-between mb-1">
                      <div className="text-gray-600">Music Tempo:</div>
                      <div className="font-medium">{showDetail.musicTempo || 'Varies'}</div>
                    </div>
                    {showDetail.musicTempo === 'Varies' ? (
                      <div className="h-4 w-full bg-gray-200 rounded-full overflow-hidden">
                        <div 
                          className="h-full bg-gradient-to-r from-green-500 via-yellow-500 to-red-500"
                          style={{ width: '100%' }}
                        ></div>
                      </div>
                    ) : (
                      <div className="h-4 w-full bg-gray-200 rounded-full overflow-hidden flex">
                        {[1, 2, 3, 4, 5].map((segment) => {
                          let level = 3; // Default to moderate
                        
                          // Handle all possible rating values from the spreadsheet
                          if (showDetail.musicTempo) {
                            if (showDetail.musicTempo.includes('Low-Moderate') || 
                                showDetail.musicTempo.includes('Low to Moderate')) {
                              level = 2;
                            } else if (showDetail.musicTempo.includes('Moderate-Low')) {
                              level = 2;
                            } else if (showDetail.musicTempo.includes('Moderate-High') || 
                                       showDetail.musicTempo.includes('Moderate to High')) {
                              level = 4;
                            } else if (showDetail.musicTempo.includes('Mod-High')) {
                              level = 4;
                            } else if (showDetail.musicTempo === 'Low') {
                              level = 1;
                            } else if (showDetail.musicTempo === 'Moderate') {
                              level = 3;
                            } else if (showDetail.musicTempo === 'High') {
                              level = 5;
                            } else if (showDetail.musicTempo === 'Limited') {
                              level = 1;
                            } else if (showDetail.musicTempo === 'Minimal') {
                              level = 1;
                            }
                          }
                            
                          const color = 
                            segment === 1 ? 'bg-green-500' : 
                            segment === 2 ? 'bg-yellow-500' : 
                            segment === 3 ? 'bg-orange-500' : 
                            segment === 4 ? 'bg-orange-600' : 
                            'bg-red-500';
                          
                          return (
                            <div
                              key={segment}
                              className={`h-full w-1/5 ${segment <= level ? color : 'bg-gray-200'}`}
                            />
                          );
                        })}
                      </div>
                    )}
                  </div>
                  
                  {/* Total Music Level Bar */}
                  <div>
                    <div className="flex justify-between mb-1">
                      <div className="text-gray-600">Total Music Level:</div>
                      <div className="font-medium">{showDetail.totalMusicLevel || 'Moderate'}</div>
                    </div>
                    <div className="h-4 w-full bg-gray-200 rounded-full overflow-hidden flex">
                      {[1, 2, 3, 4, 5].map((segment) => {
                        let level = 3; // Default to moderate
                        
                        // Handle all possible rating values from the spreadsheet
                        if (showDetail.totalMusicLevel) {
                          if (showDetail.totalMusicLevel.includes('Low-Moderate') || 
                              showDetail.totalMusicLevel.includes('Low to Moderate')) {
                            level = 2;
                          } else if (showDetail.totalMusicLevel.includes('Moderate-Low')) {
                            level = 2;
                          } else if (showDetail.totalMusicLevel.includes('Moderate-High') || 
                                     showDetail.totalMusicLevel.includes('Moderate to High')) {
                            level = 4;
                          } else if (showDetail.totalMusicLevel.includes('Mod-High')) {
                            level = 4;
                          } else if (showDetail.totalMusicLevel === 'Low') {
                            level = 1;
                          } else if (showDetail.totalMusicLevel === 'Moderate') {
                            level = 3;
                          } else if (showDetail.totalMusicLevel === 'High') {
                            level = 5;
                          } else if (showDetail.totalMusicLevel === 'Limited') {
                            level = 1;
                          } else if (showDetail.totalMusicLevel === 'Minimal') {
                            level = 1;
                          }
                        }
                          
                        const color = 
                          segment === 1 ? 'bg-green-500' : 
                          segment === 2 ? 'bg-yellow-500' : 
                          segment === 3 ? 'bg-orange-500' : 
                          segment === 4 ? 'bg-orange-600' : 
                          'bg-red-500';
                        
                        return (
                          <div
                            key={segment}
                            className={`h-full w-1/5 ${segment <= level ? color : 'bg-gray-200'}`}
                          />
                        );
                      })}
                    </div>
                  </div>
                  
                  {/* Interaction Level Bar */}
                  <div>
                    <div className="flex justify-between mb-1">
                      <div className="text-gray-600">Interaction Level:</div>
                      <div className="font-medium">{showDetail.interactivityLevel || 'Not Available'}</div>
                    </div>
                    <div className="h-4 w-full bg-gray-200 rounded-full overflow-hidden flex">
                      {[1, 2, 3, 4, 5].map((segment) => {
                        let level = 1; // Default to low if no data
                        
                        // Handle all possible rating values from the database
                        if (showDetail.interactivityLevel) {
                          if (showDetail.interactivityLevel.includes('Low-Moderate') || 
                              showDetail.interactivityLevel.includes('Low to Moderate')) {
                            level = 2;
                          } else if (showDetail.interactivityLevel.includes('Moderate-Low')) {
                            level = 2;
                          } else if (showDetail.interactivityLevel.includes('Moderate-High') || 
                                    showDetail.interactivityLevel.includes('Moderate to High')) {
                            level = 4;
                          } else if (showDetail.interactivityLevel.includes('Mod-High')) {
                            level = 4;
                          } else if (showDetail.interactivityLevel === 'Low') {
                            level = 1;
                          } else if (showDetail.interactivityLevel === 'Moderate') {
                            level = 3;
                          } else if (showDetail.interactivityLevel === 'High') {
                            level = 5;
                          } else if (showDetail.interactivityLevel === 'Limited') {
                            level = 1;
                          } else if (showDetail.interactivityLevel === 'Minimal') {
                            level = 1;
                          }
                        }
                          
                        const color = 
                          segment === 1 ? 'bg-green-500' : 
                          segment === 2 ? 'bg-yellow-500' : 
                          segment === 3 ? 'bg-orange-500' : 
                          segment === 4 ? 'bg-orange-600' : 
                          'bg-red-500';
                        
                        return (
                          <div
                            key={segment}
                            className={`h-full w-1/5 ${segment <= level ? color : 'bg-gray-200'}`}
                          />
                        );
                      })}
                    </div>
                  </div>
                  
                  {/* Animation Style */}
                  <div className="grid grid-cols-1">
                    <div className="text-gray-600 mb-1">Animation Style:</div>
                    <div className="font-medium">
                      {showDetail.animationStyle || 'Traditional 2D Animation with surreal and sometimes dark visuals. Color Palette: Varied colors with contrasting dark and bright tones.'}
                    </div>
                  </div>
                </div>
              </div>
              

            </div>
          </div>
        </div>
        
        {/* Detail Page Ad */}
        <div className="border-t border-gray-200 p-6">
          <AdContainer size="leaderboard" className="mx-auto mb-6" />
        </div>
        
        <div className="border-t border-gray-200 p-6">
          <h3 className="font-heading font-bold text-gray-900 mb-4">Parent Reviews</h3>
          
          {/* Add review form - only shown to logged-in users */}
          {user ? (
            <div className="bg-gray-50 p-4 rounded-lg mb-6">
              <h4 className="font-medium text-gray-800 mb-4">Share Your Experience</h4>
              <Form {...reviewForm}>
                <form onSubmit={reviewForm.handleSubmit((data) => addReviewMutation.mutate(data))} className="space-y-4">
                  {/* Rating stars */}
                  <div>
                    <FormLabel>Rating</FormLabel>
                    <div className="flex items-center gap-1 mt-2">
                      {[1, 2, 3, 4, 5].map((value) => (
                        <button
                          key={value}
                          type="button"
                          onClick={() => {
                            setSelectedRating(value);
                            reviewForm.setValue('rating', value);
                          }}
                          className="text-2xl focus:outline-none"
                        >
                          {value <= selectedRating ? (
                            <i className="fas fa-star text-yellow-500"></i>
                          ) : (
                            <i className="far fa-star text-gray-400"></i>
                          )}
                        </button>
                      ))}
                      <span className="ml-2 text-sm text-gray-500">
                        {selectedRating} out of 5 stars
                      </span>
                    </div>
                    {reviewForm.formState.errors.rating && (
                      <p className="text-red-500 text-sm mt-1">{reviewForm.formState.errors.rating.message}</p>
                    )}
                  </div>
                  
                  {/* Review text */}
                  <FormField
                    control={reviewForm.control}
                    name="review"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Your Review</FormLabel>
                        <FormControl>
                          <Textarea 
                            placeholder="Share your thoughts about this show..." 
                            {...field} 
                            className="h-24"
                          />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />
                  
                  <Button 
                    type="submit" 
                    disabled={addReviewMutation.isPending}
                    className="bg-primary text-white hover:bg-primary-600"
                  >
                    {addReviewMutation.isPending ? 'Submitting...' : 'Submit Review'}
                  </Button>
                </form>
              </Form>
            </div>
          ) : (
            <div className="bg-blue-50 p-4 rounded-lg mb-6 border border-blue-100">
              <p className="text-blue-800">
                <Link href={`/auth?redirect=/detail/${id}`} className="font-medium underline">
                  Sign in or register
                </Link> to leave a review and help other parents choose appropriate shows for their children.
              </p>
            </div>
          )}
          
          {/* Existing reviews section */}
          {showDetail.reviews && showDetail.reviews.length > 0 ? (
            <div className="space-y-4">
              {showDetail.reviews.map((review, index) => (
                <div key={index} className="flex p-4 bg-white rounded-lg border border-gray-100 shadow-sm">
                  <div className="flex-shrink-0 mr-4">
                    <div className="w-10 h-10 rounded-full bg-primary-100 flex items-center justify-center">
                      <span className="font-medium text-primary-600">
                        {review.userName.split(' ').map(name => name[0]).join('')}
                      </span>
                    </div>
                  </div>
                  <div className="flex-1">
                    <div className="flex items-center justify-between mb-1">
                      <div className="flex items-center">
                        {user ? (
                          <Link href={`/user/${review.userId}`}>
                            <h4 className="font-medium text-blue-600 hover:text-blue-800 cursor-pointer underline">
                              {review.userName}
                            </h4>
                          </Link>
                        ) : (
                          <h4 
                            className="font-medium text-blue-600 hover:text-blue-800 cursor-pointer underline"
                            onClick={() => setLocation("/auth")}
                          >
                            {review.userName}
                          </h4>
                        )}
                        <div className="ml-2 flex">
                          {[...Array(5)].map((_, i) => (
                            <i key={i} className={`${i < review.rating ? 'fas' : 'far'} fa-star text-yellow-500`}></i>
                          ))}
                        </div>
                      </div>
                      <div className="flex items-center gap-2">
                        {/* Only show upvote button if user is logged in and not the review author */}
                        {user && user.id !== review.userId && (
                          <Button 
                            variant="ghost" 
                            size="sm"
                            className={`${review.userHasUpvoted ? 'text-blue-600' : 'text-gray-500'} hover:text-blue-700 hover:bg-blue-50`}
                            onClick={() => handleToggleUpvote(review.id, review.userHasUpvoted)}
                          >
                            <i className={`${review.userHasUpvoted ? 'fas' : 'far'} fa-thumbs-up mr-1`}></i>
                            {review.upvoteCount || 0}
                          </Button>
                        )}
                        
                        {/* If user is the review author, show upvote count without button */}
                        {user && user.id === review.userId && review.upvoteCount > 0 && (
                          <div className="text-gray-500 text-sm flex items-center">
                            <i className="fas fa-thumbs-up mr-1 text-blue-400"></i>
                            {review.upvoteCount}
                          </div>
                        )}
                        
                        {/* Admin delete button */}
                        {user?.isAdmin && (
                          <Button 
                            variant="ghost" 
                            size="sm"
                            className="text-red-500 hover:text-red-700 hover:bg-red-50"
                            onClick={() => handleDeleteReview(review.id)}
                          >
                            <i className="fas fa-trash-alt mr-1"></i>
                            Delete
                          </Button>
                        )}
                      </div>
                    </div>
                    <p className="text-gray-700">{review.review}</p>
                  </div>
                </div>
              ))}
            </div>
          ) : (
            <div className="text-center py-8 bg-gray-50 rounded-lg">
              <p className="text-gray-500 italic">No reviews yet. Be the first to share your thoughts!</p>
            </div>
          )}
          
          {showDetail.reviews && showDetail.reviews.length > 3 && (
            <Button variant="link" className="mt-4 text-primary-600 hover:text-primary-800">
              Show more reviews
            </Button>
          )}
        </div>
      </div>
      
      {/* Similar Shows Section */}
      <SimilarShows showId={id} />
      
      <div className="text-center text-xs text-gray-500 mt-8">
        © 2025 Sensory Screen Time Guide. All rights reserved.
      </div>
      
      {/* Share Modal */}
      {showDetail && (
        <ShareModal
          open={shareModalOpen}
          onOpenChange={setShareModalOpen}
          show={{
            id: showDetail.id,
            name: showDetail.name,
            imageUrl: showDetail.imageUrl || showDetail.omdb?.poster,
            stimulationScore: showDetail.stimulationScore || 3,
          }}
        />
      )}
    </main>
  );
}

// Similar Shows Component
function SimilarShows({ showId }: { showId: number }) {
  const { data: similarShows, isLoading, error } = useQuery<TvShow[]>({
    queryKey: [`/api/shows/${showId}/similar`],
    enabled: !!showId,
    refetchOnWindowFocus: false
  });
  
  const [isMobile, setIsMobile] = useState(false);
  
  // Check if device is mobile
  useEffect(() => {
    const checkIfMobile = () => {
      const mobileWidth = 768;
      const width = window.innerWidth;
      setIsMobile(width < mobileWidth);
    };
    
    // Check on mount
    checkIfMobile();
    
    // Add resize listener
    window.addEventListener('resize', checkIfMobile);
    
    // Clean up
    return () => window.removeEventListener('resize', checkIfMobile);
  }, []);
  
  const [_, setLocation] = useLocation();
  
  if (isLoading) {
    return (
      <div className="mt-8 bg-white rounded-md shadow p-6">
        <h2 className="text-xl font-bold text-gray-800 mb-4">You might also like...</h2>
        <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-4 gap-4">
          {[1, 2, 3, 4].map((i) => (
            <div key={i} className="rounded-md border border-gray-200 overflow-hidden">
              <Skeleton className="w-full h-40" />
              <div className="p-3">
                <Skeleton className="h-5 w-3/4 mb-2" />
                <Skeleton className="h-4 w-1/2" />
              </div>
            </div>
          ))}
        </div>
      </div>
    );
  }
  
  if (error) {
    console.error("Error loading similar shows:", error);
    return null;
  }
  
  if (!similarShows || similarShows.length === 0) {
    console.log("No similar shows found or data empty");
    // Show empty state instead of hiding completely
    return (
      <div className="mt-8 bg-white rounded-md shadow p-6">
        <h2 className="text-xl font-bold text-gray-800 mb-4">You might also like...</h2>
        <p className="text-center py-4 text-gray-500">No similar shows found for this title.</p>
      </div>
    );
  }
  
  // Handle navigation to show detail
  const navigateToShow = (showId: number) => {
    window.scrollTo(0, 0);
    setLocation(`/shows/${showId}`);
  };
  
  return (
    <div className="mt-8 bg-white rounded-md shadow p-6">
      <h2 className="text-xl font-bold text-gray-800 mb-4">You might also like...</h2>
      
      {isMobile ? (
        // Mobile carousel with portrait cards using ShowCard component
        <div className="relative">
          <Carousel
            opts={{
              align: "start",
              loop: true,
              dragFree: true,
              containScroll: "trimSnaps"
            }}
            className="w-full"
          >
            <CarouselContent className="-ml-2 md:-ml-4">
              {similarShows.map((show) => (
                <CarouselItem key={show.id} className="pl-2 md:pl-4 basis-1/2">
                  <ShowCard 
                    show={show} 
                    viewMode="grid" 
                    isMobile={true}
                    onClick={() => navigateToShow(show.id)} 
                  />
                </CarouselItem>
              ))}
            </CarouselContent>
            <div className="flex justify-center gap-2 mt-4">
              <CarouselPrevious className="static translate-y-0 mr-0" />
              <CarouselNext className="static translate-y-0" />
            </div>
          </Carousel>
        </div>
      ) : (
        // Desktop grid layout using the same ShowCard component as the browse page
        <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-4 gap-4">
          {similarShows.map((show) => (
            <ShowCard 
              key={show.id}
              show={show} 
              viewMode="grid" 
              onClick={() => navigateToShow(show.id)} 
            />
          ))}
        </div>
      )}
    </div>
  );
}
</file>

<file path="server/referral-system.ts">
import { db } from "./db";
import { userReferrals, users, userPointsHistory, referralClicks } from "@shared/schema";
import { eq, and, sql } from "drizzle-orm";

const REFERRAL_POINTS = 1; // Points awarded for clicking referral links

/**
 * Track a referral click and award points to the referrer
 * @param referrerId The ID of the user who shared the link
 * @param showId The ID of the show being shared
 * @param clickerIp The IP address of the person clicking
 * @param userAgent The user agent of the person clicking
 */
export async function trackReferralClick(referrerId: number, showId: number, clickerIp: string, userAgent?: string) {
  try {
    // Check if this IP has already clicked this referrer's link for this show
    const [existingClick] = await db
      .select()
      .from(referralClicks)
      .where(
        and(
          eq(referralClicks.referrerId, referrerId),
          eq(referralClicks.showId, showId),
          eq(referralClicks.clickerIp, clickerIp)
        )
      );
    
    if (existingClick) {
      console.log("Click already recorded for this IP");
      return { success: false, reason: "already_clicked" };
    }
    
    // Record the click
    const [click] = await db
      .insert(referralClicks)
      .values({
        referrerId,
        showId,
        clickerIp,
        clickerUserAgent: userAgent,
        pointsAwarded: true
      })
      .returning();
    
    if (!click) {
      console.error("Failed to record referral click");
      return { success: false, reason: "database_error" };
    }
    
    // Award points to the referrer only
    await awardClickPoints(referrerId);
    
    console.log(`Successfully recorded click and awarded ${REFERRAL_POINTS} points to user ${referrerId}`);
    return { success: true, pointsAwarded: REFERRAL_POINTS };
  } catch (error) {
    console.error("Error tracking referral click:", error);
    return { success: false, reason: "error" };
  }
}

/**
 * Track a referral when a user registers via a shared link
 * @param referrerId The ID of the user who shared the link
 * @param referredId The ID of the newly registered user
 */
export async function trackReferral(referrerId: string, referredId: string) {
  const referrerIdInt = parseInt(referrerId);
  const referredIdInt = parseInt(referredId);
  try {
    // Verify both users exist
    const [referrer] = await db.select().from(users).where(eq(users.id, referrerIdInt));
    const [referred] = await db.select().from(users).where(eq(users.id, referredIdInt));
    
    if (!referrer || !referred) {
      console.error("Referral failed: One or both users not found");
      return null;
    }
    
    // Check if this referral already exists
    const [existingReferral] = await db
      .select()
      .from(userReferrals)
      .where(
        and(
          eq(userReferrals.referrerId, referrerIdInt),
          eq(userReferrals.referredId, referredIdInt)
        )
      );
    
    if (existingReferral) {
      console.log("Referral already recorded");
      return existingReferral;
    }
    
    // Record the referral
    const [referral] = await db
      .insert(userReferrals)
      .values({
        referrerId: referrerIdInt,
        referredId: referredIdInt
      })
      .returning();
    
    if (!referral) {
      console.error("Failed to record referral");
      return null;
    }
    
    // Award points to both users
    await awardReferralPoints(referrerIdInt, referredIdInt);
    
    return referral;
  } catch (error) {
    console.error("Error tracking referral:", error);
    return null;
  }
}

/**
 * Award points to the referrer for a click
 */
async function awardClickPoints(referrerId: number) {
  try {
    await db.transaction(async (tx) => {
      // Add points to referrer's total using SQL expression
      await tx
        .update(users)
        .set({
          totalPoints: sql`${users.totalPoints} + ${REFERRAL_POINTS}`
        })
        .where(eq(users.id, referrerId));
      
      // Record points history for referrer
      await tx
        .insert(userPointsHistory)
        .values({
          userId: referrerId,
          points: REFERRAL_POINTS,
          activityType: "referral_click",
          description: "Points earned for someone clicking your shared link"
        });
    });
    
    console.log(`Successfully awarded ${REFERRAL_POINTS} points to user ${referrerId} for referral click`);
    return true;
  } catch (error) {
    console.error("Error awarding click points:", error);
    return false;
  }
}

/**
 * Award points to both the referrer and the referred user
 */
async function awardReferralPoints(referrerId: number, referredId: number) {
  try {
    // Award points to referrer
    await db.transaction(async (tx) => {
      // Add points to referrer's total using SQL expression
      await tx
        .update(users)
        .set({
          totalPoints: sql`${users.totalPoints} + ${REFERRAL_POINTS}`
        })
        .where(eq(users.id, referrerId));
      
      // Record points history for referrer
      await tx
        .insert(userPointsHistory)
        .values({
          userId: referrerId,
          points: REFERRAL_POINTS,
          activityType: "referral",
          description: "Points earned for referring a new user"
        });
      
      // Add points to referred user's total
      await tx
        .update(users)
        .set({
          totalPoints: sql`${users.totalPoints} + ${REFERRAL_POINTS}`
        })
        .where(eq(users.id, referredId));
      
      // Record points history for referred user
      await tx
        .insert(userPointsHistory)
        .values({
          userId: referredId,
          points: REFERRAL_POINTS,
          activityType: "signup",
          description: "Welcome bonus for signing up via referral"
        });
    });
    
    console.log(`Successfully awarded ${REFERRAL_POINTS} points to both users`);
    return true;
  } catch (error) {
    console.error("Error awarding referral points:", error);
    return false;
  }
}

/**
 * Get all referrals for a specific user
 */
export async function getUserReferrals(userId: string) {
  try {
    const referrals = await db
      .select({
        id: userReferrals.id,
        referredId: userReferrals.referredId,
        createdAt: userReferrals.createdAt,
        // Join to get referred user details
        referredUser: {
          username: users.username,
          profileImageUrl: users.profileImageUrl
        }
      })
      .from(userReferrals)
      .leftJoin(users, eq(userReferrals.referredId, users.id))
      .where(eq(userReferrals.referrerId, userId));
    
    return referrals;
  } catch (error) {
    console.error("Error getting user referrals:", error);
    return [];
  }
}
</file>

<file path="client/src/pages/about.tsx">
import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";
import { useEffect, useState } from "react";

export default function About() {
  const [iframeLoaded, setIframeLoaded] = useState(false);
  const [iframeError, setIframeError] = useState(false);

  // Load GHL form script
  useEffect(() => {
    const script = document.createElement('script');
    script.src = 'https://www.uschooler.com/js/form_embed.js';
    script.async = true;
    script.onerror = () => setIframeError(true);
    document.body.appendChild(script);

    // Set a timeout to show error if iframe doesn't load within 10 seconds
    const timeout = setTimeout(() => {
      if (!iframeLoaded) {
        setIframeError(true);
      }
    }, 10000);

    return () => {
      document.body.removeChild(script);
      clearTimeout(timeout);
    };
  }, [iframeLoaded]);
  return (
    <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
      <h1 className="text-3xl font-heading font-bold text-center mb-8">About TV Tantrum</h1>
      
      <div className="grid grid-cols-1 md:grid-cols-2 gap-8 mb-12">
        <div>
          <h2 className="text-2xl font-heading font-bold mb-4">Our Mission</h2>
          <p className="text-gray-700 mb-4">
            TV Tantrum was created to help parents make informed decisions about the children's TV shows their kids watch. We understand that screen time is inevitable, so why not make it count?
          </p>
          <p className="text-gray-700 mb-4">
            Our unique rating system focuses on metrics that matter to parents, including:
          </p>
          <ul className="list-disc pl-6 mb-4 text-gray-700 space-y-2">
            <li><span className="font-semibold">Stimulation Score</span> - Measure of how visually and audibly stimulating the content is.</li>
            <li><span className="font-semibold">Themes</span> - Understand what topics and concepts are covered in each show, from adventure and creativity to social-emotional learning and problem-solving.</li>
            <li><span className="font-semibold">Interactivity Level</span> - How engaging and interactive is the content for children?</li>
            <li><span className="font-semibold">Target Ages</span> - We inform you on what age group the show's content targets</li>
          </ul>
        </div>
        
        <div className="bg-primary-50 rounded-lg p-6">
          <h2 className="text-2xl font-heading font-bold mb-4">Data Sources</h2>
          <p className="text-gray-700 mb-4">
            Our comprehensive database aggregates ratings and information from:
          </p>
          <ul className="list-disc pl-6 mb-4 text-gray-700 space-y-2">
            <li>Content analysis by our proprietary stimulation measurement technology</li>
            <li>Parent surveys and reviews</li>
            <li>Child development expert assessments</li>
            <li>User contributions and feedback</li>
          </ul>
          <p className="text-gray-700">
            We're constantly updating our database as new shows emerge and more parents contribute their experiences. Any score could be subject to change as we improve the accuracy of our service.
          </p>
        </div>
      </div>
      
      <h2 className="text-2xl font-heading font-bold mb-6">How to Use Our Features</h2>
      
      <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6 mb-12">
        <Card>
          <CardContent className="pt-6">
            <div className="text-center mb-4">
              <div className="bg-primary-100 rounded-full w-16 h-16 flex items-center justify-center mx-auto mb-4">
                <i className="fas fa-search text-primary-600 text-2xl"></i>
              </div>
              <h3 className="text-xl font-heading font-bold mb-2">Browse</h3>
              <p className="text-gray-600">
                Explore our comprehensive database of children's TV shows with detailed ratings and reviews.
              </p>
            </div>
          </CardContent>
        </Card>
        
        <Card>
          <CardContent className="pt-6">
            <div className="text-center mb-4">
              <div className="bg-secondary-100 rounded-full w-16 h-16 flex items-center justify-center mx-auto mb-4">
                <i className="fas fa-filter text-secondary-600 text-2xl"></i>
              </div>
              <h3 className="text-xl font-heading font-bold mb-2">Filter</h3>
              <p className="text-gray-600">
                Narrow down shows by age appropriateness, stimulation score, themes, and more.
              </p>
            </div>
          </CardContent>
        </Card>
        
        <Card>
          <CardContent className="pt-6">
            <div className="text-center mb-4">
              <div className="bg-accent-100 rounded-full w-16 h-16 flex items-center justify-center mx-auto mb-4">
                <i className="fas fa-balance-scale text-accent-600 text-2xl"></i>
              </div>
              <h3 className="text-xl font-heading font-bold mb-2">Compare</h3>
              <p className="text-gray-600">
                Side-by-side comparison of shows to find the best fit for your family and child.
              </p>
            </div>
          </CardContent>
        </Card>
        
        <Card>
          <CardContent className="pt-6">
            <div className="text-center mb-4">
              <div className="bg-red-100 rounded-full w-16 h-16 flex items-center justify-center mx-auto mb-4">
                <i className="fas fa-heart text-red-500 text-2xl"></i>
              </div>
              <h3 className="text-xl font-heading font-bold mb-2">Save</h3>
              <p className="text-gray-600">
                Bookmark your favorite shows and create personalized lists for easy reference.
              </p>
            </div>
          </CardContent>
        </Card>
      </div>
      
      <h2 className="text-2xl font-heading font-bold mb-6">Understanding Stimulation Ratings</h2>
      
      <div className="bg-gray-50 rounded-lg p-8 mb-12">
        <p className="text-gray-700 mb-6">
          Our stimulation ratings help you understand how a show may affect your child's sensory system and behavior. Lower-rated shows allow for longer watching periods before causing overstimulation, while higher-rated shows may lead to overstimulation more quickly, potentially resulting in tantrums. Keep in mind that younger children are more sensitive to stimulation, while older children can typically handle higher levels of stimulation.
        </p>
        
        <div className="grid grid-cols-1 md:grid-cols-5 gap-4 mt-6">
          <div className="bg-green-100 rounded-lg p-4">
            <div className="flex items-center mb-2">
              <div className="w-8 h-8 rounded-full bg-green-500 flex items-center justify-center text-white font-bold">1</div>
              <h3 className="ml-2 text-lg font-bold text-green-800">Low</h3>
            </div>
            <p className="text-green-800">
              Gentle pacing with minimal scene changes. Soft sounds and music. Calm dialogue and predictable content. Ideal for very young children, bedtime viewing, or children sensitive to stimulation.
            </p>
          </div>
          
          <div className="bg-yellow-50 rounded-lg p-4">
            <div className="flex items-center mb-2">
              <div className="w-8 h-8 rounded-full bg-yellow-500 flex items-center justify-center text-white font-bold">2</div>
              <h3 className="ml-2 text-lg font-bold text-yellow-800">Low-Medium</h3>
            </div>
            <p className="text-yellow-800">
              Moderate pacing with occasional transitions. Mild sound effects and harmonious music. Engaging but not overwhelming content. Good for longer viewing sessions and younger children.
            </p>
          </div>
          
          <div className="bg-orange-50 rounded-lg p-4">
            <div className="flex items-center mb-2">
              <div className="w-8 h-8 rounded-full bg-orange-500 flex items-center justify-center text-white font-bold">3</div>
              <h3 className="ml-2 text-lg font-bold text-orange-800">Medium</h3>
            </div>
            <p className="text-orange-800">
              Balanced pacing with regular scene changes. Moderate sound effects and varied music. Mix of calm and exciting moments. Suitable for most children but monitor younger viewers for signs of overstimulation.
            </p>
          </div>
          
          <div className="bg-red-100 rounded-lg p-4">
            <div className="flex items-center mb-2">
              <div className="w-8 h-8 rounded-full bg-red-400 flex items-center justify-center text-white font-bold">4</div>
              <h3 className="ml-2 text-lg font-bold text-red-700">Medium-High</h3>
            </div>
            <p className="text-red-700">
              Fast-paced with frequent scene changes. Prominent sound effects and dynamic music. Energetic dialogue and action. Better for older children and shorter viewing sessions. May feel intense to younger viewers.
            </p>
          </div>
          
          <div className="bg-red-50 rounded-lg p-4">
            <div className="flex items-center mb-2">
              <div className="w-8 h-8 rounded-full bg-red-500 flex items-center justify-center text-white font-bold">5</div>
              <h3 className="ml-2 text-lg font-bold text-red-800">High</h3>
            </div>
            <p className="text-red-800">
              Rapid pacing with constant scene changes. Loud sound effects and intense music. Highly energetic content with many elements competing for attention. Use with caution.
            </p>
          </div>
        </div>
      </div>
      
      <div id="contact" className="bg-gray-50 rounded-lg p-8 mb-12">
        <h2 className="text-2xl font-heading font-bold mb-6 text-center">Contact Us</h2>
        <p className="text-gray-700 mb-6 text-center max-w-2xl mx-auto">
          Have a question, suggestion, or want to work with us? Use the form below to get in touch with our team.
        </p>
        
        <div className="max-w-xl mx-auto">
          <div className="min-h-[576px]">
            {!iframeError ? (
              <iframe
                src="https://www.uschooler.com/widget/form/6CGfRNsfQiXTbIQzwUtH"
                style={{width:'100%', height:'576px', border:'none', borderRadius:'3px'}}
                id="inline-6CGfRNsfQiXTbIQzwUtH" 
                data-layout="{'id':'INLINE'}"
                data-trigger-type="alwaysShow"
                data-trigger-value=""
                data-activation-type="alwaysActivated"
                data-activation-value=""
                data-deactivation-type="neverDeactivate"
                data-deactivation-value=""
                data-form-name="Tv Tantrum - Contact Us"
                data-height="576"
                data-layout-iframe-id="inline-6CGfRNsfQiXTbIQzwUtH"
                data-form-id="6CGfRNsfQiXTbIQzwUtH"
                title="Tv Tantrum - Contact Us"
                onLoad={() => setIframeLoaded(true)}
                onError={() => setIframeError(true)}
              />
            ) : (
              <div className="bg-white border border-gray-200 rounded-lg p-8 text-center">
                <h3 className="text-xl font-semibold mb-4">Get In Touch</h3>
                <p className="text-gray-600 mb-6">
                  We'd love to hear from you! Reach out to us through any of the following methods:
                </p>
                <div className="space-y-4">
                  <div>
                    <h4 className="font-semibold text-gray-800">Email</h4>
                    <p className="text-blue-600">hello@tvtantrum.com</p>
                  </div>
                  <div>
                    <h4 className="font-semibold text-gray-800">Social Media</h4>
                    <p className="text-gray-600">Follow us @tvtantrum on social platforms</p>
                  </div>
                  <Button 
                    onClick={() => setIframeError(false)} 
                    className="mt-4"
                  >
                    Try Loading Form Again
                  </Button>
                </div>
              </div>
            )}
          </div>
        </div>
      </div>
    </main>
  );
}
</file>

<file path="client/src/pages/auth-page-new.tsx">
import { useState, useEffect, useCallback } from "react";
import { useLocation } from "wouter";
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { useAuth } from "@/hooks/use-auth";
import { useToast } from "@/hooks/use-toast";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { Form, FormControl, FormDescription, FormField, FormItem, FormLabel, FormMessage } from "@/components/ui/form";
import { CheckCircle2, XCircle } from "lucide-react";
import { trackEvent } from "@/lib/analytics";

// Schema for login form
const loginSchema = z.object({
  identifier: z.string().min(3, "Please enter a valid email or username"),
  password: z.string().min(6, "Password must be at least 6 characters"),
});

// Schema for registration form with additional fields
const registerSchema = z.object({
  email: z.string().email("Please enter a valid email address"),
  username: z.string().min(3, "Username must be at least 3 characters"),
  password: z.string().min(6, "Password must be at least 6 characters"),
  confirmPassword: z.string().min(6, "Confirm password must be at least 6 characters"),
}).refine(data => data.password === data.confirmPassword, {
  message: "Passwords do not match",
  path: ["confirmPassword"],
});

type LoginFormValues = z.infer<typeof loginSchema>;
type RegisterFormValues = z.infer<typeof registerSchema>;

// Login form component
function LoginForm({ onSuccess }: { onSuccess: () => void }) {
  const { loginMutation } = useAuth();
  const { toast } = useToast();
  const [, navigate] = useLocation();

  const form = useForm<LoginFormValues>({
    resolver: zodResolver(loginSchema),
    defaultValues: {
      identifier: "",
      password: "",
    },
  });

  const onSubmit = (data: LoginFormValues) => {
    loginMutation.mutate(data, {
      onSuccess: () => {
        // Track successful login event
        trackEvent('login', 'user', 'login_success');
        
        toast({
          title: "Login successful!",
          description: "Welcome back to TV Tantrum",
        });
        onSuccess();
      },
    });
  };

  return (
    <Card>
      <CardHeader>
        <CardTitle>Login to your account</CardTitle>
        <CardDescription>
          Enter your credentials to access your account
        </CardDescription>
      </CardHeader>
      <CardContent className="space-y-4">
        <Form {...form}>
          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
            <FormField
              control={form.control}
              name="identifier"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Email or Username</FormLabel>
                  <FormControl>
                    <Input 
                      type="text"
                      placeholder="Enter your email or username"
                      {...field}
                      disabled={loginMutation.isPending}
                    />
                  </FormControl>
                  <p className="text-xs text-muted-foreground">Note: Usernames are case-sensitive</p>
                  <FormMessage />
                </FormItem>
              )}
            />
            
            <FormField
              control={form.control}
              name="password"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Password</FormLabel>
                  <FormControl>
                    <Input 
                      type="password" 
                      placeholder="Enter your password"
                      {...field}
                      disabled={loginMutation.isPending}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />
            
            <Button 
              type="submit" 
              className="w-full"
              disabled={loginMutation.isPending}
            >
              {loginMutation.isPending ? "Logging in..." : "Login"}
            </Button>
          </form>
        </Form>
      </CardContent>
    </Card>
  );
}

// GHL Registration form component
function RegisterForm({ 
  onSuccess,
  earlyAccessToken
}: { 
  onSuccess: () => void; 
  earlyAccessToken: string | null;
}) {
  const { toast } = useToast();
  const [, navigate] = useLocation();

  useEffect(() => {
    // Listen for GHL form completion
    const handleMessage = (event: MessageEvent) => {
      if (event.origin !== window.location.origin) return;
      
      if (event.data.type === 'GHL_FORM_COMPLETED') {
        // Store the email for the complete registration page
        if (event.data.email) {
          localStorage.setItem('ghl_user_email', event.data.email);
        }
        
        toast({
          title: "Email Verification Sent!",
          description: "Please check your email and click the verification link to continue registration.",
        });
        
        // Redirect to complete registration page after a short delay
        setTimeout(() => {
          const email = event.data.email || localStorage.getItem('ghl_user_email');
          if (email) {
            navigate(`/complete-registration?email=${encodeURIComponent(email)}`);
          } else {
            navigate('/complete-registration');
          }
        }, 2000);
      }
    };

    window.addEventListener('message', handleMessage);
    return () => window.removeEventListener('message', handleMessage);
  }, [toast, navigate]);

  return (
    <Card>
      <CardHeader>
        <CardTitle>Create an account</CardTitle>
        <CardDescription>
          Register to save your favorite shows and more
        </CardDescription>
      </CardHeader>
      <CardContent className="space-y-4">
        <div className="text-center space-y-4">
          <p className="text-sm text-muted-foreground">
            Fill out the form below to get started. After email verification, you'll create your username and password.
          </p>
          
          {/* Go High Level Form Embed */}
          <div className="w-full min-h-[632px] border rounded-lg">
            <iframe
              src="https://api.leadconnectorhq.com/widget/form/k1oNtk7bxZaBfdLXDkek"
              className="w-full h-[632px] border-0 rounded-lg"
              id="inline-k1oNtk7bxZaBfdLXDkek" 
              data-layout="{'id':'INLINE'}"
              data-trigger-type="alwaysShow"
              data-trigger-value=""
              data-activation-type="alwaysActivated"
              data-activation-value=""
              data-deactivation-type="neverDeactivate"
              data-deactivation-value=""
              data-form-name="Registration form"
              data-height="632"
              data-layout-iframe-id="inline-k1oNtk7bxZaBfdLXDkek"
              data-form-id="k1oNtk7bxZaBfdLXDkek"
              title="Registration form"
            />
          </div>
          <script src="https://link.msgsndr.com/js/form_embed.js"></script>
          
          <div className="text-xs text-muted-foreground">
            <p>By registering, you agree to our terms of service and privacy policy.</p>
            <p className="mt-2">After email verification, you'll be redirected to complete your account setup.</p>
          </div>
        </div>
      </CardContent>
    </Card>
  );
}

export default function AuthPage() {
  const [activeTab, setActiveTab] = useState<string>("login");
  const [, navigate] = useLocation();
  const { user } = useAuth();
  const [isCheckingStoredAuth, setIsCheckingStoredAuth] = useState(true);
  const [earlyAccessToken, setEarlyAccessToken] = useState<string | null>(null);
  
  // Handle successful authentication
  const handleAuthSuccess = useCallback(() => {
    if (user) {
      const redirectPath = user.isAdmin ? "/admin" : user.isApproved ? "/home" : "/registration-pending";
      navigate(redirectPath);
    }
  }, [navigate, user]);

  // Check if there's authentication on page load - rely on server session only
  useEffect(() => {
    // Skip localStorage checking, rely on server session
    setIsCheckingStoredAuth(false);
    
    // Check for URL parameters
    const params = new URLSearchParams(window.location.search);
    const urlToken = params.get('token');
    const tabParam = params.get('tab');
    
    // Handle tab parameter for direct navigation
    if (tabParam === 'login') {
      setActiveTab('login');
    } else if (tabParam === 'register') {
      setActiveTab('register');
    }
    
    // Check for early access token from URL
    if (urlToken) {
      setEarlyAccessToken(urlToken);
      localStorage.setItem("earlyAccessToken", urlToken);
      
      // Switch to register tab when token is present (unless tab param overrides)
      if (urlToken === "2025" && !tabParam) {
        setActiveTab("register");
      }
    } else {
      // Read token from localStorage if not in URL
      const storedToken = localStorage.getItem("earlyAccessToken");
      if (storedToken) {
        setEarlyAccessToken(storedToken);
        
        // Switch to register tab when token is present and valid (unless tab param overrides)
        if (storedToken === "2025" && !tabParam) {
          setActiveTab("register");
        }
      }
    }
  }, []);
  
  // Check if user is already logged in
  useEffect(() => {
    // If we're done checking auth and have a user, redirect
    if (!isCheckingStoredAuth && user) {
      handleAuthSuccess();
    }
  }, [user, isCheckingStoredAuth, handleAuthSuccess]);
  
  // If still checking stored auth, show loading
  if (isCheckingStoredAuth) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-primary mx-auto"></div>
          <p className="mt-4 text-lg">Checking authentication...</p>
        </div>
      </div>
    );
  }
  
  // If we have user data, redirect (handled by useEffect)
  if (user) {
    const redirectPath = user.isAdmin ? "/admin" : user.isApproved ? "/home" : "/registration-pending";
    navigate(redirectPath);
    return null;
  }

  return (
    <div className="flex items-center justify-center min-h-screen bg-background">
      <div className="w-full max-w-5xl p-4 md:p-8 flex flex-col md:flex-row gap-8">
        {/* Auth forms column */}
        <div className="w-full md:w-1/2">
          <Tabs value={activeTab} onValueChange={setActiveTab} className="w-full">
            <TabsList className="grid w-full grid-cols-2">
              <TabsTrigger value="login">Login</TabsTrigger>
              <TabsTrigger value="register">Register</TabsTrigger>
            </TabsList>
            <TabsContent value="login">
              <LoginForm onSuccess={handleAuthSuccess} />
              <div className="text-sm text-muted-foreground mt-4 text-center">
                Don't have an account?{" "}
                <Button 
                  variant="link" 
                  className="p-0 h-auto" 
                  onClick={() => setActiveTab("register")}
                >
                  Register
                </Button>
              </div>
            </TabsContent>
            <TabsContent value="register">
              <RegisterForm 
                onSuccess={handleAuthSuccess} 
                earlyAccessToken={earlyAccessToken} 
              />
              <div className="text-sm text-muted-foreground mt-4 text-center">
                Already have an account?{" "}
                <Button 
                  variant="link" 
                  className="p-0 h-auto" 
                  onClick={() => setActiveTab("login")}
                >
                  Login
                </Button>
              </div>
            </TabsContent>
          </Tabs>
        </div>
        
        {/* Hero content column */}
        <div className="w-full md:w-1/2 flex flex-col justify-center space-y-4">
          <h1 className="text-3xl md:text-4xl font-bold text-primary">
            TV Tantrum
          </h1>
          <p className="text-xl text-muted-foreground">
            The ultimate guide for parents to understand the stimulation level of children's TV shows
          </p>
          
          <div className="space-y-4">
            <div>
              <h3 className="font-semibold text-lg mb-2">Non-Registered Users Can:</h3>
              <div className="space-y-2">
                <div className="flex items-start space-x-2">
                  <CheckCircle2 className="h-5 w-5 text-green-500 mt-1" />
                  <p>Browse and search all TV shows</p>
                </div>
                <div className="flex items-start space-x-2">
                  <CheckCircle2 className="h-5 w-5 text-green-500 mt-1" />
                  <p>View stimulation scores and details</p>
                </div>
                <div className="flex items-start space-x-2">
                  <CheckCircle2 className="h-5 w-5 text-green-500 mt-1" />
                  <p>Compare shows side-by-side</p>
                </div>
                <div className="flex items-start space-x-2">
                  <CheckCircle2 className="h-5 w-5 text-green-500 mt-1" />
                  <p>See reviews</p>
                </div>
              </div>
            </div>
            
            <div>
              <h3 className="font-semibold text-lg mb-2">(FREE) Registered Users Can:</h3>
              <div className="space-y-2">
                <div className="flex items-start space-x-2">
                  <CheckCircle2 className="h-5 w-5 text-primary mt-1" />
                  <p>Get personalized recommendations</p>
                </div>
                <div className="flex items-start space-x-2">
                  <CheckCircle2 className="h-5 w-5 text-primary mt-1" />
                  <p>Submit new shows for analysis</p>
                </div>
                <div className="flex items-start space-x-2">
                  <CheckCircle2 className="h-5 w-5 text-primary mt-1" />
                  <p>Access research summaries</p>
                </div>
                <div className="flex items-start space-x-2">
                  <CheckCircle2 className="h-5 w-5 text-primary mt-1" />
                  <p>Leave reviews</p>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="client/src/pages/complete-registration.tsx">
import { useState, useEffect } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { Button } from "@/components/ui/button";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Loader2, CheckCircle } from "lucide-react";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { useToast } from "@/hooks/use-toast";
import { apiRequest } from "@/lib/queryClient";
import { useLocation } from "wouter";
import { useAuth } from "@/hooks/use-auth";

// Top user countries first, then alphabetical
const topCountries = [
  { name: "United Kingdom", code: "GB" },
  { name: "United States", code: "US" },
  { name: "Australia", code: "AU" },
  { name: "Canada", code: "CA" },
];

const otherCountries = [
  { name: "Afghanistan", code: "AF" },
  { name: "Åland Islands", code: "AX" },
  { name: "Albania", code: "AL" },
  { name: "Algeria", code: "DZ" },
  { name: "American Samoa", code: "AS" },
  { name: "Andorra", code: "AD" },
  { name: "Angola", code: "AO" },
  { name: "Anguilla", code: "AI" },
  { name: "Antarctica", code: "AQ" },
  { name: "Antigua and Barbuda", code: "AG" },
  { name: "Argentina", code: "AR" },
  { name: "Armenia", code: "AM" },
  { name: "Aruba", code: "AW" },
  { name: "Austria", code: "AT" },
  { name: "Azerbaijan", code: "AZ" },
  { name: "Bahamas", code: "BS" },
  { name: "Bahrain", code: "BH" },
  { name: "Bangladesh", code: "BD" },
  { name: "Barbados", code: "BB" },
  { name: "Belarus", code: "BY" },
  { name: "Belgium", code: "BE" },
  { name: "Belize", code: "BZ" },
  { name: "Benin", code: "BJ" },
  { name: "Bermuda", code: "BM" },
  { name: "Bhutan", code: "BT" },
  { name: "Bolivia", code: "BO" },
  { name: "Bosnia and Herzegovina", code: "BA" },
  { name: "Botswana", code: "BW" },
  { name: "Bouvet Island", code: "BV" },
  { name: "Brazil", code: "BR" },
  { name: "British Indian Ocean Territory", code: "IO" },
  { name: "Brunei Darussalam", code: "BN" },
  { name: "Bulgaria", code: "BG" },
  { name: "Burkina Faso", code: "BF" },
  { name: "Burundi", code: "BI" },
  { name: "Cambodia", code: "KH" },
  { name: "Cameroon", code: "CM" },
  { name: "Cape Verde", code: "CV" },
  { name: "Cayman Islands", code: "KY" },
  { name: "Central African Republic", code: "CF" },
  { name: "Chad", code: "TD" },
  { name: "Chile", code: "CL" },
  { name: "China", code: "CN" },
  { name: "Christmas Island", code: "CX" },
  { name: "Cocos (Keeling) Islands", code: "CC" },
  { name: "Colombia", code: "CO" },
  { name: "Comoros", code: "KM" },
  { name: "Congo", code: "CG" },
  { name: "Congo, The Democratic Republic of the", code: "CD" },
  { name: "Cook Islands", code: "CK" },
  { name: "Costa Rica", code: "CR" },
  { name: "Cote D'Ivoire", code: "CI" },
  { name: "Croatia", code: "HR" },
  { name: "Cuba", code: "CU" },
  { name: "Cyprus", code: "CY" },
  { name: "Czech Republic", code: "CZ" },
  { name: "Denmark", code: "DK" },
  { name: "Djibouti", code: "DJ" },
  { name: "Dominica", code: "DM" },
  { name: "Dominican Republic", code: "DO" },
  { name: "Ecuador", code: "EC" },
  { name: "Egypt", code: "EG" },
  { name: "El Salvador", code: "SV" },
  { name: "Equatorial Guinea", code: "GQ" },
  { name: "Eritrea", code: "ER" },
  { name: "Estonia", code: "EE" },
  { name: "Ethiopia", code: "ET" },
  { name: "Falkland Islands (Malvinas)", code: "FK" },
  { name: "Faroe Islands", code: "FO" },
  { name: "Fiji", code: "FJ" },
  { name: "Finland", code: "FI" },
  { name: "France", code: "FR" },
  { name: "French Guiana", code: "GF" },
  { name: "French Polynesia", code: "PF" },
  { name: "French Southern Territories", code: "TF" },
  { name: "Gabon", code: "GA" },
  { name: "Gambia", code: "GM" },
  { name: "Georgia", code: "GE" },
  { name: "Germany", code: "DE" },
  { name: "Ghana", code: "GH" },
  { name: "Gibraltar", code: "GI" },
  { name: "Greece", code: "GR" },
  { name: "Greenland", code: "GL" },
  { name: "Grenada", code: "GD" },
  { name: "Guadeloupe", code: "GP" },
  { name: "Guam", code: "GU" },
  { name: "Guatemala", code: "GT" },
  { name: "Guernsey", code: "GG" },
  { name: "Guinea", code: "GN" },
  { name: "Guinea-Bissau", code: "GW" },
  { name: "Guyana", code: "GY" },
  { name: "Haiti", code: "HT" },
  { name: "Heard Island and Mcdonald Islands", code: "HM" },
  { name: "Holy See (Vatican City State)", code: "VA" },
  { name: "Honduras", code: "HN" },
  { name: "Hong Kong", code: "HK" },
  { name: "Hungary", code: "HU" },
  { name: "Iceland", code: "IS" },
  { name: "India", code: "IN" },
  { name: "Indonesia", code: "ID" },
  { name: "Iran, Islamic Republic Of", code: "IR" },
  { name: "Iraq", code: "IQ" },
  { name: "Ireland", code: "IE" },
  { name: "Isle of Man", code: "IM" },
  { name: "Israel", code: "IL" },
  { name: "Italy", code: "IT" },
  { name: "Jamaica", code: "JM" },
  { name: "Japan", code: "JP" },
  { name: "Jersey", code: "JE" },
  { name: "Jordan", code: "JO" },
  { name: "Kazakhstan", code: "KZ" },
  { name: "Kenya", code: "KE" },
  { name: "Kiribati", code: "KI" },
  { name: "Korea, Democratic People'S Republic of", code: "KP" },
  { name: "Korea, Republic of", code: "KR" },
  { name: "Kuwait", code: "KW" },
  { name: "Kyrgyzstan", code: "KG" },
  { name: "Lao People'S Democratic Republic", code: "LA" },
  { name: "Latvia", code: "LV" },
  { name: "Lebanon", code: "LB" },
  { name: "Lesotho", code: "LS" },
  { name: "Liberia", code: "LR" },
  { name: "Libyan Arab Jamahiriya", code: "LY" },
  { name: "Liechtenstein", code: "LI" },
  { name: "Lithuania", code: "LT" },
  { name: "Luxembourg", code: "LU" },
  { name: "Macao", code: "MO" },
  { name: "Macedonia, The Former Yugoslav Republic of", code: "MK" },
  { name: "Madagascar", code: "MG" },
  { name: "Malawi", code: "MW" },
  { name: "Malaysia", code: "MY" },
  { name: "Maldives", code: "MV" },
  { name: "Mali", code: "ML" },
  { name: "Malta", code: "MT" },
  { name: "Marshall Islands", code: "MH" },
  { name: "Martinique", code: "MQ" },
  { name: "Mauritania", code: "MR" },
  { name: "Mauritius", code: "MU" },
  { name: "Mayotte", code: "YT" },
  { name: "Mexico", code: "MX" },
  { name: "Micronesia, Federated States of", code: "FM" },
  { name: "Moldova, Republic of", code: "MD" },
  { name: "Monaco", code: "MC" },
  { name: "Mongolia", code: "MN" },
  { name: "Montserrat", code: "MS" },
  { name: "Morocco", code: "MA" },
  { name: "Mozambique", code: "MZ" },
  { name: "Myanmar", code: "MM" },
  { name: "Namibia", code: "NA" },
  { name: "Nauru", code: "NR" },
  { name: "Nepal", code: "NP" },
  { name: "Netherlands", code: "NL" },
  { name: "Netherlands Antilles", code: "AN" },
  { name: "New Caledonia", code: "NC" },
  { name: "New Zealand", code: "NZ" },
  { name: "Nicaragua", code: "NI" },
  { name: "Niger", code: "NE" },
  { name: "Nigeria", code: "NG" },
  { name: "Niue", code: "NU" },
  { name: "Norfolk Island", code: "NF" },
  { name: "Northern Mariana Islands", code: "MP" },
  { name: "Norway", code: "NO" },
  { name: "Oman", code: "OM" },
  { name: "Pakistan", code: "PK" },
  { name: "Palau", code: "PW" },
  { name: "Palestinian Territory, Occupied", code: "PS" },
  { name: "Panama", code: "PA" },
  { name: "Papua New Guinea", code: "PG" },
  { name: "Paraguay", code: "PY" },
  { name: "Peru", code: "PE" },
  { name: "Philippines", code: "PH" },
  { name: "Pitcairn", code: "PN" },
  { name: "Poland", code: "PL" },
  { name: "Portugal", code: "PT" },
  { name: "Puerto Rico", code: "PR" },
  { name: "Qatar", code: "QA" },
  { name: "Reunion", code: "RE" },
  { name: "Romania", code: "RO" },
  { name: "Russian Federation", code: "RU" },
  { name: "Rwanda", code: "RW" },
  { name: "Saint Helena", code: "SH" },
  { name: "Saint Kitts and Nevis", code: "KN" },
  { name: "Saint Lucia", code: "LC" },
  { name: "Saint Pierre and Miquelon", code: "PM" },
  { name: "Saint Vincent and the Grenadines", code: "VC" },
  { name: "Samoa", code: "WS" },
  { name: "San Marino", code: "SM" },
  { name: "Sao Tome and Principe", code: "ST" },
  { name: "Saudi Arabia", code: "SA" },
  { name: "Senegal", code: "SN" },
  { name: "Serbia and Montenegro", code: "CS" },
  { name: "Seychelles", code: "SC" },
  { name: "Sierra Leone", code: "SL" },
  { name: "Singapore", code: "SG" },
  { name: "Slovakia", code: "SK" },
  { name: "Slovenia", code: "SI" },
  { name: "Solomon Islands", code: "SB" },
  { name: "Somalia", code: "SO" },
  { name: "South Africa", code: "ZA" },
  { name: "South Georgia and the South Sandwich Islands", code: "GS" },
  { name: "Spain", code: "ES" },
  { name: "Sri Lanka", code: "LK" },
  { name: "Sudan", code: "SD" },
  { name: "Suriname", code: "SR" },
  { name: "Svalbard and Jan Mayen", code: "SJ" },
  { name: "Swaziland", code: "SZ" },
  { name: "Sweden", code: "SE" },
  { name: "Switzerland", code: "CH" },
  { name: "Syrian Arab Republic", code: "SY" },
  { name: "Taiwan, Province of China", code: "TW" },
  { name: "Tajikistan", code: "TJ" },
  { name: "Tanzania, United Republic of", code: "TZ" },
  { name: "Thailand", code: "TH" },
  { name: "Timor-Leste", code: "TL" },
  { name: "Togo", code: "TG" },
  { name: "Tokelau", code: "TK" },
  { name: "Tonga", code: "TO" },
  { name: "Trinidad and Tobago", code: "TT" },
  { name: "Tunisia", code: "TN" },
  { name: "Turkey", code: "TR" },
  { name: "Turkmenistan", code: "TM" },
  { name: "Turks and Caicos Islands", code: "TC" },
  { name: "Tuvalu", code: "TV" },
  { name: "Uganda", code: "UG" },
  { name: "Ukraine", code: "UA" },
  { name: "United Arab Emirates", code: "AE" },
  { name: "United States Minor Outlying Islands", code: "UM" },
  { name: "Uruguay", code: "UY" },
  { name: "Uzbekistan", code: "UZ" },
  { name: "Vanuatu", code: "VU" },
  { name: "Venezuela", code: "VE" },
  { name: "Vietnam", code: "VN" },
  { name: "Virgin Islands, British", code: "VG" },
  { name: "Virgin Islands, U.S.", code: "VI" },
  { name: "Wallis and Futuna", code: "WF" },
  { name: "Western Sahara", code: "EH" },
  { name: "Yemen", code: "YE" },
  { name: "Zambia", code: "ZM" },
  { name: "Zimbabwe", code: "ZW" }
];

// Combine top countries first, then other countries
const countries = [...topCountries, ...otherCountries];

const completeRegistrationSchema = z.object({
  email: z.string().email("Please enter a valid email address"),
  username: z.string().min(3, "Username must be at least 3 characters"),
  password: z.string().min(6, "Password must be at least 6 characters"),
  confirmPassword: z.string(),
  country: z.string().min(1, "Please select your country"),
}).refine((data) => data.password === data.confirmPassword, {
  message: "Passwords don't match",
  path: ["confirmPassword"],
});

type CompleteRegistrationForm = z.infer<typeof completeRegistrationSchema>;

export default function CompleteRegistration() {
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [isComplete, setIsComplete] = useState(false);
  const [usernameStatus, setUsernameStatus] = useState<'idle' | 'checking' | 'available' | 'taken' | 'invalid'>('idle');
  const [usernameCheckTimeout, setUsernameCheckTimeout] = useState<NodeJS.Timeout | null>(null);
  const { toast } = useToast();
  const [, setLocation] = useLocation();
  const { loginMutation } = useAuth();

  // Function to get email from URL parameters or localStorage
  const getPrefilledEmail = () => {
    // Check URL parameters first
    const urlParams = new URLSearchParams(window.location.search);
    const emailFromUrl = urlParams.get('email');
    if (emailFromUrl) {
      return emailFromUrl;
    }

    // Check localStorage for GHL form data
    const ghlEmail = localStorage.getItem('ghl_user_email');
    if (ghlEmail) {
      return ghlEmail;
    }

    return "";
  };

  const form = useForm<CompleteRegistrationForm>({
    resolver: zodResolver(completeRegistrationSchema),
    defaultValues: {
      email: getPrefilledEmail(),
      username: "",
      password: "",
      confirmPassword: "",
      country: "",
    },
  });

  // Function to check username availability
  const checkUsernameAvailability = async (username: string) => {
    if (username.length < 3) {
      setUsernameStatus('invalid');
      return;
    }

    setUsernameStatus('checking');
    
    try {
      const response = await fetch(`/api/check-username?username=${encodeURIComponent(username)}`);
      const data = await response.json();
      
      if (response.ok) {
        setUsernameStatus(data.available ? 'available' : 'taken');
      } else {
        setUsernameStatus('idle');
      }
    } catch (error) {
      console.error('Error checking username:', error);
      setUsernameStatus('idle');
    }
  };

  // Debounced username checker
  const handleUsernameChange = (username: string) => {
    // Clear existing timeout
    if (usernameCheckTimeout) {
      clearTimeout(usernameCheckTimeout);
    }

    // Reset status if username is empty
    if (!username.trim()) {
      setUsernameStatus('idle');
      return;
    }

    // Set new timeout
    const timeout = setTimeout(() => {
      checkUsernameAvailability(username);
    }, 500); // Wait 500ms after user stops typing

    setUsernameCheckTimeout(timeout);
  };

  // Update form when component mounts or URL changes
  useEffect(() => {
    const prefilledEmail = getPrefilledEmail();
    if (prefilledEmail && prefilledEmail !== form.getValues('email')) {
      form.setValue('email', prefilledEmail);
    }
  }, [form]);

  // Cleanup timeout on unmount
  useEffect(() => {
    return () => {
      if (usernameCheckTimeout) {
        clearTimeout(usernameCheckTimeout);
      }
    };
  }, [usernameCheckTimeout]);

  const onSubmit = async (data: CompleteRegistrationForm) => {
    setIsSubmitting(true);
    
    try {
      const response = await apiRequest("POST", "/api/complete-registration", {
        email: data.email,
        username: data.username,
        password: data.password,
        country: data.country,
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Registration failed');
      }

      setIsComplete(true);
      toast({
        title: "Registration Completed!",
        description: "Your account has been created successfully. Logging you in...",
      });

      // Automatically log the user in with their new credentials
      loginMutation.mutate({
        identifier: data.username, // Use username for login
        password: data.password
      }, {
        onSuccess: () => {
          toast({
            title: "Welcome to TV Tantrum!",
            description: "You've been automatically logged in.",
          });
          // Redirect to home page after successful login
          setTimeout(() => {
            setLocation("/home");
          }, 1500);
        },
        onError: () => {
          // If auto-login fails, redirect to login page
          toast({
            title: "Registration successful!",
            description: "Please log in with your new credentials.",
          });
          setTimeout(() => {
            setLocation("/auth?tab=login");
          }, 2000);
        }
      });

    } catch (error: any) {
      console.error("Registration completion error:", error);
      toast({
        title: "Registration Failed",
        description: error.message || "Unable to complete registration. Please try again.",
        variant: "destructive",
      });
    } finally {
      setIsSubmitting(false);
    }
  };

  if (isComplete) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-background px-4">
        <Card className="w-full max-w-md">
          <CardHeader className="text-center">
            <div className="mx-auto mb-4 flex h-12 w-12 items-center justify-center rounded-full bg-green-100">
              <CheckCircle className="h-6 w-6 text-green-600" />
            </div>
            <CardTitle className="text-2xl font-bold text-green-600">Welcome to TV Tantrum!</CardTitle>
            <CardDescription>
              Your account has been created successfully. Redirecting you to sign in...
            </CardDescription>
          </CardHeader>
        </Card>
      </div>
    );
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-background px-4">
      <Card className="w-full max-w-md">
        <CardHeader>
          <CardTitle className="text-2xl font-bold text-center">Complete Your Registration</CardTitle>
          <CardDescription className="text-center">
            Your email has been verified! Now create your username and password to access TV Tantrum.
          </CardDescription>
        </CardHeader>
        <CardContent>
          <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
              <FormField
                control={form.control}
                name="email"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Email Address</FormLabel>
                    <FormControl>
                      <Input 
                        type="email" 
                        placeholder="Enter your verified email" 
                        {...field} 
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="username"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Username</FormLabel>
                    <FormControl>
                      <div className="relative">
                        <Input 
                          placeholder="Choose a unique username" 
                          {...field}
                          onChange={(e) => {
                            field.onChange(e);
                            handleUsernameChange(e.target.value);
                          }}
                          className={`pr-10 ${
                            usernameStatus === 'available' ? 'border-green-500' :
                            usernameStatus === 'taken' ? 'border-red-500' :
                            usernameStatus === 'invalid' ? 'border-yellow-500' :
                            ''
                          }`}
                        />
                        <div className="absolute inset-y-0 right-0 flex items-center pr-3">
                          {usernameStatus === 'checking' && (
                            <Loader2 className="h-4 w-4 animate-spin text-muted-foreground" />
                          )}
                          {usernameStatus === 'available' && (
                            <CheckCircle className="h-4 w-4 text-green-500" />
                          )}
                          {usernameStatus === 'taken' && (
                            <span className="text-red-500 text-xs font-medium">✗</span>
                          )}
                          {usernameStatus === 'invalid' && (
                            <span className="text-yellow-500 text-xs font-medium">!</span>
                          )}
                        </div>
                      </div>
                    </FormControl>
                    <div className="space-y-1">
                      {usernameStatus === 'available' && (
                        <p className="text-xs text-green-600">✓ Username is available</p>
                      )}
                      {usernameStatus === 'taken' && (
                        <p className="text-xs text-red-600">Username is already taken</p>
                      )}
                      {usernameStatus === 'invalid' && (
                        <p className="text-xs text-yellow-600">Username must be at least 3 characters</p>
                      )}
                      {usernameStatus === 'checking' && (
                        <p className="text-xs text-muted-foreground">Checking availability...</p>
                      )}
                      <p className="text-xs text-muted-foreground">Note: Usernames are case-sensitive</p>
                    </div>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="password"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Password</FormLabel>
                    <FormControl>
                      <Input 
                        type="password" 
                        placeholder="Create a secure password" 
                        {...field} 
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="confirmPassword"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Confirm Password</FormLabel>
                    <FormControl>
                      <Input 
                        type="password" 
                        placeholder="Confirm your password" 
                        {...field} 
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="country"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Country</FormLabel>
                    <Select 
                      onValueChange={field.onChange} 
                      defaultValue={field.value}
                    >
                      <FormControl>
                        <SelectTrigger>
                          <SelectValue placeholder="Select your country" />
                        </SelectTrigger>
                      </FormControl>
                      <SelectContent className="max-h-60">
                        {countries.map((country) => (
                          <SelectItem key={country.code} value={country.name}>
                            {country.name}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <Button 
                type="submit" 
                className="w-full" 
                disabled={isSubmitting}
              >
                {isSubmitting && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
                Complete Registration
              </Button>
            </form>
          </Form>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="client/src/pages/user-dashboard.tsx">
import React, { useState, useRef } from 'react';
import { useQuery, useQueryClient, useMutation } from '@tanstack/react-query';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Progress } from '@/components/ui/progress';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import { Badge } from '@/components/ui/badge';
import { Skeleton } from '@/components/ui/skeleton';
import { formatDistanceToNow } from 'date-fns';
import { Award, Star as StarIcon, Trophy, Timer, LineChart, Flame, Users, Calendar as CalendarIcon, Send, Share, UserPlus, FilePlus2, BookOpen, Heart, X, Camera, Upload, Palette } from 'lucide-react';
import { useAuth } from '@/hooks/use-auth';
import { Button } from '@/components/ui/button';
import { useToast } from '@/hooks/use-toast';
import ShowCard from '@/components/ShowCard';
import { useLocation } from 'wouter';
import { apiRequest } from '@/lib/queryClient';
import ChangePasswordForm from '@/components/ChangePasswordForm';

// Badge progression system
const BADGE_PROGRESSION = [
  { name: "TV Watcher", emoji: "📺", points: 0 }, // Default badge
  { name: "Tablet Baby", emoji: "👶", points: 25 },
  { name: "TV Tamer", emoji: "🧑‍🧒", points: 50 },
  { name: "Algorithm Avoider", emoji: "🫷", points: 100 },
  { name: "Mood-Swing Mediator", emoji: "🧑‍⚖️", points: 200 },
  { name: "Rhythm Regulator", emoji: "🪪", points: 300 },
  { name: "Pixel Protector", emoji: "🥽", points: 400 },
  { name: "Screen-Time Sherpa", emoji: "🤝", points: 500 },
  { name: "Programme Peacekeeper", emoji: "✌️", points: 750 },
  { name: "Calm-Ware Engineer", emoji: "🧑‍🔧", points: 1000 },
  { name: "Digital Diplomat", emoji: "🧑‍💼", points: 1250 },
  { name: "Sensory Sentinel", emoji: "🦾", points: 1500 },
  { name: "Guardian of the Glow", emoji: "🥷", points: 1750 },
  { name: "Screen Sensei", emoji: "🧘", points: 2000 }
];

// Background color options
const BACKGROUND_COLORS = [
  { name: "Purple", value: "bg-purple-500", preview: "#8b5cf6" },
  { name: "Blue", value: "bg-blue-500", preview: "#3b82f6" },
  { name: "Green", value: "bg-green-500", preview: "#10b981" },
  { name: "Orange", value: "bg-orange-500", preview: "#f97316" },
  { name: "Pink", value: "bg-pink-500", preview: "#ec4899" },
  { name: "Red", value: "bg-red-500", preview: "#ef4444" },
  { name: "Yellow", value: "bg-yellow-500", preview: "#eab308" },
  { name: "Indigo", value: "bg-indigo-500", preview: "#6366f1" },
  { name: "Teal", value: "bg-teal-500", preview: "#14b8a6" },
  { name: "Gray", value: "bg-gray-600", preview: "#4b5563" }
];

// Helper function to get current badge based on points
const getCurrentBadge = (points: number) => {
  const sorted = [...BADGE_PROGRESSION].reverse();
  return sorted.find(badge => points >= badge.points) || BADGE_PROGRESSION[0];
};

// Helper function to get next badge
const getNextBadge = (points: number) => {
  return BADGE_PROGRESSION.find(badge => points < badge.points);
};

const UserDashboard = () => {
  const { user, toggleFavorite, isLoading: isAuthLoading } = useAuth();
  const [activeTab, setActiveTab] = useState('overview');
  const queryClient = useQueryClient();
  const { toast } = useToast();
  const [showColorPicker, setShowColorPicker] = useState(false);
  const [selectedBackgroundColor, setSelectedBackgroundColor] = useState('bg-purple-500');

  // Background color update mutation
  const updateBackgroundColorMutation = useMutation({
    mutationFn: async (backgroundColor: string) => {
      console.log('=== Frontend Debug ===');
      console.log('Updating background color to:', backgroundColor);
      console.log('Making API request...');
      
      const response = await fetch('/api/user/background-color', {
        method: 'PUT',
        body: JSON.stringify({ backgroundColor }),
        headers: { 
          'Content-Type': 'application/json',
        },
        credentials: 'include' // Include cookies for session authentication
      });
      
      console.log('Response status:', response.status);
      console.log('Response headers:', Object.fromEntries(response.headers.entries()));
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        console.log('Error response:', errorData);
        throw new Error(errorData.message || 'Failed to update background color');
      }
      
      const result = await response.json();
      console.log('Success response:', result);
      return result;
    },
    onSuccess: (data) => {
      toast({
        title: "Background color updated!",
        description: "Your profile background color has been changed.",
      });
      
      // Refresh dashboard data to show the updated background color
      queryClient.invalidateQueries({ queryKey: ['/api/user/dashboard'] });
    },
    onError: () => {
      toast({
        title: "Update failed",
        description: "Failed to update background color. Please try again.",
        variant: "destructive",
      });
    },
  });

  const { data: dashboardData, isLoading: isLoadingDashboard, error: dashboardError } = useQuery({
    queryKey: ['/api/user/dashboard'],
    enabled: !!user,
  });
  
  // Debug logging to understand what's happening with dashboard data
  console.log('Dashboard query state:', {
    user: !!user,
    dashboardData,
    isLoadingDashboard,
    dashboardError,
    userEnabled: !!user
  });
  
  // Extract data from dashboard response
  const userRank = dashboardData?.rank || "TV Watcher";
  const totalPoints = dashboardData?.points || 0;
  const pointsBreakdown = dashboardData?.pointsBreakdown || {};
  const pointsHistory = dashboardData?.pointsHistory || [];
  const recommendations = dashboardData?.recommendedShows || [];
  // Removed login streak since we're using login rewards instead
  const readResearch = dashboardData?.readResearch || [];
  const topUsers = dashboardData?.topUsers || [];
  const recentActivity = dashboardData?.recentActivity || [];
  
  // Get current and next badge based on points
  const currentBadge = getCurrentBadge(totalPoints);
  const nextBadge = getNextBadge(totalPoints);
  
  // Calculate progress to next badge
  const nextMilestone = nextBadge ? nextBadge.points : 2000;
  const prevMilestone = currentBadge.points;
  const progress = nextBadge ? 
    ((totalPoints - prevMilestone) / (nextMilestone - prevMilestone)) * 100 : 
    100;
  
  // Get user's background color preference from dashboard data
  const dashboardUser = dashboardData?.user;
  const userBackgroundColor = dashboardUser?.background_color || dashboardUser?.backgroundColor || 'bg-purple-500';

  // Show loading state while authentication or dashboard data is loading
  if (isAuthLoading || isLoadingDashboard) {
    return (
      <div className="container max-w-4xl py-8">
        <div className="text-center mb-6">
          <h2 className="text-2xl font-bold mb-2">Loading Dashboard</h2>
          <p className="text-gray-500">Please wait while we gather your latest activity and points...</p>
        </div>
        <div className="space-y-4">
          <Skeleton className="h-12 w-[250px]" />
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
            <Skeleton className="h-[200px] w-full" />
            <Skeleton className="h-[200px] w-full" />
            <Skeleton className="h-[200px] w-full" />
          </div>
          <Skeleton className="h-[400px] w-full" />
        </div>
      </div>
    );
  }
  
  // Only show login prompt if auth is definitely finished loading and user is not authenticated
  if (!isAuthLoading && !user) {
    return (
      <div className="container max-w-4xl py-8">
        <div className="text-center py-12">
          <h2 className="text-2xl font-bold mb-2">Please Log In</h2>
          <p className="text-gray-500">You need to be logged in to view your dashboard.</p>
        </div>
      </div>
    );
  }

  const {
    user: userData,
    favorites,
    reviews
  } = dashboardData || {
    user: {},
    favorites: [],
    reviews: []
  };

  return (
    <div className="container max-w-4xl py-8 px-4 md:px-6">
      <div className="flex flex-col md:flex-row gap-6 md:items-center mb-8">
        <div className="relative group">
          {/* Emoji Badge Avatar */}
          <div className={`w-20 h-20 rounded-full flex items-center justify-center text-3xl ${userBackgroundColor} relative`}>
            {currentBadge.emoji}
            
            {/* Background Color Picker Overlay */}
            <div className="absolute inset-0 bg-black bg-opacity-50 rounded-full flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity cursor-pointer">
              <Button
                variant="ghost"
                size="sm"
                className="text-white hover:text-white hover:bg-transparent p-1"
                onClick={() => setShowColorPicker(!showColorPicker)}
              >
                <Palette className="w-5 h-5" />
              </Button>
            </div>
          </div>
          
          {/* Color Picker Dropdown */}
          {showColorPicker && (
            <Card className="absolute top-full left-0 mt-2 p-4 z-50 min-w-[200px]">
              <CardHeader className="pb-2">
                <CardTitle className="text-sm">Choose Background Color</CardTitle>
              </CardHeader>
              <CardContent className="p-0">
                <div className="grid grid-cols-5 gap-2">
                  {BACKGROUND_COLORS.map((color) => (
                    <button
                      key={color.value}
                      className={`w-8 h-8 rounded-full border-2 ${color.value} ${
                        userBackgroundColor === color.value ? 'border-gray-800 scale-110' : 'border-gray-300'
                      } transition-all hover:scale-105`}
                      onClick={() => {
                        updateBackgroundColorMutation.mutate(color.value);
                        setShowColorPicker(false); // Close the picker after selection
                      }}
                      disabled={updateBackgroundColorMutation.isPending}
                      title={color.name}
                    />
                  ))}
                </div>
              </CardContent>
            </Card>
          )}
        </div>
        
        <div className="flex-1">
          <h1 className="text-3xl font-bold">{user?.username || "User"}'s Dashboard</h1>
          <p className="text-gray-500">{user?.email}</p>
          <div className="flex items-center gap-2 mt-1">
            <Badge variant="outline" className="bg-orange-50 text-orange-500 border-orange-200">
              <Trophy className="w-3 h-3 mr-1" /> {currentBadge.name}
            </Badge>
            <Badge variant="outline" className="bg-blue-50 text-blue-500 border-blue-200">
              <Award className="w-3 h-3 mr-1" /> {totalPoints} Points
            </Badge>
          </div>
          
          {/* Customize Background Button - Mobile */}
          <div className="md:hidden mt-3">
            <Button
              variant="outline"
              size="sm"
              onClick={() => setShowColorPicker(!showColorPicker)}
              className="w-full"
            >
              <Palette className="w-4 h-4 mr-2" />
              Customize Background
            </Button>
          </div>
        </div>
      </div>

      {/* Progress to next badge */}
      <Card className="mb-8">
        <CardHeader className="pb-2">
          <CardTitle className="text-lg">Progress to Next Badge</CardTitle>
          <CardDescription>
            {nextBadge ? (
              <>
                {totalPoints} / {nextMilestone} points to unlock{' '}
                <span className="font-semibold">{nextBadge.name} {nextBadge.emoji}</span>
              </>
            ) : (
              <>Congratulations! You've reached the highest badge: {currentBadge.name} {currentBadge.emoji}</>
            )}
          </CardDescription>
        </CardHeader>
        <CardContent>
          <Progress value={progress} className="h-2" />
          <div className="mt-2 text-sm text-gray-500">
            {nextBadge ? (
              <>Earn {nextMilestone - totalPoints} more points to unlock the next badge!</>
            ) : (
              <>You've mastered all badges! Keep earning points to maintain your Screen Sensei status.</>
            )}
          </div>
        </CardContent>
      </Card>

      <Tabs defaultValue="overview" value={activeTab} onValueChange={setActiveTab} className="mb-8">
        <TabsList className="grid grid-cols-2 sm:grid-cols-4 gap-1 mb-8 h-auto p-1">
          <TabsTrigger value="overview" className="text-xs sm:text-sm px-2 py-2">Overview</TabsTrigger>
          <TabsTrigger value="activity" className="text-xs sm:text-sm px-2 py-2">Activity</TabsTrigger>
          <TabsTrigger value="content" className="text-xs sm:text-sm px-2 py-2">Your Content</TabsTrigger>
          <TabsTrigger value="settings" className="text-xs sm:text-sm px-2 py-2">Account Settings</TabsTrigger>
        </TabsList>

        <TabsContent value="overview" className="space-y-6">
          <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4">
            <Card>
              <CardHeader className="pb-2">
                <CardTitle className="text-sm font-medium">Reviews</CardTitle>
              </CardHeader>
              <CardContent>
                <div className="text-2xl font-bold">{reviews?.length || 0}</div>
                <p className="text-xs text-gray-500 mt-1">
                  {pointsBreakdown.reviews} Points Earned
                </p>
              </CardContent>
            </Card>

            <Card>
              <CardHeader className="pb-2">
                <CardTitle className="text-sm font-medium">Upvotes Received</CardTitle>
              </CardHeader>
              <CardContent>
                <div className="text-2xl font-bold">
                  {pointsHistory?.filter((ph: any) => ph.activityType === 'upvote_received').length || 0}
                </div>
                <p className="text-xs text-gray-500 mt-1">
                  {pointsBreakdown.upvotesReceived} Points Earned
                </p>
              </CardContent>
            </Card>

            <Card>
              <CardHeader className="pb-2">
                <CardTitle className="text-sm font-medium">Research Read</CardTitle>
              </CardHeader>
              <CardContent>
                <div className="text-2xl font-bold">{readResearch?.length || 0}</div>
                <p className="text-xs text-gray-500 mt-1">
                  {pointsBreakdown.researchRead} Points Earned
                </p>
              </CardContent>
            </Card>
          </div>

          <Card>
            <CardHeader>
              <CardTitle>Points Breakdown</CardTitle>
              <CardDescription>How you've earned your points</CardDescription>
            </CardHeader>
            <CardContent>
              <div className="space-y-4">
                <div className="flex items-center justify-between">
                  <div className="flex items-center">
                    <StarIcon className="w-4 h-4 mr-2 text-yellow-500" />
                    <span>Reviews</span>
                  </div>
                  <span className="font-medium">{pointsBreakdown.reviews} points</span>
                </div>

                <div className="flex items-center justify-between">
                  <div className="flex items-center">
                    <Award className="w-4 h-4 mr-2 text-purple-500" />
                    <span>Upvotes Received</span>
                  </div>
                  <span className="font-medium">{pointsBreakdown.upvotesReceived} points</span>
                </div>

                <div className="flex items-center justify-between">
                  <div className="flex items-center">
                    <LineChart className="w-4 h-4 mr-2 text-blue-500" />
                    <span>Upvotes Given</span>
                  </div>
                  <span className="font-medium">{pointsBreakdown.upvotesGiven} points</span>
                </div>

                {/* Removed login streaks since we're using login rewards instead */}

                <div className="flex items-center justify-between">
                  <div className="flex items-center">
                    <Timer className="w-4 h-4 mr-2 text-cyan-500" />
                    <span>Login Rewards</span>
                  </div>
                  <span className="font-medium">{pointsBreakdown.loginRewards || 0} points</span>
                </div>

                {/* Shares section removed - points only awarded for successful referrals */}

                <div className="flex items-center justify-between">
                  <div className="flex items-center">
                    <UserPlus className="w-4 h-4 mr-2 text-pink-500" />
                    <span>Referral Clicks</span>
                  </div>
                  <span className="font-medium">{pointsBreakdown.referrals} points</span>
                </div>

                <div className="flex items-center justify-between">
                  <div className="flex items-center">
                    <FilePlus2 className="w-4 h-4 mr-2 text-orange-500" />
                    <span>Show Submissions</span>
                  </div>
                  <span className="font-medium">{pointsBreakdown.showSubmissions} points</span>
                </div>

                <div className="flex items-center justify-between">
                  <div className="flex items-center">
                    <BookOpen className="w-4 h-4 mr-2 text-teal-500" />
                    <span>Research Read</span>
                  </div>
                  <span className="font-medium">{pointsBreakdown.researchRead} points</span>
                </div>

                <div className="pt-4 mt-4 border-t border-gray-100 flex items-center justify-between font-bold">
                  <span>Total Points</span>
                  <span>{totalPoints} points</span>
                </div>
              </div>
            </CardContent>
          </Card>
        </TabsContent>

        <TabsContent value="activity" className="space-y-6">
          <Card>
            <CardHeader>
              <CardTitle>Recent Activity</CardTitle>
              <CardDescription>Your latest actions on TV Tantrum</CardDescription>
            </CardHeader>
            <CardContent>
              {(reviews?.length > 0 || pointsHistory?.length > 0) ? (
                <div className="space-y-4">
                  {/* Create a combined array of all activities */}
                  {(() => {
                    // Convert reviews to a standard format matching activities
                    const reviewActivities = reviews.map((review: any) => ({
                      id: `review-${review.id}`,
                      type: 'review',
                      review,
                      description: `Review of ${review.showName || review.tvShowName || "TV Show"}`,
                      points: 10,
                      createdAt: new Date(review.createdAt),
                      activityType: 'review'
                    }));
                    
                    // Convert points history records
                    const otherActivities = pointsHistory
                      .filter((activity: any) => activity.activityType !== 'review') // Skip reviews as we handle them above
                      .map((activity: any) => ({
                        id: `activity-${activity.id}`,
                        type: 'pointsHistory',
                        activity,
                        description: activity.description || formatActivityType(activity.activityType),
                        points: activity.points,
                        createdAt: new Date(activity.createdAt),
                        activityType: activity.activityType
                      }));
                    
                    // Combine and sort all activities by date (newest first)
                    const allActivities = [...reviewActivities, ...otherActivities]
                      .sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());
                    
                    // Return the sorted activities as JSX
                    return allActivities.map((item) => (
                      <div key={item.id} className="flex items-start gap-4 pb-4 border-b border-gray-100 last:border-b-0 last:pb-0">
                        <div className="bg-gray-100 p-2 rounded-full">
                          {item.activityType === 'review' && <StarIcon className="w-4 h-4 text-yellow-500" />}
                          {item.activityType === 'upvote_given' && <LineChart className="w-4 h-4 text-blue-500" />}
                          {item.activityType === 'upvote_received' && <Award className="w-4 h-4 text-purple-500" />}
                          {item.activityType === 'login_streak' && <CalendarIcon className="w-4 h-4 text-green-500" />}
                          {item.activityType === 'login_reward' && <Timer className="w-4 h-4 text-cyan-500" />}
                          {/* Show icon for historical share activities, though they no longer earn points */}
                          {item.activityType === 'share' && <Send className="w-4 h-4 text-gray-400" />}
                          {item.activityType === 'referral' && <UserPlus className="w-4 h-4 text-pink-500" />}
                          {item.activityType === 'show_submission' && <FilePlus2 className="w-4 h-4 text-orange-500" />}
                          {item.activityType === 'research_read' && <BookOpen className="w-4 h-4 text-teal-500" />}
                          {item.activityType === 'favorite_added' && <Heart className="w-4 h-4 text-red-500" />}
                          {item.activityType === 'points_deducted' && <X className="w-4 h-4 text-red-500" />}
                          {/* Check description for favorite activities */}
                          {item.description && item.description.includes('to favorites') && <Heart className="w-4 h-4 text-red-500" />}
                        </div>
                        <div className="flex-1">
                          <div className="flex justify-between">
                            <p className="font-medium">
                              {item.description}
                            </p>
                            <Badge variant="outline">{item.points > 0 ? `+${item.points}` : item.points} points</Badge>
                          </div>
                          <p className="text-sm text-gray-500">
                            {formatDistanceToNow(item.createdAt, { addSuffix: true })}
                          </p>
                        </div>
                      </div>
                    ));
                  })()}
                </div>
              ) : (
                <div className="text-center py-6 text-gray-500">
                  <p>No activity yet. Start interacting with TV Tantrum to earn points!</p>
                </div>
              )}
            </CardContent>
          </Card>
        </TabsContent>

        <TabsContent value="content" className="space-y-6">
          <Card>
            <CardHeader>
              <CardTitle>Your Reviews</CardTitle>
              <CardDescription>Reviews you've written for TV shows</CardDescription>
            </CardHeader>
            <CardContent>
              {reviews?.length > 0 ? (
                <div className="space-y-4">
                  {reviews.map((review: any) => (
                    <div key={review.id} className="p-4 border border-gray-200 rounded-lg">
                      <div className="flex justify-between items-start mb-2">
                        <h3 className="font-medium">{review.showName || review.tvShowName || "TV Show"}</h3>
                        <div className="flex items-center">
                          {[...Array(5)].map((_, i) => (
                            <StarIcon
                              key={i}
                              className={`w-4 h-4 ${
                                i < review.rating ? "text-yellow-400 fill-yellow-400" : "text-gray-300"
                              }`}
                            />
                          ))}
                        </div>
                      </div>
                      <p className="text-sm text-gray-600">{review.review}</p>
                      <div className="mt-2 text-xs text-gray-500">
                        {formatDistanceToNow(new Date(review.createdAt), { addSuffix: true })}
                      </div>
                    </div>
                  ))}
                </div>
              ) : (
                <div className="text-center py-6 text-gray-500">
                  <p>You haven't written any reviews yet.</p>
                </div>
              )}
            </CardContent>
          </Card>

          <Card>
            <CardHeader>
              <CardTitle>Your Favorites</CardTitle>
              <CardDescription>TV shows you've added to your favorites</CardDescription>
            </CardHeader>
            <CardContent>
              {favorites?.length > 0 ? (
                <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-3">
                  {favorites.map((show: any) => (
                    <div key={show.id} className="rounded-lg">
                      <ShowCard 
                        show={show} 
                        viewMode="grid" 
                        onClick={() => {
                          // Navigate to show details
                          window.location.href = `/show/${show.id}`;
                        }}
                        isMobile={true}
                      />
                    </div>
                  ))}
                </div>
              ) : (
                <div className="text-center py-6 text-gray-500">
                  <p>You haven't added any favorites yet.</p>
                </div>
              )}
            </CardContent>
          </Card>
        </TabsContent>

        <TabsContent value="settings" className="space-y-6">
          <Card>
            <CardHeader>
              <CardTitle>Account Settings</CardTitle>
              <CardDescription>
                Manage your account preferences and security settings
              </CardDescription>
            </CardHeader>
            <CardContent>
              <ChangePasswordForm />
            </CardContent>
          </Card>
        </TabsContent>
      </Tabs>
    </div>
  );
};

// Helper function to format activity types for display
function formatActivityType(type: string): string {
  const formats: Record<string, string> = {
    review: "Added a review",
    upvote_given: "Upvoted a review",
    upvote_received: "Received an upvote",
    login_streak: "Login streak bonus",
    share: "Shared content",
    referral: "Referred a new user",
    show_submission: "Submitted a new show",
    research_read: "Read research content"
  };
  
  return formats[type] || type.replace(/_/g, " ");
}

export default UserDashboard;
</file>

<file path="server/services/searchService.ts">
import { Pool } from 'pg';
import { pool } from '../db';

/**
 * Search service for TV shows
 * This service handles all search-related functionality
 * and database operations for TV shows
 */
export class SearchService {
  private pool: Pool;
  
  constructor(dbPool: Pool) {
    this.pool = dbPool;
  }
  
  /**
   * Search for TV shows by name or description
   * @param searchTerm The search term to look for
   * @returns Array of TV shows matching the search term
   */
  async searchShows(searchTerm: string) {
    if (!searchTerm || !searchTerm.trim()) {
      return [];
    }
    
    const client = await this.pool.connect();
    
    try {
      // Simple, reliable SQL search with no ORM complexity
      const result = await client.query(
        `SELECT * FROM tv_shows 
         WHERE name ILIKE $1 OR description ILIKE $1
         ORDER BY name ASC`,
        [`%${searchTerm.trim()}%`]
      );
      
      // Normalize the field names to match the frontend expectations
      return result.rows.map(row => ({
        id: row.id,
        name: row.name,
        description: row.description,
        ageRange: row.age_range || '',
        stimulationScore: row.stimulation_score || 0,
        themes: row.themes || [],
        imageUrl: row.image_url,
        network: row.network,
        releaseYear: row.release_year,
        endYear: row.end_year,
        isOngoing: row.is_ongoing,
        seasons: row.seasons,
        availableOn: row.available_on || [],
        interactionLevel: row.interaction_level,
        dialogueIntensity: row.dialogue_intensity,
        soundFrequency: row.sound_frequency,
        episodeLength: row.episode_length || 0,
        creator: row.creator,
        creativityRating: row.creativity_rating,
        subscriberCount: row.subscriber_count,
        videoCount: row.video_count,
        channelId: row.channel_id,
        isYouTubeChannel: row.is_youtube_channel || false,
        publishedAt: row.published_at,
        hasOmdbData: row.has_omdb_data || false,
        hasYoutubeData: row.has_youtube_data || false
      }));
    } finally {
      client.release();
    }
  }
  
  /**
   * Track a search hit in the background
   * @param showId The ID of the show that was found in search
   */
  async trackSearchHit(showId: number) {
    if (!showId) return;
    
    // Run this in the background so it doesn't block the main thread
    setTimeout(async () => {
      try {
        const trackingClient = await this.pool.connect();
        
        try {
          await trackingClient.query(
            `INSERT INTO tv_show_searches (tv_show_id, search_count, last_searched) 
             VALUES ($1, 1, NOW()) 
             ON CONFLICT (tv_show_id) 
             DO UPDATE SET 
               search_count = tv_show_searches.search_count + 1, 
               last_searched = NOW()`, 
            [showId]
          );
        } finally {
          trackingClient.release();
        }
      } catch (e) {
        // Silently ignore any errors in tracking
        console.error('Search tracking error (non-blocking):', e);
      }
    }, 0);
  }
  
  /**
   * Perform a filtered search based on multiple criteria
   * @param filters The filter criteria
   * @returns Array of TV shows matching the filters
   */
  async searchWithFilters(filters: any) {
    const client = await this.pool.connect();
    
    try {
      console.log('Filter query detected:', filters);
      
      // Base query that safely handles all filter combinations
      let query = `SELECT * FROM tv_shows WHERE 1=1`;
      const params: any[] = [];
      let paramIndex = 1;
      
      // Add search filter if present
      if (filters.search) {
        query += ` AND (name ILIKE $${paramIndex} OR description ILIKE $${paramIndex})`;
        params.push(`%${filters.search}%`);
        paramIndex++;
      }
      
      // Age range filter - filter shows that overlap with the requested age range
      if (filters.ageRangeMin !== undefined && filters.ageRangeMax !== undefined) {
        console.log(`Age range filter applied: ${filters.ageRangeMin}-${filters.ageRangeMax}`);
        
        query += ` AND (
          -- Handle exact matches like "0-2", "3-5", etc.
          (age_range ~ '^[0-9]+-[0-9]+$' AND 
           CAST(SPLIT_PART(age_range, '-', 1) AS INTEGER) <= $${paramIndex + 1} AND 
           CAST(SPLIT_PART(age_range, '-', 2) AS INTEGER) >= $${paramIndex})
          
          -- Handle ranges with "+" like "13+"
          OR (age_range ~ '^[0-9]+\\+$' AND 
              CAST(REGEXP_REPLACE(age_range, '[^0-9]', '', 'g') AS INTEGER) <= $${paramIndex + 1})
          
          -- Handle "Any Age" or similar broad categories
          OR (age_range ILIKE '%any%' OR age_range ILIKE '%all%')
        )`;
        
        params.push(filters.ageRangeMin, filters.ageRangeMax);
        paramIndex += 2;
      }
      
      // Stimulation score range filter
      if (filters.stimulationScoreRange) {
        const range = typeof filters.stimulationScoreRange === 'string' 
          ? JSON.parse(filters.stimulationScoreRange) 
          : filters.stimulationScoreRange;
        console.log('Stimulation score range filter applied:', range);
        query += ` AND stimulation_score >= $${paramIndex} AND stimulation_score <= $${paramIndex + 1}`;
        params.push(range.min, range.max);
        paramIndex += 2;
      }
      
      // Interaction level filter (updated field name)
      if (filters.interactionLevel && filters.interactionLevel !== 'Any') {
        console.log('Filtering by interaction level:', filters.interactionLevel);
        
        if (filters.interactionLevel === 'High') {
          query += ` AND (interactivity_level = $${paramIndex} OR interactivity_level ILIKE $${paramIndex + 1} OR interactivity_level ILIKE $${paramIndex + 2})`;
          params.push('High', '%High%', '%to High%');
          paramIndex += 3;
        } else {
          query += ` AND interactivity_level = $${paramIndex}`;
          params.push(filters.interactionLevel);
          paramIndex++;
        }
      }
      
      if (filters.dialogueIntensity) {
        query += ` AND dialogue_intensity = $${paramIndex}`;
        params.push(filters.dialogueIntensity);
        paramIndex++;
      }
      
      if (filters.soundFrequency) {
        query += ` AND sound_frequency = $${paramIndex}`;
        params.push(filters.soundFrequency);
        paramIndex++;
      }
      
      // Sort filter - apply appropriate sorting
      if (filters.sortBy) {
        switch (filters.sortBy) {
          case 'name':
            query += ` ORDER BY LOWER(name) ASC`;
            break;
          case 'newest':
            query += ` ORDER BY release_year DESC NULLS LAST`;
            break;
          case 'oldest':
            query += ` ORDER BY release_year ASC NULLS LAST`;
            break;
          case 'stimulation-score':
            query += ` ORDER BY stimulation_score ASC NULLS LAST`;
            break;
          case 'interactivity-level':
            query += ` ORDER BY interactivity_level DESC NULLS LAST`;
            break;
          case 'popular':
            // For popularity-based sorting, we'll handle this post-query
            query += ` ORDER BY LOWER(name) ASC`;
            break;
          case 'rating':
          case 'rating_desc':
          case 'overall-rating':
            // For rating-based sorting, we'll handle this post-query
            query += ` ORDER BY LOWER(name) ASC`;
            break;
          default:
            query += ` ORDER BY LOWER(name) ASC`;
        }
      } else {
        // Default sort
        query += ` ORDER BY LOWER(name) ASC`;
      }
      
      // Execute the query
      const result = await client.query(query, params);
      
      console.log(`Interaction level filter returned ${result.rows.length} shows`);
      
      // Process the results for theme filtering if necessary
      let shows = result.rows;
      
      // Handle popularity-based sorting (post-query with view and search data)
      if (filters.sortBy === 'popular') {
        console.log(`Search Service: Starting popularity-based sorting`);
        try {
          // Get view statistics for all shows
          const viewStats = await client.query(`
            SELECT tv_show_id, view_count FROM tv_show_views
          `);
          
          // Get search statistics for all shows
          const searchStats = await client.query(`
            SELECT tv_show_id, search_count FROM tv_show_searches
          `);
          
          console.log(`Search Service: Found ${viewStats.rows.length} shows with views, ${searchStats.rows.length} shows with searches`);
          
          // Create maps for popularity data
          const viewMap = new Map();
          const searchMap = new Map();
          
          viewStats.rows.forEach(row => {
            viewMap.set(row.tv_show_id, parseInt(row.view_count) || 0);
          });
          
          searchStats.rows.forEach(row => {
            searchMap.set(row.tv_show_id, parseInt(row.search_count) || 0);
          });
          
          // Sort shows by popularity score (views * 2 + searches)
          shows.sort((a, b) => {
            const aViews = viewMap.get(a.id) || 0;
            const aSearches = searchMap.get(a.id) || 0;
            const aPopularity = (aViews * 2) + aSearches; // Weight views more heavily
            
            const bViews = viewMap.get(b.id) || 0;
            const bSearches = searchMap.get(b.id) || 0;
            const bPopularity = (bViews * 2) + bSearches;
            
            return bPopularity - aPopularity; // Descending order (highest first)
          });
          
          console.log(`Search Service: Applied popularity-based sorting to ${shows.length} shows`);
          // Log the first few shows after sorting
          const topShows = shows.slice(0, 5).map(show => {
            const views = viewMap.get(show.id) || 0;
            const searches = searchMap.get(show.id) || 0;
            const popularity = (views * 2) + searches;
            return `${show.name} (${views} views, ${searches} searches, score: ${popularity})`;
          });
          console.log(`Search Service: Top 5 popular shows: ${topShows.join(', ')}`);
        } catch (error) {
          console.error('Search Service: Error applying popularity-based sorting:', error);
          // Continue with default sorting if popularity sort fails
        }
      }
      
      // Handle rating-based sorting (post-query with review data)
      if (filters.sortBy === 'rating' || filters.sortBy === 'rating_desc' || filters.sortBy === 'overall-rating') {
        console.log(`Search Service: Starting rating-based sorting for sortBy: ${filters.sortBy}`);
        try {
          // Get review statistics for all shows
          const reviewStats = await client.query(`
            SELECT 
              tv_show_id,
              AVG(rating) as avg_rating,
              COUNT(rating) as review_count
            FROM tv_show_reviews 
            GROUP BY tv_show_id
          `);
          
          console.log(`Search Service: Found ${reviewStats.rows.length} shows with reviews`);
          
          // Create a map of show ratings
          const ratingMap = new Map();
          reviewStats.rows.forEach(row => {
            const avgRating = parseFloat(row.avg_rating) || 0;
            const reviewCount = parseInt(row.review_count) || 0;
            ratingMap.set(row.tv_show_id, {
              avgRating,
              reviewCount
            });
            console.log(`Search Service: Show ID ${row.tv_show_id}: ${avgRating} stars (${reviewCount} reviews)`);
          });
          
          // Sort shows by rating (highest first)
          shows.sort((a, b) => {
            const aStats = ratingMap.get(a.id) || { avgRating: 0, reviewCount: 0 };
            const bStats = ratingMap.get(b.id) || { avgRating: 0, reviewCount: 0 };
            
            // Sort by average rating first, then by review count as tiebreaker
            if (bStats.avgRating !== aStats.avgRating) {
              return bStats.avgRating - aStats.avgRating;
            }
            return bStats.reviewCount - aStats.reviewCount;
          });
          
          console.log(`Search Service: Applied rating-based sorting to ${shows.length} shows`);
          // Log the first few shows after sorting
          const topShows = shows.slice(0, 5).map(show => {
            const stats = ratingMap.get(show.id) || { avgRating: 0, reviewCount: 0 };
            return `${show.name} (${stats.avgRating} stars, ${stats.reviewCount} reviews)`;
          });
          console.log(`Search Service: Top 5 shows after rating sort: ${topShows.join(', ')}`);
        } catch (error) {
          console.error('Search Service: Error applying rating-based sorting:', error);
          // Continue with default sorting if rating sort fails
        }
      }
      
      // Handle theme filtering (post-query for better control)
      if (filters.themes && filters.themes.length > 0) {
        const themeMatchMode = ('themeMatchMode' in filters) ? (filters.themeMatchMode || 'AND') : 'AND';
        const searchThemes = Array.isArray(filters.themes) 
          ? filters.themes.map((theme: string) => theme.trim())
          : [filters.themes.trim()];
          
        if (themeMatchMode === 'AND') {
          // All themes must match
          shows = shows.filter((show: any) => {
            const showThemes = show.themes || [];
            return searchThemes.every((theme: string) => {
              return showThemes.some((showTheme: string) => 
                showTheme.toLowerCase() === theme.toLowerCase()
              );
            });
          });
        } else {
          // Any of the themes can match (OR)
          shows = shows.filter((show: any) => {
            const showThemes = show.themes || [];
            return searchThemes.some((theme: string) => {
              return showThemes.some((showTheme: string) => 
                showTheme.toLowerCase() === theme.toLowerCase()
              );
            });
          });
        }
      }
      
      // Normalize the field names to match the frontend expectations (same as search function)
      return shows.map(row => ({
        id: row.id,
        name: row.name,
        description: row.description,
        ageRange: row.age_range || '',
        stimulationScore: row.stimulation_score || 0,
        themes: row.themes || [],
        imageUrl: row.image_url,
        network: row.network,
        releaseYear: row.release_year,
        endYear: row.end_year,
        isOngoing: row.is_ongoing,
        seasons: row.seasons,
        availableOn: row.available_on || [],
        interactionLevel: row.interaction_level,
        dialogueIntensity: row.dialogue_intensity,
        soundFrequency: row.sound_frequency,
        episodeLength: row.episode_length || 0,
        creator: row.creator,
        creativityRating: row.creativity_rating,
        subscriberCount: row.subscriber_count,
        videoCount: row.video_count,
        channelId: row.channel_id,
        isYouTubeChannel: row.is_youtube_channel || false,
        publishedAt: row.published_at,
        hasOmdbData: row.has_omdb_data || false,
        hasYoutubeData: row.has_youtube_data || false
      }));
    } finally {
      client.release();
    }
  }
}

// Create and export a singleton instance
export const searchService = new SearchService(pool);
</file>

<file path="shared/schema.ts">
import { pgTable, text, serial, integer, boolean, jsonb, timestamp, primaryKey, varchar } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";
import { sql, eq, asc, desc, and, or, like, inArray, isNull, notInArray } from "drizzle-orm";

// --- User-related tables ---

// Session storage table for auth
export const sessions = pgTable(
  "sessions",
  {
    sid: text("sid").primaryKey(),
    sess: jsonb("sess").notNull(),
    expire: timestamp("expire").notNull(),
  },
  (table) => ({
    expireIdx: primaryKey({ columns: [table.expire] }),
  })
);

export const users = pgTable("users", {
  id: serial("id").primaryKey(),
  email: text("email").unique(),
  password: text("password"),
  firstName: text("first_name"),
  username: text("username"),
  isAdmin: boolean("is_admin").default(false),
  country: text("country"),
  isApproved: boolean("is_approved").default(false),
  createdAt: timestamp("created_at").notNull().defaultNow(),
  totalPoints: integer("total_points").default(0),
  rank: text("rank").default("TV Watcher"),
  loginStreak: integer("login_streak").default(0),
  lastLoginDate: timestamp("last_login").defaultNow(),
  backgroundColor: text("background_color").default("bg-purple-500"),
});

// --- Core TV Shows Schema ---
export const tvShows = pgTable("tv_shows", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(),
  description: text("description").notNull(),
  ageRange: text("age_range").notNull(),
  episodeLength: integer("episode_length").notNull(), // in minutes
  creator: text("creator"),
  releaseYear: integer("release_year"),
  endYear: integer("end_year"),
  isOngoing: boolean("is_ongoing").default(true),
  
  // Number of seasons
  seasons: integer("seasons"),
  
  // Core metrics from GitHub data
  stimulationScore: integer("stimulation_score").notNull(), // Direct from GitHub data
  interactivityLevel: text("interactivity_level"),
  dialogueIntensity: text("dialogue_intensity"), 
  soundEffectsLevel: text("sound_effects_level"),
  musicTempo: text("music_tempo"),
  totalMusicLevel: text("total_music_level"),
  totalSoundEffectTimeLevel: text("total_sound_effect_time_level"),
  sceneFrequency: text("scene_frequency"),
  
  // We're keeping creativity_rating but removing other specialized ratings
  creativityRating: integer("creativity_rating"),
  
  // We keep these temporarily for backward compatibility
  // They'll be replaced by junction tables
  availableOn: text("available_on").array(),
  themes: text("themes").array(),
  
  // Other fields
  animationStyle: text("animation_style"),
  imageUrl: text("image_url"),
  isFeatured: boolean("is_featured").default(false),
  
  // YouTube-specific fields - will eventually be moved to youtube_channels table
  // Keeping temporarily for backward compatibility
  subscriberCount: text("subscriber_count"),
  videoCount: text("video_count"),
  channelId: text("channel_id"),
  isYouTubeChannel: boolean("is_youtube_channel").default(false),
  publishedAt: text("published_at"),
  
  // API data tracking
  hasOmdbData: boolean("has_omdb_data").default(false),
  hasYoutubeData: boolean("has_youtube_data").default(false),
});

// --- Favorites table ---
export const favorites = pgTable("favorites", {
  id: serial("id").primaryKey(),
  userId: text("user_id").notNull().references(() => users.id, { onDelete: 'cascade' }),
  tvShowId: integer("tv_show_id").notNull().references(() => tvShows.id, { onDelete: 'cascade' }),
  createdAt: timestamp("created_at").notNull().defaultNow(),
});

// --- Theme and Platform tables ---
export const themes = pgTable("themes", {
  id: serial("id").primaryKey(),
  name: text("name").notNull().unique(),
});

export const platforms = pgTable("platforms", {
  id: serial("id").primaryKey(),
  name: text("name").notNull().unique(),
  url: text("url"),
  iconUrl: text("icon_url"),
});

export const tvShowThemes = pgTable("tv_show_themes", {
  id: serial("id").primaryKey(),
  tvShowId: integer("tv_show_id").notNull().references(() => tvShows.id, { onDelete: 'cascade' }),
  themeId: integer("theme_id").notNull().references(() => themes.id, { onDelete: 'cascade' }),
});

export const tvShowPlatforms = pgTable("tv_show_platforms", {
  id: serial("id").primaryKey(),
  tvShowId: integer("tv_show_id").notNull().references(() => tvShows.id, { onDelete: 'cascade' }),
  platformId: integer("platform_id").notNull().references(() => platforms.id, { onDelete: 'cascade' }),
});

// --- YouTube-specific table ---
export const youtubeChannels = pgTable("youtube_channels", {
  id: serial("id").primaryKey(),
  tvShowId: integer("tv_show_id").notNull().references(() => tvShows.id, { onDelete: 'cascade' }).unique(),
  channelId: text("channel_id"),
  subscriberCount: text("subscriber_count"),
  videoCount: text("video_count"),
  publishedAt: text("published_at"),
});

// --- Reviews table ---
export const tvShowReviews = pgTable("tv_show_reviews", {
  id: serial("id").primaryKey(),
  tvShowId: integer("tv_show_id").notNull().references(() => tvShows.id, { onDelete: 'cascade' }),
  userId: text("user_id").notNull().references(() => users.id, { onDelete: 'cascade' }),
  userName: text("user_name").notNull(),
  rating: integer("rating").notNull(), // 1-5 scale
  review: text("review").notNull(),
  showName: text("show_name"),
  createdAt: timestamp("created_at").notNull().defaultNow(),
});

// --- Analytics tables ---
export const tvShowSearches = pgTable("tv_show_searches", {
  id: serial("id").primaryKey(),
  tvShowId: integer("tv_show_id").notNull().references(() => tvShows.id, { onDelete: 'cascade' }),
  searchCount: integer("search_count").notNull().default(1),
  lastSearched: timestamp("last_searched").notNull().defaultNow(),
});

export const tvShowViews = pgTable("tv_show_views", {
  id: serial("id").primaryKey(),
  tvShowId: integer("tv_show_id").notNull().references(() => tvShows.id, { onDelete: 'cascade' }),
  viewCount: integer("view_count").notNull().default(1),
  lastViewed: timestamp("last_viewed").notNull().defaultNow(),
});

// --- Gamification Tables ---
export const userPointsHistory = pgTable("user_points_history", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull().references(() => users.id, { onDelete: 'cascade' }),
  points: integer("points").notNull(),
  activityType: text("activity_type").notNull(),
  description: text("description"),
  createdAt: timestamp("created_at").notNull().defaultNow(),
  referenceId: integer("reference_id"),
});

export const reviewUpvotes = pgTable("review_upvotes", {
  id: serial("id").primaryKey(),
  reviewId: integer("review_id").notNull().references(() => tvShowReviews.id, { onDelete: 'cascade' }),
  userId: text("user_id").notNull().references(() => users.id, { onDelete: 'cascade' }),
  createdAt: timestamp("created_at").notNull().defaultNow(),
});

export const researchSummaries = pgTable("research_summaries", {
  id: serial("id").primaryKey(),
  title: text("title").notNull(),
  summary: text("summary"),
  fullText: text("full_text"),
  category: text("category").notNull(),
  imageUrl: text("image_url"),
  source: text("source"),
  originalUrl: text("original_url"),
  publishedDate: text("published_date"),
  headline: text("headline"),
  subHeadline: text("sub_headline"),
  keyFindings: text("key_findings"),
  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().defaultNow(),
});

export const userReadResearch = pgTable("user_read_research", {
  id: serial("id").primaryKey(),
  userId: text("user_id").notNull().references(() => users.id, { onDelete: 'cascade' }),
  researchId: integer("research_id").notNull().references(() => researchSummaries.id, { onDelete: 'cascade' }),
  readAt: timestamp("read_at").notNull().defaultNow(),
});

// NEW: Show submissions table with smart duplicate detection and priority system
export const showSubmissions = pgTable("show_submissions", {
  id: serial("id").primaryKey(),
  userId: text("user_id").notNull().references(() => users.id, { onDelete: 'cascade' }),
  showName: text("show_name").notNull(),
  normalizedName: text("normalized_name").notNull(), // For duplicate detection
  whereTheyWatch: text("where_they_watch").notNull(),
  status: text("status").notNull().default("pending"), // pending, approved, rejected
  requestCount: integer("request_count").notNull().default(1), // How many users want this
  priorityScore: integer("priority_score").notNull().default(1), // For admin sorting
  createdAt: timestamp("created_at").notNull().defaultNow(),
  processedAt: timestamp("processed_at"),
  processedBy: text("processed_by").references(() => users.id),
  linkedShowId: integer("linked_show_id").references(() => tvShows.id), // When approved and added
});

export const userReferrals = pgTable("user_referrals", {
  id: serial("id").primaryKey(),
  referrerId: integer("referrer_id").notNull().references(() => users.id, { onDelete: 'cascade' }),
  referredId: integer("referred_id").notNull().references(() => users.id, { onDelete: 'cascade' }),
  createdAt: timestamp("created_at").notNull().defaultNow(),
});

// Track unique clicks on referral links for points
export const referralClicks = pgTable("referral_clicks", {
  id: serial("id").primaryKey(),
  referrerId: integer("referrer_id").notNull().references(() => users.id, { onDelete: 'cascade' }),
  showId: integer("show_id").notNull().references(() => tvShows.id, { onDelete: 'cascade' }),
  clickerIp: text("clicker_ip").notNull(), // To prevent duplicate clicks from same IP
  clickerUserAgent: text("clicker_user_agent"), // Additional uniqueness check
  pointsAwarded: boolean("points_awarded").default(true),
  createdAt: timestamp("created_at").notNull().defaultNow(),
});

// Short URLs for sharing - makes referral links look more professional
export const shortUrls = pgTable("short_urls", {
  id: serial("id").primaryKey(),
  shortCode: text("short_code").notNull().unique(),
  originalUrl: text("original_url").notNull(),
  showId: integer("show_id").notNull().references(() => tvShows.id),
  userId: integer("user_id"), // Optional - for referral tracking
  clicks: integer("clicks").default(0),
  createdAt: timestamp("created_at").notNull().defaultNow(),
});

// Temporary GHL users table to track form submissions before full registration
export const tempGhlUsers = pgTable("temp_ghl_users", {
  id: serial("id").primaryKey(),
  email: text("email").notNull(),
  firstName: text("first_name"),
  lastName: text("last_name"),
  phone: text("phone"),
  country: text("country"),
  ghlContactId: text("ghl_contact_id"),
  isVerified: boolean("is_verified").default(false),
  hasCompletedRegistration: boolean("has_completed_registration").default(false),
  createdAt: timestamp("created_at").notNull().defaultNow(),
  verifiedAt: timestamp("verified_at"),
  registrationCompletedAt: timestamp("registration_completed_at"),
});

// --- Zod schemas for inserting/selecting ---
export const insertUserSchema = createInsertSchema(users).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertFavoriteSchema = createInsertSchema(favorites).omit({
  id: true,
  createdAt: true,
});

export const insertTvShowSchema = createInsertSchema(tvShows).omit({
  id: true,
});

export const insertTvShowReviewSchema = createInsertSchema(tvShowReviews).omit({
  id: true,
  createdAt: true,
});

export const insertShowSubmissionSchema = createInsertSchema(showSubmissions).omit({
  id: true,
  normalizedName: true,
  status: true,
  requestCount: true,
  priorityScore: true,
  createdAt: true,
  processedAt: true,
  processedBy: true,
  linkedShowId: true,
});

export const insertTvShowSearchSchema = createInsertSchema(tvShowSearches).omit({
  id: true,
  lastSearched: true,
});

export const insertTvShowViewSchema = createInsertSchema(tvShowViews).omit({
  id: true,
  lastViewed: true, 
});

export const insertYoutubeChannelSchema = createInsertSchema(youtubeChannels).omit({
  id: true,
});

export const insertThemeSchema = createInsertSchema(themes).omit({
  id: true,
});

export const insertPlatformSchema = createInsertSchema(platforms).omit({
  id: true,
});

export const insertTvShowThemeSchema = createInsertSchema(tvShowThemes).omit({
  id: true,
});

export const insertTvShowPlatformSchema = createInsertSchema(tvShowPlatforms).omit({
  id: true,
});

// --- Gamification schemas ---
export const insertUserPointsHistorySchema = createInsertSchema(userPointsHistory).omit({
  id: true,
  createdAt: true,
});

export const insertReviewUpvoteSchema = createInsertSchema(reviewUpvotes).omit({
  id: true,
  createdAt: true,
});

export const insertResearchSummarySchema = createInsertSchema(researchSummaries).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertUserReadResearchSchema = createInsertSchema(userReadResearch).omit({
  id: true,
  readAt: true,
});



export const insertUserReferralSchema = createInsertSchema(userReferrals).omit({
  id: true,
  createdAt: true,
});

export const insertTempGhlUserSchema = createInsertSchema(tempGhlUsers).omit({
  id: true,
  createdAt: true,
  verifiedAt: true,
  registrationCompletedAt: true,
});

// --- TypeScript types for database entities ---
export type InsertUser = z.infer<typeof insertUserSchema>;
export type User = typeof users.$inferSelect;

export type InsertFavorite = z.infer<typeof insertFavoriteSchema>;
export type Favorite = typeof favorites.$inferSelect;

export type InsertTvShow = z.infer<typeof insertTvShowSchema>;
export type TvShow = typeof tvShows.$inferSelect;

export type InsertTvShowReview = z.infer<typeof insertTvShowReviewSchema>;
export type TvShowReview = typeof tvShowReviews.$inferSelect;

export type InsertTvShowSearch = z.infer<typeof insertTvShowSearchSchema>;
export type TvShowSearch = typeof tvShowSearches.$inferSelect;

export type InsertTvShowView = z.infer<typeof insertTvShowViewSchema>;
export type TvShowView = typeof tvShowViews.$inferSelect;

export type InsertYoutubeChannel = z.infer<typeof insertYoutubeChannelSchema>;
export type YoutubeChannel = typeof youtubeChannels.$inferSelect;

export type InsertTheme = z.infer<typeof insertThemeSchema>;
export type Theme = typeof themes.$inferSelect;

export type InsertPlatform = z.infer<typeof insertPlatformSchema>;
export type Platform = typeof platforms.$inferSelect;

export type InsertTvShowTheme = z.infer<typeof insertTvShowThemeSchema>;
export type TvShowTheme = typeof tvShowThemes.$inferSelect;

export type InsertTvShowPlatform = z.infer<typeof insertTvShowPlatformSchema>;
export type TvShowPlatform = typeof tvShowPlatforms.$inferSelect;

// --- Gamification types ---
export type InsertUserPointsHistory = z.infer<typeof insertUserPointsHistorySchema>;
export type UserPointsHistory = typeof userPointsHistory.$inferSelect;

export type InsertReviewUpvote = z.infer<typeof insertReviewUpvoteSchema>;
export type ReviewUpvote = typeof reviewUpvotes.$inferSelect;

export type InsertResearchSummary = z.infer<typeof insertResearchSummarySchema>;
export type ResearchSummary = typeof researchSummaries.$inferSelect;

export type InsertUserReadResearch = z.infer<typeof insertUserReadResearchSchema>;
export type UserReadResearch = typeof userReadResearch.$inferSelect;

export type InsertShowSubmission = z.infer<typeof insertShowSubmissionSchema>;
export type ShowSubmission = typeof showSubmissions.$inferSelect;

export type InsertUserReferral = z.infer<typeof insertUserReferralSchema>;
export type UserReferral = typeof userReferrals.$inferSelect;

// --- Notifications table ---
export const notifications = pgTable("notifications", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
  type: text("type").notNull(),
  message: text("message").notNull(),
  isRead: boolean("is_read").default(false),
  relatedShowName: text("related_show_name"),
  createdAt: timestamp("created_at").notNull().defaultNow(),
});

export const insertNotificationSchema = createInsertSchema(notifications).omit({
  id: true,
  createdAt: true,
});

export type InsertNotification = z.infer<typeof insertNotificationSchema>;
export type Notification = typeof notifications.$inferSelect;

// --- External data schema for GitHub import ---
export const tvShowGitHubSchema = z.object({
  name: z.string(),
  description: z.string(),
  age_range: z.string(),
  episode_length: z.number(),
  themes: z.array(z.string()).or(z.string()).optional().nullable(),
  stimulation_score: z.number().or(z.string().transform(Number)),
  interaction_level: z.string().optional().nullable(),
  dialogue_intensity: z.string().optional().nullable(), 
  sound_effects_level: z.string().optional().nullable(),
  music_tempo: z.string().optional().nullable(),
  total_music_level: z.string().optional().nullable(),
  total_sound_effect_time_level: z.string().optional().nullable(),
  scene_frequency: z.string().optional().nullable(),
});

export type TvShowGitHub = z.infer<typeof tvShowGitHubSchema>;
</file>

<file path="client/src/components/Navbar.tsx">
import { useState, useEffect } from "react";
import { Link, useLocation } from "wouter";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { useQuery } from "@tanstack/react-query";
import { apiGet } from "@/lib/queryClient";
import { Search, User, LogOut, Home, Filter, BarChart2, Info, Settings, X, BookOpen, Plus } from "lucide-react";
import type { TvShow } from "../../../shared/schema";
import { useAuth } from "@/hooks/use-auth";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@/components/ui/alert-dialog";

export default function Navbar() {
  const [location] = useLocation();
  const [searchTerm, setSearchTerm] = useState("");
  const [showResults, setShowResults] = useState(false);
  const [isNavOpen, setIsNavOpen] = useState(false);
  const [showLogoutDialog, setShowLogoutDialog] = useState(false);
  // Use the original authentication hook
  const { user, isLoading, isAdmin } = useAuth();

  // Handle logout with confirmation
  const handleLogout = () => {
    fetch('/api/logout', {
      method: 'POST',
      credentials: 'include'
    }).then(() => {
      // Redirect to token entry page after logout
      window.location.href = '/';
    }).catch(err => {
      console.error("Logout error:", err);
      // Force redirect even if there's an error
      window.location.href = '/';
    });
  };

  // Fetch shows for search dropdown
  const { data: shows } = useQuery({
    queryKey: ['/api/shows'],
    queryFn: async () => {
      const response = await fetch('/api/shows');
      if (!response.ok) {
        throw new Error('Failed to fetch shows');
      }
      const data = await response.json();
      return data as TvShow[];
    },
    staleTime: 60000, // 1 minute
  });

  const handleSearch = (e: React.FormEvent) => {
    e.preventDefault();
    if (searchTerm.trim()) {
      // For all searches, direct to browse page with search filter
      console.log('Navbar - Submitting search for:', searchTerm.trim());
      // Use setLocation from wouter instead of directly setting window.location
      // This keeps the app in SPA mode and avoids a full page reload
      window.location.href = `/browse?search=${encodeURIComponent(searchTerm.trim())}`;
      setShowResults(false);
    }
  };
  
  // Hide results when clicking outside
  useEffect(() => {
    const handleClickOutside = () => setShowResults(false);
    document.addEventListener('click', handleClickOutside);
    return () => document.removeEventListener('click', handleClickOutside);
  }, []);

  // Filter shows based on search term
  const filteredShows = shows?.filter((show: TvShow) => {
    if (!searchTerm.trim()) return false;
    
    const searchLower = searchTerm.toLowerCase().trim();
    const nameLower = show.name.toLowerCase();
    
    // Direct match in name
    if (nameLower.includes(searchLower)) return true;
    
    // Handle shows with year ranges
    const nameWithoutYears = nameLower.replace(/\s+\d{4}(-\d{4}|-present)?/g, '');
    if (nameWithoutYears.includes(searchLower)) return true;
    
    // Match any part of a word
    const words = nameLower.split(/\s+/);
    if (words.some((word: string) => word.includes(searchLower))) return true;
    
    // Handle apostrophes and special characters
    const simplifiedName = nameLower.replace(/[''\.]/g, '');
    if (simplifiedName.includes(searchLower)) return true;
    
    return false;
  }).slice(0, 6);

  return (
    <header className="sticky top-0 z-50 bg-primary shadow-md">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div className="flex justify-between h-16">
          <div className="flex items-center">
            <Link href="/home" className="flex-shrink-0">
              <h1 className="text-2xl font-heading font-bold" style={{ color: "#F6CB59" }}>TV Tantrum</h1>
            </Link>
            <nav className="hidden md:ml-10 md:flex space-x-8">
              <Link 
                href="/home"
                className={`${location === '/home' ? 'text-white border-b-2 border-white' : 'text-white/80 hover:text-white'} font-medium px-1 py-4 flex items-center`}
              >
                <Home className="w-4 h-4 mr-2" />
                Home
              </Link>
              <Link 
                href="/browse"
                className={`${location === '/browse' ? 'text-white border-b-2 border-white' : 'text-white/80 hover:text-white'} font-medium px-1 py-4 flex items-center`}
              >
                <Filter className="w-4 h-4 mr-2" />
                Browse
              </Link>
              <Link 
                href="/compare"
                className={`${location === '/compare' ? 'text-white border-b-2 border-white' : 'text-white/80 hover:text-white'} font-medium px-1 py-4 flex items-center`}
              >
                <BarChart2 className="w-4 h-4 mr-2" />
                Compare
              </Link>
              <Link 
                href="/app-about"
                className={`${location === '/app-about' ? 'text-white border-b-2 border-white' : 'text-white/80 hover:text-white'} font-medium px-1 py-4 flex items-center`}
              >
                <Info className="w-4 h-4 mr-2" />
                About
              </Link>
            </nav>
          </div>
          
          <div className="flex items-center gap-4">
            {/* Authentication links */}
            <div className="hidden md:flex items-center gap-3">
              {!!user ? (
                <div className="flex items-center gap-2">
                  {isAdmin && (
                    <Link href="/admin">
                      <Button 
                        variant="ghost" 
                        className="flex items-center gap-1 text-white/90 hover:text-white hover:bg-primary-700"
                      >
                        <Settings className="h-4 w-4" />
                        <span>Admin</span>
                      </Button>
                    </Link>
                  )}
                  <Link href="/research">
                    <Button 
                      variant="ghost" 
                      className="flex items-center gap-1 text-white/90 hover:text-white hover:bg-primary-700"
                    >
                      <BookOpen className="h-4 w-4" />
                      <span>Research</span>
                    </Button>
                  </Link>
                  <Link href="/submit-show">
                    <Button 
                      variant="ghost" 
                      className="flex items-center gap-1 text-white/90 hover:text-white hover:bg-primary-700"
                    >
                      <Plus className="h-4 w-4" />
                      <span>Submit Show</span>
                    </Button>
                  </Link>
                  <Link href="/user-dashboard">
                    <Button 
                      variant="ghost" 
                      className="flex items-center gap-1 text-white/90 hover:text-white hover:bg-primary-700"
                    >
                      <User className="h-4 w-4" />
                      <span>Dashboard</span>
                    </Button>
                  </Link>
                  <Button 
                    variant="ghost" 
                    className="flex items-center gap-1 text-white/90 hover:text-white hover:bg-primary-700"
                    onClick={() => setShowLogoutDialog(true)}
                  >
                    <LogOut className="h-4 w-4" />
                    <span>Logout</span>
                  </Button>
                </div>
              ) : (
                <Link href="/auth">
                  <Button 
                    variant="ghost" 
                    className="text-white/90 hover:text-white hover:bg-primary-700"
                  >
                    Login/Register
                  </Button>
                </Link>
              )}
            </div>
            
            {/* Mobile menu button */}
            <Button
              variant="ghost"
              size="icon"
              className="md:hidden ml-4 text-white hover:text-white/80"
              onClick={() => setIsNavOpen(true)}
            >
              <i className="fas fa-bars text-xl"></i>
            </Button>
            
            {/* Custom mobile navigation overlay */}
            {isNavOpen && (
              <div className="fixed inset-0 z-50 md:hidden">
                {/* Backdrop */}
                <div 
                  className="fixed inset-0 bg-black/50"
                  onClick={() => setIsNavOpen(false)}
                />
                
                {/* Side drawer */}
                <div className="fixed inset-y-0 left-0 w-64 bg-white p-4 overflow-y-auto">
                  <div className="flex justify-between items-center mb-4">
                    <Link href="/home" onClick={() => setIsNavOpen(false)}>
                      <h2 className="text-lg font-bold" style={{ color: "#F6CB59" }}>TV Tantrum</h2>
                    </Link>
                    <Button
                      variant="ghost"
                      size="icon"
                      className="text-gray-500 hover:bg-gray-100"
                      onClick={() => setIsNavOpen(false)}
                    >
                      <X className="h-5 w-5" />
                    </Button>
                  </div>
                  
                  <div className="space-y-1">
                    <Link 
                      href="/home"
                      onClick={() => setIsNavOpen(false)}
                      className={`flex items-center px-3 py-2 text-base font-medium ${location === '/home' ? 'text-primary-600 bg-primary-50' : 'text-gray-500 hover:text-primary-600 hover:bg-primary-50'} rounded-md`}
                    >
                      <Home className="h-5 w-5 mr-3" />
                      Home
                    </Link>
                    <Link 
                      href="/browse"
                      onClick={() => setIsNavOpen(false)}
                      className={`flex items-center px-3 py-2 text-base font-medium ${location === '/browse' ? 'text-primary-600 bg-primary-50' : 'text-gray-500 hover:text-primary-600 hover:bg-primary-50'} rounded-md`}
                    >
                      <Filter className="h-5 w-5 mr-3" />
                      Browse
                    </Link>
                    <Link 
                      href="/compare"
                      onClick={() => setIsNavOpen(false)}
                      className={`flex items-center px-3 py-2 text-base font-medium ${location === '/compare' ? 'text-primary-600 bg-primary-50' : 'text-gray-500 hover:text-primary-600 hover:bg-primary-50'} rounded-md`}
                    >
                      <BarChart2 className="h-5 w-5 mr-3" />
                      Compare
                    </Link>
                    <Link 
                      href="/about"
                      onClick={() => setIsNavOpen(false)}
                      className={`flex items-center px-3 py-2 text-base font-medium ${location === '/about' ? 'text-primary-600 bg-primary-50' : 'text-gray-500 hover:text-primary-600 hover:bg-primary-50'} rounded-md`}
                    >
                      <Info className="h-5 w-5 mr-3" />
                      About
                    </Link>
                    
                    {/* Authentication links */}
                    {!!user ? (
                      <>
                        {user?.isAdmin && (
                          <Link 
                            href="/admin"
                            onClick={() => setIsNavOpen(false)}
                            className="flex items-center px-3 py-2 text-base font-medium text-gray-500 hover:text-primary-600 hover:bg-primary-50 rounded-md"
                          >
                            <Settings className="h-5 w-5 mr-2" />
                            Admin Dashboard
                          </Link>
                        )}
                        <Link 
                          href="/research"
                          onClick={() => setIsNavOpen(false)}
                          className="flex items-center px-3 py-2 text-base font-medium text-gray-500 hover:text-primary-600 hover:bg-primary-50 rounded-md"
                        >
                          <BookOpen className="h-5 w-5 mr-2" />
                          Research
                        </Link>
                        <Link 
                          href="/submit-show"
                          onClick={() => setIsNavOpen(false)}
                          className="flex items-center px-3 py-2 text-base font-medium text-gray-500 hover:text-primary-600 hover:bg-primary-50 rounded-md"
                        >
                          <Plus className="h-5 w-5 mr-2" />
                          Submit Show
                        </Link>
                        <Link 
                          href="/user-dashboard"
                          onClick={() => setIsNavOpen(false)}
                          className="flex items-center px-3 py-2 text-base font-medium text-gray-500 hover:text-primary-600 hover:bg-primary-50 rounded-md"
                        >
                          <User className="h-5 w-5 mr-2" />
                          Dashboard
                        </Link>
                        <button
                          onClick={() => {
                            setIsNavOpen(false);
                            setShowLogoutDialog(true);
                          }}
                          className="flex w-full items-center px-3 py-2 text-base font-medium text-gray-500 hover:text-primary-600 hover:bg-primary-50 rounded-md"
                        >
                          <LogOut className="h-5 w-5 mr-2" />
                          Logout
                        </button>
                      </>
                    ) : (
                      <Link 
                        href="/auth"
                        onClick={() => setIsNavOpen(false)}
                        className="flex items-center px-3 py-2 text-base font-medium text-gray-500 hover:text-primary-600 hover:bg-primary-50 rounded-md"
                      >
                        <User className="h-5 w-5 mr-2" />
                        Login/Register
                      </Link>
                    )}
                  </div>
                  
                  {/* Search has been removed to make interface cleaner */}
                </div>
              </div>
            )}
          </div>
        </div>
      </div>
      
      {/* Standalone logout confirmation dialog */}
      <AlertDialog open={showLogoutDialog} onOpenChange={setShowLogoutDialog}>
        <AlertDialogContent className="max-w-sm mx-4">
          <AlertDialogHeader>
            <AlertDialogTitle>Are you sure you want to logout?</AlertDialogTitle>
            <AlertDialogDescription>
              You will be redirected to the login page and will need to sign in again to access your account.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction onClick={handleLogout}>
              Yes, Logout
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </header>
  );
}
</file>

<file path="client/src/components/ShowCard.tsx">
import { useState, useEffect } from "react";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";
import RatingBar from "@/components/RatingBar";
import { TvShow } from "@shared/schema";
import { getStimulationScoreColor } from "@/lib/showUtils";
import { useAuth } from "@/hooks/use-auth";
import { Heart, Star } from "lucide-react";
import { useLocation } from "wouter";
import { useToast } from "@/hooks/use-toast";
import { FavoriteRegistrationModal } from "@/components/FavoriteRegistrationModal";

interface ShowCardProps {
  show: TvShow & {
    averageRating?: number;
    reviewCount?: number;
    isFavorite?: boolean;
  };
  viewMode: "grid" | "list";
  onClick: () => void;
  isMobile?: boolean;
}

export default function ShowCard({ show, viewMode, onClick, isMobile = false }: ShowCardProps) {
  const [isFavorite, setIsFavorite] = useState(false);
  const [imageError, setImageError] = useState(false);
  const [showRegistrationModal, setShowRegistrationModal] = useState(false);
  const [reviewStats, setReviewStats] = useState<{reviewCount: number, avgRating: number} | null>(null);
  const { user, toggleFavorite: toggleFav } = useAuth();
  
  // Ensure we have valid show data
  if (!show || !show.id) {
    return null;
  }
  
  // Normalize show data to handle API response field naming differences
  const normalizedShow = {
    ...show,
    // Type-safe normalization for field names that might come in different formats
    imageUrl: show.imageUrl || '',
    ageRange: show.ageRange || 'Unknown',
    stimulationScore: show.stimulationScore || 0
  };
  
  // Initialize favorite status from props if available
  useEffect(() => {
    if (show.isFavorite !== undefined) {
      setIsFavorite(show.isFavorite);
      return;
    }
    
    // Reset favorite status when user logs out
    if (!user) {
      setIsFavorite(false);
      return;
    }
    
    const checkFavoriteStatus = async () => {
      if (user && show.id) {
        try {
          const res = await fetch(`/api/favorites/${show.id}`, {
            credentials: "include" // Ensure cookies are sent for authentication
          });
          
          if (!res.ok) {
            // If request failed, set to false and return
            setIsFavorite(false);
            return;
          }
          
          const data = await res.json();
          setIsFavorite(!!data.isFavorite); // Convert to boolean with !!
        } catch (error) {
          console.error("Failed to check favorite status:", error);
          setIsFavorite(false); // Set to false on error to be safe
        }
      } else {
        // If no user or no show.id, ensure favorite is false
        setIsFavorite(false);
      }
    };
    
    checkFavoriteStatus();
  }, [user, show.id]);

  // Fetch review statistics for this show
  useEffect(() => {
    if (show?.id) {
      const fetchReviewStats = async () => {
        try {
          const response = await fetch(`/api/reviews/${show.id}`, {
            credentials: 'include'
          });
          if (response.ok) {
            const reviews = await response.json();
            if (reviews && reviews.length > 0) {
              const totalRating = reviews.reduce((sum: number, review: any) => sum + review.rating, 0);
              const avgRating = totalRating / reviews.length;
              setReviewStats({
                reviewCount: reviews.length,
                avgRating: Math.round(avgRating * 10) / 10 // Round to 1 decimal place
              });
            } else {
              setReviewStats({ reviewCount: 0, avgRating: 0 });
            }
          }
        } catch (error) {
          console.error('Error fetching review stats:', error);
          setReviewStats({ reviewCount: 0, avgRating: 0 });
        }
      };
      fetchReviewStats();
    }
  }, [show?.id]);
  
  const [, navigate] = useLocation();
  const { toast } = useToast();
  
  const toggleFavorite = (e: React.MouseEvent) => {
    e.stopPropagation();
    
    // Check if user is logged in
    if (!user) {
      setShowRegistrationModal(true);
      return;
    }
    
    // Optimistic update - update UI immediately
    const newFavoriteStatus = !isFavorite;
    setIsFavorite(newFavoriteStatus);
    
    // Use the auth context toggle favorite function with current status
    toggleFav(show.id, isFavorite).then(() => {
      toast({
        title: newFavoriteStatus ? "Added to favorites" : "Removed from favorites",
        description: newFavoriteStatus ? `${show.name} has been added to your favorites.` : `${show.name} has been removed from your favorites.`,
        variant: "default",
      });
    }).catch(error => {
      // Revert optimistic update on error
      setIsFavorite(!newFavoriteStatus);
      toast({
        title: "Error",
        description: "There was an error updating your favorites. Please try again.",
        variant: "destructive",
      });
      console.error("Error toggling favorite:", error);
    });
  };
  
  // Format release year range
  const releaseYears = show.releaseYear ? (
    show.endYear && show.endYear !== show.releaseYear 
      ? `(${show.releaseYear}-${show.endYear})` 
      : `(${show.releaseYear})`
  ) : '';
  
  // Theme colors based on categories
  const getThemeColor = (theme: string) => {
    const lowerTheme = theme.toLowerCase();
    if (lowerTheme.includes('friendship')) return 'bg-cyan-100 text-cyan-800';
    if (lowerTheme.includes('problem solving')) return 'bg-green-100 text-green-800';
    if (lowerTheme.includes('emotional intelligence')) return 'bg-rose-100 text-rose-800';
    if (lowerTheme.includes('creativity') || lowerTheme.includes('imagination')) return 'bg-purple-100 text-purple-800';
    if (lowerTheme.includes('adventure')) return 'bg-amber-100 text-amber-800';
    if (lowerTheme.includes('science') || lowerTheme.includes('stem')) return 'bg-sky-100 text-sky-800';
    if (lowerTheme.includes('nature')) return 'bg-emerald-100 text-emerald-800';
    if (lowerTheme.includes('mechanic') || lowerTheme.includes('engineering')) return 'bg-orange-100 text-orange-800';
    if (lowerTheme.includes('cultural') || lowerTheme.includes('social')) return 'bg-pink-100 text-pink-800';
    if (lowerTheme.includes('entertainment')) return 'bg-indigo-100 text-indigo-800';
    return 'bg-gray-100 text-gray-800';
  };
  
  // Get stimulation score colors based on index
  const getStimulationDotColor = (index: number) => {
    // Match the colors from details page
    const bgColors = [
      'bg-green-500',    // green for 1
      'bg-yellow-500',   // yellow for 2
      'bg-orange-500',   // orange for 3
      'bg-orange-600',   // dark orange for 4
      'bg-red-500'       // red for 5
    ];
    
    const borderColors = [
      'border-green-500',    // green for 1
      'border-yellow-500',   // yellow for 2
      'border-orange-500',   // orange for 3
      'border-orange-600',   // dark orange for 4
      'border-red-500'       // red for 5
    ];
    
    return { bgColor: bgColors[index], borderColor: borderColors[index] };
  };
  
  // Render stimulation score dots
  const renderStimulationDots = () => {
    const dots = [];
    const score = normalizedShow.stimulationScore;
    
    for (let i = 0; i < 5; i++) {
      const { bgColor, borderColor } = getStimulationDotColor(i);
      dots.push(
        <div 
          key={i} 
          className={`w-3 h-3 rounded-full mx-0.5 ${
            // Active dots show their own color
            i < score 
              ? bgColor 
              // Inactive dots are outlined with their corresponding color
              : `border-2 ${borderColor} bg-white`
          }`} 
        />
      );
    }
    return dots;
  };
  
  // Get the stimulation score text representation
  const getStimulationText = (score: number) => {
    return score === 1 ? 'Low' : 
           score === 2 ? 'Low-Medium' : 
           score === 3 ? 'Medium' : 
           score === 4 ? 'Medium-High' : 
           'High';
  };
  
  // Format the stimulation score text (used for circular badge in mobile view)
  const getStimulationScoreText = (score: number) => {
    return `${score}/5`;
  };
  
  // Get color for circular stimulation score
  const getStimulationCircleColor = (score: number) => {
    if (score <= 1) return 'border-green-500 text-green-500';
    if (score <= 2) return 'border-green-400 text-green-500';
    if (score <= 3) return 'border-yellow-500 text-yellow-600';
    if (score <= 4) return 'border-orange-500 text-orange-600';
    return 'border-red-500 text-red-600';
  };

  // Mobile portrait style card - clean design as in screenshot
  if (isMobile && viewMode === "grid") {
    const stimulationLabel = getStimulationText(normalizedShow.stimulationScore);
    
    return (
      <Card 
        className="bg-white rounded-lg shadow-sm overflow-hidden cursor-pointer h-full flex flex-col" 
        onClick={() => {
          // Scroll to top before triggering the onClick action
          window.scrollTo(0, 0);
          onClick();
        }}
      >
        {/* Image */}
        <div className="relative">
          {normalizedShow.imageUrl && !imageError ? (
            <div className="w-full aspect-[2/3] bg-gray-100 overflow-hidden">
              <img 
                className="w-full h-full object-cover"
                src={normalizedShow.imageUrl}
                alt={show.name}
                style={{ objectPosition: 'center top' }}
                onError={() => {
                  // If image fails to load, set state to show placeholder
                  setImageError(true);
                }}
              />
            </div>
          ) : (
            <div className="w-full aspect-[2/3] bg-gray-200 flex items-center justify-center">
              <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="text-gray-400">
                <rect x="2" y="7" width="20" height="15" rx="2" ry="2"></rect>
                <polyline points="17 2 12 7 7 2"></polyline>
              </svg>
            </div>
          )}
          
          {/* Favorite button */}
          <Button 
            variant="ghost" 
            size="sm"
            className={`absolute top-1 right-1 p-1 bg-black/30 text-white rounded-full hover:bg-black/50 h-7 w-7 flex items-center justify-center`}
            onClick={(e) => {
              e.stopPropagation();
              toggleFavorite(e);
            }}
          >
            <Heart className={`w-4 h-4 ${isFavorite ? 'fill-red-500 text-red-500' : ''}`} />
          </Button>
        </div>
        
        <CardContent className="p-3 flex flex-col flex-grow">
          {/* Title with ellipsis */}
          <h3 className="text-sm font-bold line-clamp-1 mb-2">{show.name}</h3>
          
          {/* Review Statistics */}
          {reviewStats && reviewStats.reviewCount > 0 && (
            <div className="flex items-center gap-1 mb-2 text-xs">
              <Star className="w-3 h-3 fill-yellow-400 text-yellow-400" />
              <span className="font-medium">{reviewStats.avgRating}</span>
              <span className="text-gray-500">({reviewStats.reviewCount} review{reviewStats.reviewCount !== 1 ? 's' : ''})</span>
            </div>
          )}
          
          {/* Age Badge */}
          <Badge variant="outline" className="bg-green-50 text-green-700 text-xs border-green-100 mb-2 w-fit">
            Ages {normalizedShow.ageRange}
          </Badge>
          
          {/* Stimulation score dots and label */}
          <div className="mt-auto">
            <div className="flex flex-col items-center">
              <div className="flex items-center justify-center mb-1">
                {renderStimulationDots()}
              </div>
              <div className="text-xs text-gray-600 text-center">
                {stimulationLabel} Stimulation
              </div>
            </div>
          </div>
        </CardContent>
      </Card>
    );
  }

  // Original list view card
  if (viewMode === "list") {
    return (
      <Card 
        className="hover:shadow-lg transition-shadow duration-300 cursor-pointer" 
        onClick={() => {
          // Scroll to top before triggering the onClick action
          window.scrollTo(0, 0);
          onClick();
        }}>
        <div className="flex">
          <div className="flex-shrink-0 w-32 sm:w-48">
            {show.imageUrl ? (
              <div className="h-full w-full bg-gray-100 overflow-hidden flex items-center justify-center">
                <div className="w-full h-full relative">
                  <img 
                    className="absolute inset-0 w-full h-full object-cover"
                    src={show.imageUrl}
                    alt={show.name}
                    style={{ objectPosition: 'center top' }}
                  />
                </div>
              </div>
            ) : (
              <div className="h-full w-full bg-gray-200 flex items-center justify-center">
                <i className="fas fa-tv text-gray-400 text-2xl"></i>
              </div>
            )}
          </div>
          
          <CardContent className="p-4 w-full">
            <div className="flex justify-between items-start">
              <div>
                <h3 className="text-lg font-heading font-bold mb-1">{show.name}</h3>
                <div className="flex items-center flex-wrap gap-2 mb-2">
                  <Badge variant="outline" className="bg-green-100 text-green-800 text-xs font-medium">
                    Ages {show.ageRange}
                  </Badge>
                  {show.availableOn && show.availableOn.length > 0 && (
                    <Badge variant="outline" className="bg-blue-100 text-blue-800 text-xs font-medium">
                      {show.availableOn[0]}{show.availableOn.length > 1 ? "+" : ""}
                    </Badge>
                  )}
                  {/* Review Statistics */}
                  {reviewStats && reviewStats.reviewCount > 0 && (
                    <div className="flex items-center gap-1 text-xs">
                      <Star className="w-3 h-3 fill-yellow-400 text-yellow-400" />
                      <span className="font-medium">{reviewStats.avgRating}</span>
                      <span className="text-gray-500">({reviewStats.reviewCount})</span>
                    </div>
                  )}
                </div>
                <p className="text-gray-600 text-sm mb-2 line-clamp-2">
                  {show.description}
                </p>
                
                {/* Theme tags */}
                {show.themes && show.themes.length > 0 && (
                  <div className="flex flex-wrap gap-1 mt-2 mb-3">
                    {show.themes.slice(0, 5).map((theme, index) => (
                      <Badge key={index} variant="outline" className={`${getThemeColor(theme)} text-xs`}>
                        {theme}
                      </Badge>
                    ))}
                    {show.themes.length > 5 && (
                      <Badge variant="outline" className="bg-gray-100 text-gray-800 text-xs">
                        +{show.themes.length - 5}
                      </Badge>
                    )}
                  </div>
                )}
              </div>
            </div>
            
            <div className="flex justify-between items-center mt-2">
              <div className="flex items-center">
                <div className="flex items-center mr-2">
                  {renderStimulationDots()}
                </div>
                <span className="text-sm text-gray-600">
                  {getStimulationText(show.stimulationScore)} Stimulation
                </span>
              </div>
              
              <div className="flex items-center space-x-2">
                <Button 
                  variant="ghost" 
                  size="sm"
                  className={`${isFavorite ? 'text-red-500' : 'text-gray-400 hover:text-red-500'}`}
                  onClick={toggleFavorite}
                >
                  <Heart className={`w-4 h-4 mr-1 ${isFavorite ? 'fill-red-500 text-red-500' : ''}`} />
                  {isFavorite ? 'Saved' : 'Save'}
                </Button>
                <Button 
                  variant="default" 
                  size="sm" 
                  className="bg-secondary hover:bg-secondary/90 text-white"
                  style={{fontWeight: 'bold'}}
                >
                  Learn More
                </Button>
              </div>
            </div>
          </CardContent>
        </div>
      </Card>
    );
  }
  
  // Default card view (grid) - smaller portrait style
  return (
    <>
    <Card 
      className="bg-white rounded-xl shadow-md overflow-hidden hover:shadow-lg transition-shadow duration-300 cursor-pointer h-full flex flex-col" 
      onClick={() => {
        // Scroll to top before triggering the onClick action
        window.scrollTo(0, 0);
        onClick();
      }}>
      <div className="relative">
        {normalizedShow.imageUrl && !imageError ? (
          <div className="w-full aspect-[2/3] bg-gray-100 overflow-hidden flex items-center justify-center">
            <div className="w-full h-full relative">
              <img 
                className="absolute inset-0 w-full h-full object-cover"
                src={normalizedShow.imageUrl}
                alt={show.name}
                style={{ objectPosition: 'center top' }}
                onError={() => {
                  // If image fails to load, set state to show placeholder
                  setImageError(true);
                }}
              />
            </div>
          </div>
        ) : (
          <div className="w-full aspect-[2/3] bg-gray-200 flex items-center justify-center">
            <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="text-gray-400">
              <rect x="2" y="7" width="20" height="15" rx="2" ry="2"></rect>
              <polyline points="17 2 12 7 7 2"></polyline>
            </svg>
          </div>
        )}
        
        {/* Favorite button overlay */}
        <Button 
          variant="ghost" 
          size="sm"
          className={`absolute top-1 right-1 p-0.5 bg-black/30 text-white rounded-full hover:bg-black/50 h-6 w-6 flex items-center justify-center`}
          onClick={(e) => {
            e.stopPropagation();
            toggleFavorite(e);
          }}
        >
          <Heart className={`w-3 h-3 ${isFavorite ? 'fill-red-500 text-red-500' : ''}`} />
        </Button>
      </div>
      
      <CardContent className="p-2 flex-grow flex flex-col">
        <div className="flex-grow space-y-1">
          {/* Title and age */}
          <div>
            <h3 className="text-sm font-semibold line-clamp-1">{show.name}</h3>
            <div className="flex items-center gap-1 mt-0.5">
              <span className="text-xs text-gray-500">Ages {normalizedShow.ageRange}</span>
            </div>
          </div>
          
          {/* Review Statistics */}
          {reviewStats && reviewStats.reviewCount > 0 && (
            <div className="flex items-center gap-1 text-xs">
              <Star className="w-3 h-3 fill-yellow-400 text-yellow-400" />
              <span className="font-medium">{reviewStats.avgRating}</span>
              <span className="text-gray-500">({reviewStats.reviewCount})</span>
            </div>
          )}
          
          {/* Stimulation score indicator */}
          <div className="flex items-center gap-1">
            <div className="flex items-center scale-75">
              {renderStimulationDots()}
            </div>
            <span className="text-xs text-gray-600">
              {getStimulationText(normalizedShow.stimulationScore)}
            </span>
          </div>
          
          {/* Theme tags - limited to 1 for smaller cards */}
          {show.themes && show.themes.length > 0 && (
            <div className="flex flex-wrap gap-1">
              {show.themes.slice(0, 1).map((theme, index) => (
                <Badge key={index} variant="outline" className={`${getThemeColor(theme)} text-xs py-0 px-1.5`}>
                  {theme}
                </Badge>
              ))}
              {show.themes.length > 1 && (
                <Badge variant="outline" className="bg-gray-100 text-gray-600 text-xs py-0 px-1.5">
                  +{show.themes.length - 1}
                </Badge>
              )}
            </div>
          )}
        </div>
        
        {/* Learn More button */}
        <div className="mt-auto pt-1">
          <Button 
            variant="default" 
            size="sm" 
            className="w-full bg-secondary hover:bg-secondary/90 text-white text-xs py-0.5 h-7"
            style={{fontWeight: 'bold'}}
          >
            Learn More
          </Button>
        </div>
      </CardContent>
    </Card>
    
    {/* Registration Modal */}
    <FavoriteRegistrationModal 
      isOpen={showRegistrationModal}
      onClose={() => setShowRegistrationModal(false)}
      showName={show.name}
    />
    </>
  );
}
</file>

<file path="client/src/App.tsx">
import { Switch, Route } from "wouter";
import { queryClient } from "./lib/queryClient";
import { QueryClientProvider } from "@tanstack/react-query";
import { Toaster } from "@/components/ui/toaster";
import { TooltipProvider } from "@/components/ui/tooltip";
import NotFound from "@/pages/not-found";
import Navbar from "@/components/Navbar";
import Footer from "@/components/Footer";
import Home from "@/pages/home";
import Browse from "@/pages/browse";
import Detail from "@/pages/detail";
import Compare from "@/pages/compare";
import About from "@/pages/about";
import AuthPage from "@/pages/auth-page-new";
import AdminPage from "@/pages/admin-page";
import LandingPage from "@/pages/landing-page";
import PreLaunchAbout from "@/pages/pre-launch-about";
import PreLaunchFAQ from "@/pages/pre-launch-faq";
import TokenEntryPage from "@/pages/token-entry";
import RegistrationPendingPage from "@/pages/registration-pending";
import UserDashboard from "@/pages/user-dashboard";
import UserProfile from "@/pages/user-profile";
import SubmitShow from "@/pages/submit-show";
import Research from "@/pages/research";
import ResearchDetail from "@/pages/research-detail";
import PrivacyPolicy from "@/pages/privacy-policy";
import TermsOfService from "@/pages/terms-of-service";
import CookieConsent from "@/components/CookieConsent";
import ResearchView from "@/pages/research-view";
import SharePage from "@/pages/share";
import AdminResearchLinks from "@/pages/admin-research-links";
import AdminResearchManager from "@/pages/admin-research-manager";
import CompleteRegistration from "@/pages/complete-registration";
import ColorPaletteCustomizer from "@/components/ColorPaletteCustomizer";
import { AuthProvider } from "@/hooks/use-auth";
import { ApprovedRoute } from "@/lib/protected-route-approved";
import { AdminRoute } from "@/lib/protected-route-admin";
import { ProtectedRoute } from "@/lib/protected-route";
import { useEffect } from "react";
import { initGA } from "./lib/analytics";
import { useAnalytics } from "./hooks/use-analytics";
import { initAdSense } from "./lib/adsense";

function Router() {
  // Track page views when routes change
  useAnalytics();
  
  // Access URL to check for development mode
  const isDevMode = window.location.search.includes('dev=true');
  
  // Check if user has early access token stored in localStorage
  const hasEarlyAccess = localStorage.getItem("earlyAccessShown") === "true";

  return (
    <div className="min-h-screen flex flex-col">
      <Switch>
        {/* Token Entry Page - Main landing page */}
        <Route path="/">
          <TokenEntryPage />
        </Route>
        
        {/* About Page - Open to everyone */}
        <Route path="/about">
          <div className="flex-grow flex flex-col">
            <Navbar />
            <div className="flex-grow">
              <About />
            </div>
            <Footer />
          </div>
        </Route>
        
        {/* Home Page - Accessible after token entry */}
        <Route path="/home">
          <div className="flex-grow flex flex-col">
            <Navbar />
            <div className="flex-grow">
              <Home />
            </div>
            <Footer />
          </div>
        </Route>
        <Route path="/early-access">
          <AuthPage />
        </Route>
        <Route path="/registration-pending">
          <RegistrationPendingPage />
        </Route>
        <Route path="/complete-registration">
          <CompleteRegistration />
        </Route>
        
        {/* Share page - accessible to all users */}
        <Route path="/share/:id">
          {(params) => (
            <SharePage />
          )}
        </Route>
        

        
        {/* Browse Page - Open to everyone */}
        <Route path="/browse">
          <div className="flex-grow flex flex-col">
            <Navbar />
            <div className="flex-grow">
              <Browse />
            </div>
            <Footer />
          </div>
        </Route>

        {/* Show Detail Pages - Open to everyone */}
        <Route path="/shows/:id">
          {(params) => (
            <div className="flex-grow flex flex-col">
              <Navbar />
              <div className="flex-grow">
                <Detail id={parseInt(params.id, 10)} />
              </div>
              <Footer />
            </div>
          )}
        </Route>
        <Route path="/detail/:id">
          {(params) => (
            <div className="flex-grow flex flex-col">
              <Navbar />
              <div className="flex-grow">
                <Detail id={parseInt(params.id, 10)} />
              </div>
              <Footer />
            </div>
          )}
        </Route>

        {/* Compare Page - Open to everyone */}
        <Route path="/compare">
          <div className="flex-grow flex flex-col">
            <Navbar />
            <div className="flex-grow">
              <Compare />
            </div>
            <Footer />
          </div>
        </Route>

        {isDevMode ? (
          <Route path="/app-about">
            <div className="flex-grow flex flex-col">
              <Navbar />
              <div className="flex-grow">
                <About />
              </div>
              <Footer />
            </div>
          </Route>
        ) : (
          <ApprovedRoute 
            path="/app-about" 
            component={() => (
              <div className="flex-grow flex flex-col">
                <Navbar />
                <div className="flex-grow">
                  <About />
                </div>
                <Footer />
              </div>
            )} 
          />
        )}

        {/* Auth page is always accessible */}
        <Route path="/auth">
          <div className="flex-grow flex flex-col">
            <Navbar />
            <div className="flex-grow">
              <AuthPage />
            </div>
            <Footer />
          </div>
        </Route>

        {/* Login page - redirect to auth */}
        <Route path="/login">
          <div className="flex-grow flex flex-col">
            <Navbar />
            <div className="flex-grow">
              <AuthPage />
            </div>
            <Footer />
          </div>
        </Route>

        {/* User Dashboard - Requires authentication */}
        <ProtectedRoute 
          path="/user-dashboard" 
          component={() => (
            <div className="flex-grow flex flex-col">
              <Navbar />
              <div className="flex-grow">
                <UserDashboard />
              </div>
              <Footer />
            </div>
          )} 
        />
        <ProtectedRoute 
          path="/dashboard" 
          component={() => (
            <div className="flex-grow flex flex-col">
              <Navbar />
              <div className="flex-grow">
                <UserDashboard />
              </div>
              <Footer />
            </div>
          )} 
        />
        <Route path="/user/:userId">
          {(params) => (
            <div className="flex-grow flex flex-col">
              <Navbar />
              <div className="flex-grow">
                <UserProfile />
              </div>
              <Footer />
            </div>
          )}
        </Route>

        {/* Submit Show - Requires authentication */}
        <ProtectedRoute 
          path="/submit-show" 
          component={() => (
            <div className="flex-grow flex flex-col">
              <Navbar />
              <div className="flex-grow">
                <SubmitShow />
              </div>
              <Footer />
            </div>
          )} 
        />

        {/* Research Pages */}
        <Route path="/research">
          <div className="flex-grow flex flex-col">
            <Navbar />
            <div className="flex-grow">
              <Research />
            </div>
            <Footer />
          </div>
        </Route>
        <Route path="/research/:id">
          {(params) => (
            <div className="flex-grow flex flex-col">
              <Navbar />
              <div className="flex-grow">
                <ResearchDetail id={parseInt(params.id, 10)} />
              </div>
              <Footer />
            </div>
          )}
        </Route>

        {/* Admin route with approval and admin check */}
        {isDevMode ? (
          <>
            <Route path="/admin">
              <div className="flex-grow flex flex-col">
                <Navbar />
                <div className="flex-grow">
                  <AdminPage />
                </div>
                <Footer />
              </div>
            </Route>
            <Route path="/admin/research">
              <div className="flex-grow flex flex-col">
                <Navbar />
                <div className="flex-grow">
                  <AdminResearchManager />
                </div>
                <Footer />
              </div>
            </Route>
          </>
        ) : (
          <>
            <AdminRoute 
              path="/admin" 
              component={() => (
                <div className="flex-grow flex flex-col">
                  <Navbar />
                  <div className="flex-grow">
                    <AdminPage />
                  </div>
                  <Footer />
                </div>
              )} 
            />
            <AdminRoute 
              path="/admin/research" 
              component={() => (
                <div className="flex-grow flex flex-col">
                  <Navbar />
                  <div className="flex-grow">
                    <AdminResearchManager />
                  </div>
                  <Footer />
                </div>
              )} 
            />
          </>
        )}

        {/* Legal Pages - Open to everyone */}
        <Route path="/privacy-policy">
          <div className="flex-grow flex flex-col">
            <Navbar />
            <div className="flex-grow">
              <PrivacyPolicy />
            </div>
            <Footer />
          </div>
        </Route>
        <Route path="/terms-of-service">
          <div className="flex-grow flex flex-col">
            <Navbar />
            <div className="flex-grow">
              <TermsOfService />
            </div>
            <Footer />
          </div>
        </Route>

        <Route>
          <NotFound />
        </Route>
      </Switch>
    </div>
  );
}

function App() {
  // Initialize Google Analytics and AdSense when app loads
  useEffect(() => {
    // Initialize Google Analytics
    if (!import.meta.env.VITE_GA_MEASUREMENT_ID) {
      console.warn('Missing required Google Analytics key: VITE_GA_MEASUREMENT_ID');
    } else {
      initGA();
    }

    // Initialize Google AdSense
    if (!import.meta.env.VITE_GOOGLE_ADSENSE_ID) {
      console.warn('Missing required Google AdSense key: VITE_GOOGLE_ADSENSE_ID');
    } else {
      initAdSense();
    }
  }, []);

  return (
    <QueryClientProvider client={queryClient}>
      <AuthProvider>
        <TooltipProvider>
          <Toaster />
          <Router />
          <CookieConsent />
          <ColorPaletteCustomizer />
        </TooltipProvider>
      </AuthProvider>
    </QueryClientProvider>
  );
}

export default App;
</file>

<file path="client/src/pages/home.tsx">
import { useState, useRef, useEffect } from "react";
import { useQuery } from "@tanstack/react-query";
import { useLocation, Link } from "wouter";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Badge } from "@/components/ui/badge";
import { Card, CardContent } from "@/components/ui/card";
import ShowCard from "@/components/ShowCard";
import { TvShow } from "@shared/schema";
import { Heart, Search, Star } from "lucide-react";
import { useAuth } from "@/hooks/use-auth";
import { useToast } from "@/hooks/use-toast";
import AdContainer from "@/components/AdContainer";
import {
  Carousel,
  CarouselContent,
  CarouselItem,
  CarouselNext,
  CarouselPrevious,
} from "@/components/ui/carousel";

// Badge progression system
const BADGE_PROGRESSION = [
  { name: "TV Watcher", emoji: "📺", points: 0 },
  { name: "Tablet Baby", emoji: "👶", points: 25 },
  { name: "TV Tamer", emoji: "🧑‍🧒", points: 50 },
  { name: "Algorithm Avoider", emoji: "🫷", points: 100 },
  { name: "Mood-Swing Mediator", emoji: "🧑‍⚖️", points: 200 },
  { name: "Rhythm Regulator", emoji: "🪪", points: 300 },
  { name: "Pixel Protector", emoji: "🥽", points: 400 },
  { name: "Screen-Time Sherpa", emoji: "🤝", points: 500 },
  { name: "Programme Peacekeeper", emoji: "✌️", points: 750 },
  { name: "Calm-Ware Engineer", emoji: "🧑‍🔧", points: 1000 },
  { name: "Digital Diplomat", emoji: "🧑‍💼", points: 1250 },
  { name: "Sensory Sentinel", emoji: "🦾", points: 1500 },
  { name: "Guardian of the Glow", emoji: "🥷", points: 1750 },
  { name: "Screen Sensei", emoji: "🧘", points: 2000 }
];

// Helper function to get badge emoji based on points
const getBadgeEmoji = (points: number) => {
  const sorted = [...BADGE_PROGRESSION].reverse();
  const badge = sorted.find(badge => points >= badge.points) || BADGE_PROGRESSION[0];
  return badge.emoji;
};

// Helper function to get badge name based on points
const getBadgeName = (points: number) => {
  const sorted = [...BADGE_PROGRESSION].reverse();
  const badge = sorted.find(badge => points >= badge.points) || BADGE_PROGRESSION[0];
  return badge.name;
};

export default function Home() {
  const [_, setLocation] = useLocation();
  const [searchQuery, setSearchQuery] = useState("");
  const [showResults, setShowResults] = useState(false);
  const [isMobile, setIsMobile] = useState(false);
  const { user, toggleFavorite, isFavorite } = useAuth();
  const { toast } = useToast();
  
  // Hide results when clicking outside
  useEffect(() => {
    const handleClickOutside = () => setShowResults(false);
    document.addEventListener('click', handleClickOutside);
    return () => document.removeEventListener('click', handleClickOutside);
  }, []);
  
  // Effect to detect mobile screen size
  useEffect(() => {
    const checkMobile = () => {
      const isMobileView = window.innerWidth < 640; // sm breakpoint in Tailwind
      setIsMobile(isMobileView);
    };
    
    // Check initially
    checkMobile();
    
    // Add resize listener
    window.addEventListener('resize', checkMobile);
    
    // Clean up
    return () => window.removeEventListener('resize', checkMobile);
  }, []);
  
  // Fetch all TV shows
  const { data: allShows, isLoading: allShowsLoading } = useQuery<TvShow[]>({
    queryKey: ['/api/tv-shows'],
    staleTime: 60000, // 1 minute
  });
  
  // Fetch popular shows from view count tracking data
  const { data: popularShowsData, isLoading: popularShowsLoading } = useQuery<TvShow[]>({
    queryKey: ['/api/shows/popular', { limit: 24 }],
    staleTime: 60000, // 1 minute
  });

  // Fetch highly rated shows from review data
  const { data: highlyRatedShowsData, isLoading: highlyRatedShowsLoading } = useQuery<TvShow[]>({
    queryKey: ['/api/shows/highly-rated', { limit: 24 }],
    staleTime: 60000, // 1 minute
  });
  
  // Combined loading state
  const isLoading = allShowsLoading || popularShowsLoading || highlyRatedShowsLoading;
  
  // Fetch the featured show from the database
  const { data: featuredShowData } = useQuery<TvShow>({
    queryKey: ['/api/shows/featured'],
    staleTime: 60000, // 1 minute
  });
  
  // Use featured show from database, fallback to first show if none is featured
  const featuredShow = featuredShowData || allShows?.[0];
  
  // Track the favorite status of the featured show
  const [isFeaturedShowFavorite, setIsFeaturedShowFavorite] = useState(false);
  
  // Track the review statistics for the featured show
  const [featuredShowReviewStats, setFeaturedShowReviewStats] = useState<{reviewCount: number, avgRating: number} | null>(null);
  
  // Check favorite status when featured show is loaded and user is logged in
  useEffect(() => {
    // Reset favorite status when user logs out
    if (!user) {
      setIsFeaturedShowFavorite(false);
      return;
    }
    
    // Only check favorite status if featured show exists and user is logged in
    if (featuredShow && user) {
      const checkFavoriteStatus = async () => {
        try {
          // Safe check to ensure featuredShow.id exists
          if (!featuredShow.id) return;
          
          const isFav = await isFavorite(featuredShow.id);
          setIsFeaturedShowFavorite(isFav);
        } catch (error) {
          console.error("Error checking favorite status:", error);
          // Set to false on error to be safe
          setIsFeaturedShowFavorite(false);
        }
      };
      
      checkFavoriteStatus();
    }
  }, [featuredShow, user, isFavorite]);
  
  // Fetch review statistics for the featured show
  useEffect(() => {
    if (featuredShow?.id) {
      const fetchFeaturedShowReviewStats = async () => {
        try {
          const response = await fetch(`/api/reviews/${featuredShow.id}`, {
            credentials: 'include'
          });
          if (response.ok) {
            const reviews = await response.json();
            if (reviews && reviews.length > 0) {
              const totalRating = reviews.reduce((sum: number, review: any) => sum + review.rating, 0);
              const avgRating = totalRating / reviews.length;
              setFeaturedShowReviewStats({
                reviewCount: reviews.length,
                avgRating: Math.round(avgRating * 10) / 10 // Round to 1 decimal place
              });
            } else {
              setFeaturedShowReviewStats({ reviewCount: 0, avgRating: 0 });
            }
          }
        } catch (error) {
          console.error('Error fetching featured show review stats:', error);
          setFeaturedShowReviewStats({ reviewCount: 0, avgRating: 0 });
        }
      };
      fetchFeaturedShowReviewStats();
    }
  }, [featuredShow?.id]);
  
  // Helper function to check if property exists with different case formats
  const getShowProperty = (show: any, propertyNames: string[]) => {
    for (const prop of propertyNames) {
      if (show[prop] !== undefined) {
        return show[prop];
      }
    }
    return null;
  };

  // Shuffle function to randomize show order for home page carousels
  const shuffleArray = (array: any[]) => {
    const shuffled = [...array];
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
  };

  // Filter shows by categories - ensure at least 24 shows per category for better browsing
  const lowStimulationShows = shuffleArray(allShows?.filter(show => {
    const stimulationScore = getShowProperty(show, ['stimulationScore', 'stimulation_score']);
    return stimulationScore !== null && stimulationScore <= 2;
  }) || []).slice(0, 24);
  
  // Use highly rated shows data from user review ratings
  const highlyRatedShows = highlyRatedShowsData;
  
  // Use popular shows data from view count tracking
  const popularShows = popularShowsData;
  
  // Get high interaction shows
  const highInteractionShows = allShows?.filter(show => {
    const interactivityLevel = getShowProperty(show, ['interactivityLevel', 'interactivity_level', 'interactionLevel']);
    
    if (!interactivityLevel) return false;
    
    // Check for any variation of "High" interactivity
    return interactivityLevel === 'High' || 
           interactivityLevel.includes('High') || 
           interactivityLevel === 'Moderate-High' || 
           interactivityLevel === 'Moderate to High' ||
           interactivityLevel === 'Mod-High';
  }).slice(0, 24);
  
  // Find shows by educational themes using OR logic with actual database themes
  const educationalShows = shuffleArray(allShows?.filter(show => {
    const themes = getShowProperty(show, ['themes']);
    if (!themes || !Array.isArray(themes)) return false;
    
    return themes.some((theme: string) => {
      const lowerTheme = theme.toLowerCase();
      return lowerTheme.includes('elementary-basics') || 
             lowerTheme.includes('preschool-basics') ||
             lowerTheme.includes('stem') ||
             lowerTheme.includes('science') ||
             lowerTheme.includes('math') ||
             lowerTheme.includes('literacy') ||
             lowerTheme.includes('numeracy') ||
             lowerTheme.includes('reading comprehension') ||
             lowerTheme.includes('phonics') ||
             lowerTheme.includes('language learning') ||
             lowerTheme.includes('learn through play') ||
             lowerTheme.includes('learning through songs') ||
             lowerTheme.includes('learning from mistakes') ||
             lowerTheme.includes('learning disabilities') ||
             lowerTheme.includes('vocabulary') ||
             lowerTheme.includes('critical thinking') ||
             lowerTheme.includes('problem solving') ||
             lowerTheme.includes('problem-solving') ||
             lowerTheme.includes('cognitive development');
    });
  }) || []).slice(0, 24);
  
  const adventureShows = shuffleArray(allShows?.filter(show => {
    const themes = getShowProperty(show, ['themes']);
    if (!themes || !Array.isArray(themes)) return false;
    
    return themes.some((theme: string) => {
      const lowerTheme = theme.toLowerCase();
      return lowerTheme.includes('adventure') ||
             lowerTheme.includes('exploration') ||
             lowerTheme.includes('discovery') ||
             lowerTheme.includes('outdoor exploration') ||
             lowerTheme.includes('wildlife exploration') ||
             lowerTheme.includes('sensory exploration') ||
             lowerTheme.includes('career exploration') ||
             lowerTheme.includes('courage');
    });
  }) || []).slice(0, 24);
  
  const musicalShows = shuffleArray(allShows?.filter(show => {
    const themes = getShowProperty(show, ['themes']);
    if (!themes || !Array.isArray(themes)) return false;
    
    return themes.some((theme: string) => {
      const lowerTheme = theme.toLowerCase();
      return lowerTheme.includes('music') ||
             lowerTheme.includes('dance') ||
             lowerTheme.includes('learning through songs') ||
             lowerTheme.includes('sing-a-long') ||
             lowerTheme.includes('instruments');
    });
  }) || []).slice(0, 24);
  
  const fantasyShows = shuffleArray(allShows?.filter(show => {
    const themes = getShowProperty(show, ['themes']);
    if (!themes || !Array.isArray(themes)) return false;
    
    return themes.some((theme: string) => {
      const lowerTheme = theme.toLowerCase();
      return lowerTheme.includes('fantasy elements') ||
             lowerTheme.includes('mild fantasy violence') ||
             lowerTheme.includes('super hero themes');
    });
  }) || []).slice(0, 24);
  
  const preschoolerShows = shuffleArray(allShows?.filter(show => {
    const ageRange = getShowProperty(show, ['ageRange', 'age_range']);
    if (!ageRange) return false;
    
    // Handle different age range formats for ages 2-4
    const ageRangeLower = ageRange.toLowerCase();
    
    // Direct matches for 2-4 range
    if (ageRangeLower.includes('2-4') || ageRangeLower.includes('preschool')) return true;
    
    // Handle ranges like "0-2", "3-5", "2-6", etc. that overlap with 2-4
    const rangeMatch = ageRange.match(/(\d+)-(\d+)/);
    if (rangeMatch) {
      const minAge = parseInt(rangeMatch[1]);
      const maxAge = parseInt(rangeMatch[2]);
      // Show overlaps with 2-4 range if: minAge <= 4 AND maxAge >= 2
      return minAge <= 4 && maxAge >= 2;
    }
    
    // Handle single ages like "3", "4"
    const singleAgeMatch = ageRange.match(/^(\d+)$/);
    if (singleAgeMatch) {
      const age = parseInt(singleAgeMatch[1]);
      return age >= 2 && age <= 4;
    }
    
    return false;
  }) || []).slice(0, 24);
  
  // Filter shows based on search term
  const filteredShows = allShows ? allShows.filter((show: TvShow) => {
    if (!searchQuery.trim()) return false;
    if (!show || !show.name) return false; // Safety check
    
    const searchLower = searchQuery.toLowerCase().trim();
    const nameLower = show.name.toLowerCase();
    
    // Direct match in name
    if (nameLower.includes(searchLower)) return true;
    
    // Handle shows with year ranges
    const nameWithoutYears = nameLower.replace(/\s+\d{4}(-\d{4}|-present)?/g, '');
    if (nameWithoutYears.includes(searchLower)) return true;
    
    // Match any part of a word
    const words = nameLower.split(/\s+/);
    if (words.some((word: string) => word.includes(searchLower))) return true;
    
    // Handle apostrophes and special characters
    const simplifiedName = nameLower.replace(/[''\.]/g, '');
    if (simplifiedName.includes(searchLower)) return true;
    
    return false;
  }).slice(0, 6) : [];

  const handleSearch = (e: React.FormEvent) => {
    e.preventDefault();
    if (searchQuery.trim()) {
      // For all searches, direct to browse page with search filter
      setLocation(`/browse?search=${encodeURIComponent(searchQuery.trim())}`);
      setShowResults(false);
    }
  };
  
  const handleShowCardClick = (id: number) => {
    // Scroll to top first, then navigate
    window.scrollTo(0, 0);
    setLocation(`/shows/${id}`);
  };
  
  const renderCategorySection = (title: string, description: string, shows: TvShow[] | undefined, viewAllLink: string) => (
    <section className="mb-12">
      <div className="flex justify-between items-center mb-4">
        <div>
          <h2 className="text-xl font-heading font-bold text-gray-900">{title}</h2>
          <p className="text-sm text-gray-600">{description}</p>
        </div>
        <Button 
          variant="link" 
          className="text-primary-600 hover:text-primary-800"
          onClick={() => setLocation(viewAllLink)}
        >
          View All →
        </Button>
      </div>
      
      {isLoading ? (
        // Placeholder loading state
        <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6">
          {Array(4).fill(0).map((_, i) => (
            <Card key={i} className="bg-gray-100 animate-pulse h-64"></Card>
          ))}
        </div>
      ) : shows?.length ? (
        <div className="relative">
          <Carousel
            opts={{
              align: "start",
              loop: true,
              dragFree: true,
              containScroll: "trimSnaps",
              slidesToScroll: 3
            }}
            className="w-full"
          >
            <CarouselContent className="-ml-2 md:-ml-4">
              {shows.map((show) => (
                <CarouselItem key={show.id} className={`pl-2 md:pl-4 ${isMobile ? 'basis-1/3' : 'md:basis-1/4 lg:basis-1/5'}`}>
                  <ShowCard 
                    show={show} 
                    viewMode="grid"
                    isMobile={isMobile}
                    onClick={() => handleShowCardClick(show.id)}
                  />
                </CarouselItem>
              ))}
            </CarouselContent>
            <div className="flex justify-end gap-2 mt-4">
              <CarouselPrevious className="static translate-y-0 mr-0" />
              <CarouselNext className="static translate-y-0" />
            </div>
          </Carousel>
        </div>
      ) : (
        <div className="text-center py-8 text-gray-500">
          No shows found in this category.
        </div>
      )}
    </section>
  );
  
  return (
    <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
      {/* Hero Section */}
      <div className="bg-white rounded-xl p-8 mb-12 text-center">
        <h1 className="text-3xl md:text-4xl font-heading font-bold mb-3">
          Screen Time Stimulation Scores
        </h1>
        <p className="text-gray-600 mb-6 max-w-2xl mx-auto">
          Find TV shows measured by stimulation levels, helping you discover content
          that fits your child's needs.
        </p>
        
        <form onSubmit={handleSearch} className="relative max-w-md mx-auto" onClick={(e) => e.stopPropagation()}>
          <div className="flex">
            <div className="relative flex-grow">
              <Search className="absolute left-3 top-3 h-4 w-4 text-gray-500" />
              <Input 
                type="text" 
                placeholder="Search show by name, theme, platform..." 
                className="rounded-r-none pl-10"
                value={searchQuery}
                onChange={(e) => {
                  setSearchQuery(e.target.value);
                  // Show results dropdown if there's text to search
                  if (e.target.value.trim().length > 0) {
                    setShowResults(true);
                  } else {
                    setShowResults(false);
                  }
                }}
                onFocus={() => {
                  if (searchQuery.trim().length > 0) {
                    setShowResults(true);
                  }
                }}
              />
              
              {/* Search Results Dropdown */}
              {showResults && searchQuery.trim().length > 0 && (
                <div className="absolute z-50 mt-1 w-full bg-white rounded-md shadow-lg max-h-60 overflow-auto border border-gray-200">
                  <div className="py-1">
                    {filteredShows?.length ? (
                      filteredShows.map((show: TvShow) => (
                        <div
                          key={show.id}
                          className="px-4 py-2 hover:bg-gray-100 cursor-pointer"
                          onClick={() => {
                            setSearchQuery(show.name);
                            setShowResults(false);
                            setLocation(`/browse?search=${encodeURIComponent(show.name)}`);
                          }}
                        >
                          <div className="font-medium">{show.name}</div>
                          <div className="text-xs text-gray-500">
                            Ages: {show.ageRange || 'Unknown'} 
                            {show.stimulationScore ? ` • Stimulation: ${show.stimulationScore}` : ''}
                          </div>
                        </div>
                      ))
                    ) : (
                      <div className="px-4 py-2 text-sm text-gray-500">
                        No shows match your search
                      </div>
                    )}
                  </div>
                </div>
              )}
            </div>
            <Button type="submit" className="rounded-l-none">
              <i className="fas fa-search mr-2"></i> Search
            </Button>
          </div>
        </form>
      </div>
      
      {/* Top Banner Ad */}
      <div className="mb-8">
        <AdContainer size="banner" className="mx-auto" />
      </div>
      
      {/* Featured Show */}
      {featuredShow && (
        <div className="bg-indigo-50 rounded-xl overflow-hidden mb-12">
          <div className="flex flex-col md:flex-row">
            <div className="md:w-1/4 p-6">
              <div className="mb-2">
                <Badge variant="outline" className="bg-purple-100 text-purple-800 uppercase text-xs font-bold tracking-wide">
                  Featured Listing
                </Badge>
              </div>
              {featuredShow.imageUrl ? (
                <img 
                  src={featuredShow.imageUrl} 
                  alt={featuredShow.name} 
                  className="w-full aspect-[3/4] object-cover rounded-md shadow-lg"
                />
              ) : (
                <div className="w-full aspect-[3/4] bg-gray-200 rounded-md shadow-lg flex items-center justify-center">
                  <i className="fas fa-tv text-gray-400 text-5xl"></i>
                </div>
              )}
            </div>
            
            <div className="md:w-3/4 p-6">
              <h2 className="text-2xl font-heading font-bold mb-2 text-gray-900">
                {featuredShow.name}
              </h2>
              <div className="mb-3">
                <Badge variant="outline" className="bg-green-100 text-green-800 mr-2">
                  Ages {featuredShow.ageRange}
                </Badge>
                
                {/* Review Statistics */}
                {featuredShowReviewStats && featuredShowReviewStats.reviewCount > 0 && (
                  <div className="inline-flex items-center gap-1 mr-2">
                    <Star className="w-4 h-4 fill-yellow-400 text-yellow-400" />
                    <span className="font-medium text-sm">{featuredShowReviewStats.avgRating}</span>
                    <span className="text-gray-500 text-sm">({featuredShowReviewStats.reviewCount} review{featuredShowReviewStats.reviewCount !== 1 ? 's' : ''})</span>
                  </div>
                )}
                
                <div className="inline-flex items-center">
                  <div className="flex items-center mr-2">
                    {Array(5).fill(0).map((_, i) => {
                      const scoreColors = [
                        'bg-green-500 border-green-500',    // green for 1
                        'bg-yellow-500 border-yellow-500',  // yellow for 2
                        'bg-orange-500 border-orange-500',  // orange for 3
                        'bg-orange-600 border-orange-600',  // dark orange for 4
                        'bg-red-500 border-red-500'         // red for 5
                      ];
                      const color = scoreColors[i];
                      const isActive = i < featuredShow.stimulationScore;
                      return (
                        <div 
                          key={i} 
                          className={`w-3 h-3 rounded-full mx-0.5 ${
                            isActive ? color.split(' ')[0] : `border-2 ${color.split(' ')[1]} bg-white`
                          }`}
                        />
                      );
                    })}
                  </div>
                  <span className="text-sm text-gray-600">
                    {featuredShow.stimulationScore === 1 ? 'Low' : 
                     featuredShow.stimulationScore === 2 ? 'Low-Medium' : 
                     featuredShow.stimulationScore === 3 ? 'Medium' : 
                     featuredShow.stimulationScore === 4 ? 'Medium-High' : 
                     'High'} Stimulation
                  </span>
                </div>
              </div>
              
              <p className="text-gray-700 mb-4">
                {featuredShow.description}
              </p>
              
              <div className="mb-4">
                <h3 className="font-medium text-gray-900 mb-2">Key Themes:</h3>
                <div className="flex flex-wrap gap-1">
                  {featuredShow.themes?.map((theme, index) => (
                    <Badge key={index} variant="outline" className="bg-gray-100 text-gray-800">
                      {theme}
                    </Badge>
                  ))}
                </div>
              </div>
              
              <div className="flex flex-col sm:flex-row items-start sm:items-center gap-2">
                <Button 
                  variant="ghost" 
                  size="sm"
                  className={`${isFeaturedShowFavorite ? 'text-red-500' : 'text-gray-400 hover:text-red-500'}`}
                  onClick={(e) => {
                    e.stopPropagation();
                    if (user) {
                      toggleFavorite(featuredShow.id).then(() => {
                        // Toggle the local state (optimistic update)
                        setIsFeaturedShowFavorite(!isFeaturedShowFavorite);
                        
                        toast({
                          title: isFeaturedShowFavorite ? "Removed from favorites" : "Added to favorites",
                          description: isFeaturedShowFavorite 
                            ? `${featuredShow.name} has been removed from your favorites.` 
                            : `${featuredShow.name} has been added to your favorites.`,
                          variant: "default",
                        });
                      });
                    } else {
                      toast({
                        title: "Authentication required",
                        description: "Please log in or register to save shows to your favorites.",
                        variant: "default",
                      });
                      setLocation("/auth");
                    }
                  }}
                >
                  <Heart className={`w-5 h-5 mr-1 ${isFeaturedShowFavorite ? 'fill-red-500 text-red-500' : ''}`} />
                  {isFeaturedShowFavorite ? 'Saved' : 'Add to Favorites'}
                </Button>
                <Button 
                  onClick={() => handleShowCardClick(featuredShow.id)}
                >
                  View Show Details
                </Button>
              </div>
            </div>
          </div>
        </div>
      )}
      
      {/* Explore Categories */}
      <section className="mb-12">
        <h2 className="text-2xl font-heading font-bold mb-6 text-gray-900">Explore Categories</h2>
        <div className="grid grid-cols-1 md:grid-cols-4 gap-6">
          <Card 
            className="hover:shadow-lg transition-shadow cursor-pointer bg-green-50" 
            onClick={() => setLocation(`/browse?stimulationScoreRange=${encodeURIComponent(JSON.stringify({min: 1, max: 2}))}`)}
          >
            <CardContent className="p-6 text-center">
              <div className="inline-flex p-3 rounded-full bg-green-100 text-green-600 mb-3">
                <i className="fas fa-leaf text-2xl"></i>
              </div>
              <h3 className="font-heading font-bold mb-2">Lower Stimulation</h3>
              <p className="text-sm text-gray-600">Shows with calm pacing for sensitive viewers (1-2)</p>
            </CardContent>
          </Card>
          
          <Card 
            className="hover:shadow-lg transition-shadow cursor-pointer bg-blue-50" 
            onClick={() => setLocation("/browse?sortBy=stimulationScore&sortDirection=asc")}
          >
            <CardContent className="p-6 text-center">
              <div className="inline-flex p-3 rounded-full bg-blue-100 text-blue-600 mb-3">
                <i className="fas fa-star text-2xl"></i>
              </div>
              <h3 className="font-heading font-bold mb-2">Highly Rated</h3>
              <p className="text-sm text-gray-600">Shows with top ratings from our parent reviewers</p>
            </CardContent>
          </Card>
          
          <Card 
            className="hover:shadow-lg transition-shadow cursor-pointer bg-purple-50" 
            onClick={() => setLocation("/browse?interactionLevel=High")}
          >
            <CardContent className="p-6 text-center">
              <div className="inline-flex p-3 rounded-full bg-purple-100 text-purple-600 mb-3">
                <i className="fas fa-gamepad text-2xl"></i>
              </div>
              <h3 className="font-heading font-bold mb-2">Higher Interaction</h3>
              <p className="text-sm text-gray-600">Shows that encourage audience participation</p>
            </CardContent>
          </Card>
          
          <Card 
            className="hover:shadow-lg transition-shadow cursor-pointer bg-amber-50" 
            onClick={() => setLocation("/browse?sortBy=popular")}
          >
            <CardContent className="p-6 text-center">
              <div className="inline-flex p-3 rounded-full bg-amber-100 text-amber-600 mb-3">
                <i className="fas fa-fire text-2xl"></i>
              </div>
              <h3 className="font-heading font-bold mb-2">Popular</h3>
              <p className="text-sm text-gray-600">Shows our community watches and searches for the most</p>
            </CardContent>
          </Card>
        </div>
      </section>
      
      {/* Popular Shows */}
      {renderCategorySection(
        "Popular Shows", 
        "Most-viewed shows across all age groups", 
        popularShows, 
        "/browse?sortBy=popular"
      )}
      
      {/* Mid-Content Ad */}
      <div className="my-8">
        <AdContainer size="rectangle" className="mx-auto" />
      </div>
      
      {/* Highly Rated */}
      {renderCategorySection(
        "Highly Rated Shows",
        "Top-rated shows across all categories", 
        highlyRatedShows,
        "/browse?sortBy=rating&sortDirection=desc"
      )}
      
      {/* Lower Stimulation */}
      {renderCategorySection(
        "Lower Stimulation (Scores 1-2)",
        "Calmer shows with gentle pacing, perfect for sensitive viewers", 
        lowStimulationShows, 
        `/browse?stimulationScoreRange=${encodeURIComponent(JSON.stringify({min: 1, max: 2}))}`
      )}
      
      {/* Higher Interaction */}
      {highInteractionShows && highInteractionShows.length > 0 && renderCategorySection(
        "Higher Interaction",
        "Shows that encourage audience participation and engagement", 
        highInteractionShows, 
        "/browse?interactionLevel=High"
      )}
      
      {/* Educational Shows */}
      {educationalShows && educationalShows.length > 0 && renderCategorySection(
        "Educational Shows",
        "Shows that focus on learning and educational content", 
        educationalShows, 
        "/browse?themes=Elementary-Basics,Preschool-Basics,STEM,Science,Math,Literacy,Numeracy,Reading Comprehension,Phonics,Language Learning,Learn Through Play,Learning through Songs,Learning from Mistakes,Learning Disabilities,Vocabulary,Critical Thinking,Problem Solving,Problem-Solving,Cognitive Development&themeMatchMode=OR"
      )}
      
      {/* Adventure Shows */}
      {adventureShows && adventureShows.length > 0 && renderCategorySection(
        "Adventure Shows",
        "Shows focused on exploration, excitement and adventures", 
        adventureShows, 
        "/browse?themes=Adventure,Exploration,Discovery,Outdoor Exploration,Wildlife Exploration,Sensory Exploration,Career Exploration&themeMatchMode=OR"
      )}
      
      {/* Musical Shows */}
      {musicalShows && musicalShows.length > 0 && renderCategorySection(
        "Musical Shows",
        "Shows featuring songs, musical numbers and rhythmic content", 
        musicalShows, 
        "/browse?themes=Music,Dance,Learning through Songs,sing-a-long&themeMatchMode=OR"
      )}
      
      {/* Fantasy Shows */}
      {fantasyShows && fantasyShows.length > 0 && renderCategorySection(
        "Fantasy Shows",
        "Shows with magical, imaginative and fantasy elements", 
        fantasyShows, 
        "/browse?themes=Fantasy Elements,Mild Fantasy Violence,Super Hero Themes&themeMatchMode=OR"
      )}
      
      {/* Preschooler Shows */}
      {preschoolerShows && preschoolerShows.length > 0 && renderCategorySection(
        "Preschoolers",
        "Shows specifically designed for children ages 2-4", 
        preschoolerShows, 
        `/browse?ageRange=${encodeURIComponent(JSON.stringify({min: 2, max: 4}))}`
      )}

      {/* Leaderboard Section */}
      <Leaderboard />
    </main>
  );
}

// Leaderboard Component
function Leaderboard() {
  const { user } = useAuth();
  const [, setLocation] = useLocation();
  const { data: leaderboard, isLoading } = useQuery<any[]>({
    queryKey: ['/api/leaderboard'],
    staleTime: 30000, // 30 seconds - reduced to see background color changes faster
  });

  if (isLoading) {
    return (
      <section className="py-12 bg-gradient-to-r from-purple-50 to-blue-50">
        <div className="container mx-auto px-4">
          <div className="text-center">
            <h2 className="text-2xl font-bold text-gray-900 mb-8">Community Leaders</h2>
            <div className="flex justify-center items-center space-x-2">
              <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-purple-600"></div>
              <span className="text-gray-600">Loading leaderboard...</span>
            </div>
          </div>
        </div>
      </section>
    );
  }

  if (!leaderboard || leaderboard.length === 0) {
    return null;
  }

  return (
    <section className="py-12 bg-gradient-to-r from-purple-50 to-blue-50">
      <div className="container mx-auto px-4">
        <div className="text-center mb-8">
          <h2 className="text-2xl font-bold text-gray-900 mb-2">Community Leaders</h2>
          <p className="text-gray-600">Top contributors earning points through reviews, referrals, and community engagement</p>
        </div>
        
        <div className="max-w-4xl mx-auto relative">
          <div className="bg-white rounded-lg shadow-md overflow-hidden">
            <div className={`grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 p-6 ${!user ? 'blur-sm' : ''}`}>
              {leaderboard.slice(0, 9).map((user, index) => (
                <div 
                  key={user.id} 
                  className={`flex items-center space-x-4 p-4 rounded-lg transition-all duration-200 hover:shadow-md ${
                    index === 0 ? 'bg-gradient-to-r from-yellow-100 to-yellow-50 border-2 border-yellow-300' :
                    index === 1 ? 'bg-gradient-to-r from-gray-100 to-gray-50 border-2 border-gray-300' :
                    index === 2 ? 'bg-gradient-to-r from-orange-100 to-orange-50 border-2 border-orange-300' :
                    'bg-gray-50 border border-gray-200'
                  }`}
                >
                  <div className="flex-shrink-0 relative">
                    <div className={`w-10 h-10 rounded-full flex items-center justify-center text-lg relative ${
                      user.backgroundColor || 'bg-purple-500'
                    }`}>
                      {getBadgeEmoji(user.totalPoints || user.total_points)}
                      
                      {/* Ranking badges for top 3 */}
                      {index < 3 && (
                        <div className="absolute -top-1 -right-1 text-sm">
                          {index === 0 ? '🥇' : index === 1 ? '🥈' : '🥉'}
                        </div>
                      )}
                      
                      {/* Position number for others */}
                      {index >= 3 && (
                        <div className="absolute -top-1 -right-1 bg-gray-800 text-white text-xs rounded-full w-5 h-5 flex items-center justify-center font-bold">
                          {index + 1}
                        </div>
                      )}
                    </div>
                  </div>
                  
                  <div className="flex-1 min-w-0">
                    <Link href={`/user/${user.id}`}>
                      <h3 className="text-sm font-semibold text-gray-900 truncate hover:text-purple-600 cursor-pointer transition-colors">
                        {user.username || 'Anonymous User'}
                      </h3>
                    </Link>
                    <p className="text-xs text-purple-600 font-medium truncate">
                      {getBadgeName(user.totalPoints || user.total_points)}
                    </p>
                    <div className="flex items-center space-x-2">
                      <span className="text-lg font-bold text-purple-600">
                        {user.totalPoints || user.total_points || 0}
                      </span>
                      <span className="text-xs text-gray-500">points</span>
                    </div>
                    {user.country && (
                      <span className="text-xs text-gray-400 truncate">
                        {user.country}
                      </span>
                    )}
                  </div>
                </div>
              ))}
            </div>
            
            {leaderboard.length > 9 && (
              <div className={`bg-gray-50 px-6 py-3 text-center ${!user ? 'blur-sm' : ''}`}>
                <p className="text-sm text-gray-600">
                  And {leaderboard.length - 9} more amazing community members!
                </p>
              </div>
            )}
          </div>

          {/* Registration Call-to-Action Overlay for Non-Registered Users */}
          {!user && (
            <div className="absolute inset-0 flex items-center justify-center bg-white/80 rounded-lg">
              <div className="text-center p-8 max-w-md">
                <div className="mb-4">
                  <div className="w-16 h-16 mx-auto mb-4 bg-gradient-to-r from-purple-500 to-blue-500 rounded-full flex items-center justify-center">
                    <Star className="w-8 h-8 text-white" />
                  </div>
                  <h3 className="text-xl font-bold text-gray-900 mb-2">Join Our Community</h3>
                  <p className="text-gray-600 mb-6">
                    Register to see community rankings, earn points through reviews, and compete with other parents for the top spots!
                  </p>
                </div>
                <div className="space-y-3">
                  <Button 
                    onClick={() => setLocation("/auth")}
                    className="w-full bg-gradient-to-r from-purple-600 to-blue-600 hover:from-purple-700 hover:to-blue-700"
                  >
                    Register Now
                  </Button>
                  <Button 
                    variant="outline" 
                    onClick={() => setLocation("/auth")}
                    className="w-full"
                  >
                    Already have an account? Sign In
                  </Button>
                </div>
              </div>
            </div>
          )}
        </div>
      </div>
    </section>
  );
}
</file>

<file path="client/src/pages/token-entry.tsx">
import { useState, useEffect } from "react";
import { useLocation } from "wouter";
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { useToast } from "@/hooks/use-toast";
import { useAuth } from "@/hooks/use-auth";

export default function TokenEntryPage() {
  const [token, setToken] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [, setLocation] = useLocation();
  const { toast } = useToast();
  const { user } = useAuth();
  
  const expectedToken = "2025";

  // If user is already logged in, redirect to home
  useEffect(() => {
    if (user) {
      setLocation("/home");
    }
  }, [user, setLocation]);

  // Enable automatic redirect when a valid token exists
  useEffect(() => {
    const storedToken = localStorage.getItem("earlyAccessToken");
    if (storedToken === expectedToken) {
      // Redirect to home page when token is already stored
      setLocation("/home");
    }
  }, [setLocation]);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    setIsLoading(true);
    
    // Simulate API check with a timeout
    setTimeout(() => {
      if (token.trim().toLowerCase() === expectedToken.toLowerCase()) {
        // Store token in localStorage for persistence
        localStorage.setItem("earlyAccessToken", expectedToken);
        toast({
          title: "Welcome to TV Tantrum!",
          description: "Your access token has been verified. You can now browse our content!",
          variant: "default"
        });
        
        // Show additional welcome notification encouraging registration
        setTimeout(() => {
          toast({
            title: "💡 Pro Tip: Register for FREE!",
            description: "Create an account to save favorites, leave reviews, earn points, and get personalized recommendations!",
            variant: "default"
          });
        }, 2000);
        
        // Redirect to home page after successful verification
        setLocation("/home");
      } else {
        toast({
          title: "Invalid Token",
          description: "The token you entered is not valid. Please check and try again.",
          variant: "destructive"
        });
      }
      setIsLoading(false);
    }, 800);
  };

  return (
    <div className="min-h-screen bg-gradient-to-b from-primary to-primary-800 py-8 px-4 overflow-y-auto">
      <div className="max-w-lg mx-auto space-y-6">
        {/* Main token entry card */}
        <Card className="w-full shadow-xl">
          <CardHeader className="space-y-1 text-center">
            <CardTitle className="text-2xl font-bold">Welcome to TV Tantrum</CardTitle>
            <CardDescription>
              The waiting list is now closed. Enter your exclusive access token to continue.
            </CardDescription>
            <div className="bg-orange-50 border border-orange-200 rounded-md p-3 mt-4">
              <p className="text-sm text-orange-800">
                <strong>Waiting List Closed:</strong> We've reached 5,000 members! If you have a token code, enter it below to access the platform.
              </p>
            </div>
          </CardHeader>
          <form onSubmit={handleSubmit}>
            <CardContent className="space-y-4">
              <div className="space-y-2">
                <Input
                  id="token"
                  placeholder="Enter your access token"
                  value={token}
                  onChange={(e) => setToken(e.target.value)}
                  className="w-full"
                  required
                />
              </div>
            </CardContent>
            <CardFooter className="flex flex-col space-y-4">
              <Button 
                type="submit" 
                className="w-full" 
                disabled={isLoading || !token.trim()}
              >
                {isLoading ? "Verifying..." : "Verify Token"}
              </Button>
            </CardFooter>
          </form>
        </Card>
        
        {/* Benefits section */}
        <div className="bg-gray-50 border border-gray-200 rounded-md p-6">
          <h3 className="text-lg font-semibold text-gray-900 mb-4">Upon entry you will be able to:</h3>
          <ul className="text-sm text-gray-700 space-y-2 mb-6">
            <li>- Browse and search all TV shows</li>
            <li>- View stimulation scores and details</li>
            <li>- Compare shows side-by-side</li>
            <li>- See reviews</li>
          </ul>
          
          <p className="text-sm text-gray-800 font-medium mb-4">
            However, we encourage you to register for free for all these added benefits
          </p>
          
          <ul className="text-sm text-blue-800 space-y-2 mb-4">
            <li>• Select favourites for personalized recommendations</li>
            <li>• Submit shows for analysis and build our database</li>
            <li>• Access research articles</li>
            <li>• Rate shows and leave reviews</li>
          </ul>
          
          <p className="text-sm text-blue-700 font-medium">
            Become a contributor to the TV Tantrum project and help make screen time safer for families
          </p>
        </div>
        
        {/* About section */}
        <div className="bg-blue-50 border border-blue-200 rounded-md p-6">
          <h3 className="text-lg font-semibold text-blue-900 mb-4">About TV Tantrum</h3>
          <p className="text-sm text-blue-800 mb-4">
            TV Tantrum helps parents make informed decisions about children's TV shows. We understand that screen time is inevitable, so why not make it count?
          </p>
          
          <h4 className="text-md font-semibold text-blue-900 mb-3">Our Rating System</h4>
          <ul className="text-sm text-blue-800 space-y-2 mb-4">
            <li><span className="font-semibold">Stimulation Score</span> - Measure of how visually and audibly stimulating the content is</li>
            <li><span className="font-semibold">Themes</span> - Topics covered from adventure and creativity to social-emotional learning</li>
            <li><span className="font-semibold">Interactivity Level</span> - How engaging and interactive the content is for children</li>
            <li><span className="font-semibold">Target Ages</span> - We inform you on what age group the show's content targets</li>
          </ul>
          
          <p className="text-sm text-blue-700 font-medium">
            Join thousands of parents making smarter screen time choices for their families
          </p>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="server/database-storage.ts">
import { db, pool } from "./db";
import { eq, and, or, not, sql, desc, inArray, like, count } from "drizzle-orm";
import { scrypt, randomBytes } from "crypto";
import { promisify } from "util";

const scryptAsync = promisify(scrypt);

async function hashPassword(password: string) {
  const salt = randomBytes(16).toString("hex");
  const buf = (await scryptAsync(password, salt, 64)) as Buffer;
  return `${buf.toString("hex")}.${salt}`;
}
import { 
  users, favorites, tvShows, tvShowReviews, tvShowSearches, tvShowViews, 
  themes, platforms, tvShowThemes, tvShowPlatforms,
  userPointsHistory, reviewUpvotes, researchSummaries, userReadResearch, showSubmissions, userReferrals, notifications,
  type User, type InsertUser, 
  type TvShow, type InsertTvShow, 
  type TvShowReview, type InsertTvShowReview,
  type TvShowSearch, type InsertTvShowSearch,
  type TvShowView, type InsertTvShowView,
  type Favorite, type InsertFavorite,
  type Theme, type InsertTheme,
  type Platform, type InsertPlatform,
  type TvShowTheme, type InsertTvShowTheme,
  type TvShowPlatform, type InsertTvShowPlatform,
  type UserPointsHistory, type InsertUserPointsHistory,
  type ReviewUpvote, type InsertReviewUpvote,
  type ResearchSummary, type InsertResearchSummary,
  type UserReadResearch, type InsertUserReadResearch,
  type ShowSubmission, type InsertShowSubmission,
  type UserReferral, type InsertUserReferral,
  type TvShowGitHub
} from "@shared/schema";
// Import custom preservator functions with error handling
let updateCustomImageMap: Function | null = null;
let updateCustomShowDetails: Function | null = null;

try {
  const imagePreservator = require("./image-preservator");
  updateCustomImageMap = imagePreservator.updateCustomImageMap;
} catch (error) {
  console.log("Image preservator not available, continuing without it");
}

try {
  const detailsPreservator = require("./details-preservator");
  updateCustomShowDetails = detailsPreservator.updateCustomShowDetails;
} catch (error) {
  console.log("Details preservator not available, continuing without it");
}

// We'll implement a simpler solution directly in this file

export interface IStorage {
  // User methods
  getUser(id: number): Promise<User | undefined>;
  getUserByUsername(username: string): Promise<User | undefined>;
  getUserByEmail(email: string): Promise<User | undefined>;
  createUser(user: InsertUser): Promise<User>;
  getAllUsers(): Promise<User[]>;
  updateUserApproval(userId: number, isApproved: boolean): Promise<User | undefined>;
  
  // TV Shows methods
  getAllTvShows(): Promise<TvShow[]>;
  getTvShowById(id: number): Promise<TvShow | undefined>;
  getTvShowsByPlatform(platform: string, limit?: number): Promise<TvShow[]>;
  getTvShowsByFilter(filters: { 
    ageGroup?: string; 
    ageRange?: {min: number, max: number};
    tantrumFactor?: string; 
    sortBy?: string; 
    search?: string;
    themes?: string[];
    themeMatchMode?: 'AND' | 'OR';
    interactionLevel?: string;
    dialogueIntensity?: string;
    soundFrequency?: string;
    stimulationScoreRange?: {min: number, max: number};
  }): Promise<TvShow[]>;
  addTvShow(show: InsertTvShow): Promise<TvShow>;
  updateTvShow(id: number, show: Partial<InsertTvShow>): Promise<TvShow | undefined>;
  deleteTvShow(id: number): Promise<boolean>;
  
  // Reviews methods
  getReviewsByTvShowId(tvShowId: number): Promise<TvShowReview[]>;
  addReview(review: InsertTvShowReview): Promise<TvShowReview>;
  
  // Search/Popularity tracking methods
  trackShowSearch(tvShowId: number): Promise<void>;
  trackShowView(tvShowId: number): Promise<void>;
  getPopularShows(limit?: number): Promise<TvShow[]>;
  
  // Import shows from GitHub data
  importShowsFromGitHub(shows: TvShowGitHub[]): Promise<TvShow[]>;

  // Favorites methods
  addFavorite(userId: number, tvShowId: number): Promise<Favorite>;
  removeFavorite(userId: number, tvShowId: number): Promise<boolean>;
  getUserFavorites(userId: number): Promise<TvShow[]>;
  isFavorite(userId: number, tvShowId: number): Promise<boolean>;
  getSimilarShows(userId: number, limit?: number): Promise<TvShow[]>;
}

export class DatabaseStorage implements IStorage {
  /**
   * Standardizes all sensory metrics in the database to use the approved 5-level scale
   */
  async standardizeAllSensoryMetrics(): Promise<{success: boolean, unrecognizedValues: string[]}> {
    const unrecognizedValues = new Set<string>();
    const client = await pool.connect();
    
    try {
      // Start transaction
      await client.query('BEGIN');
      
      // Get all TV shows
      const result = await client.query('SELECT * FROM tv_shows');
      console.log(`Standardizing sensory metrics for ${result.rowCount} TV shows`);
      
      // Track stats
      let totalUpdates = 0;
      let showsUpdated = 0;
      
      // Process each show
      for (const show of result.rows) {
        let updated = false;
        const updates: Record<string, string> = {};
        
        // Sensory metric fields to standardize
        const fields = [
          'interaction_level',
          'dialogue_intensity',
          'sound_frequency',
          'total_music_level',
          'music_tempo',
          'sound_effects_level',
          'scene_frequency',
          'total_sound_effect_time_level',
          'interactivity_level'
        ];
        
        // Check and standardize each field
        for (const field of fields) {
          const originalValue = show[field];
          
          if (originalValue) {
            const standardizedValue = this.standardizeSensoryMetric(originalValue);
            
            // If the value changed, mark for update
            if (standardizedValue !== originalValue) {
              updates[field] = standardizedValue;
              updated = true;
              totalUpdates++;
              
              // Log non-standard values for reporting
              if (!['Low', 'Low-Moderate', 'Moderate', 'Moderate-High', 'High'].includes(originalValue)) {
                unrecognizedValues.add(`"${originalValue}" → "${standardizedValue}"`);
              }
            }
          }
        }
        
        // If any fields were standardized, update the show
        if (updated) {
          const setClause = Object.entries(updates)
            .map(([field, value]) => `${field} = $${field}`)
            .join(', ');
          
          const queryParams: any = { id: show.id };
          Object.entries(updates).forEach(([field, value]) => {
            queryParams[field] = value;
          });
          
          const updateQuery = `
            UPDATE tv_shows 
            SET ${setClause}
            WHERE id = $id
          `;
          
          await client.query(updateQuery, queryParams);
          showsUpdated++;
        }
      }
      
      // Commit changes
      await client.query('COMMIT');
      console.log(`Standardization complete: Updated ${totalUpdates} metrics across ${showsUpdated} shows`);
      
      return {
        success: true,
        unrecognizedValues: Array.from(unrecognizedValues)
      };
    } catch (error) {
      // Rollback on error
      await client.query('ROLLBACK');
      console.error('Error standardizing sensory metrics:', error);
      return {
        success: false,
        unrecognizedValues: Array.from(unrecognizedValues)
      };
    } finally {
      client.release();
    }
  }
  
  // Private helper methods
  
  /**
   * Standardize sensory metric values to use only approved ratings:
   * Low, Low-Moderate, Moderate, Moderate-High, High
   */
  private standardizeSensoryMetric(value: string | null): string | null {
    if (!value) return null;
    
    // Normalize to lowercase and trim for consistent matching
    const normalizedValue = value.toLowerCase().trim();
    
    // Already using the standard terms (case-insensitive)
    if (/^low$/i.test(normalizedValue)) return "Low";
    if (/^low-moderate$/i.test(normalizedValue)) return "Low-Moderate";
    if (/^moderate$/i.test(normalizedValue)) return "Moderate";
    if (/^moderate-high$/i.test(normalizedValue)) return "Moderate-High";
    if (/^high$/i.test(normalizedValue)) return "High";
    
    // Map various terms to standardized values
    
    // LOW mappings
    if ([
      'minimal', 'very low', 'very-low', 'verylow', 'none', 'quiet', 'soft',
      'rare', 'mild', 'limited', 'infrequent', 'sparse', 'little', 'gentle',
      'very minimal', 'very-minimal', 'very little', 'very-little', 'rarely',
      'extremely limited', 'negligible', 'slow', 'calm', 'relaxed', 'lowest',
      'slight', 'trivial', 'minor', 'subtle', 'occasional'
    ].some(term => normalizedValue.includes(term))) {
      return "Low";
    }
    
    // LOW-MODERATE mappings
    if ([
      'low moderate', 'low to moderate', 'lowmoderate', 'low/moderate',
      'light', 'light-moderate', 'light moderate', 'somewhat limited',
      'below average', 'relatively low', 'moderately low', 'light-medium',
      'somewhat low', 'few', 'gentle-moderate', 'low medium', 'moderate-low',
      'low to medium', 'occasionally', 'mild to moderate', 'fairly low'
    ].some(term => normalizedValue.includes(term))) {
      return "Low-Moderate";
    }
    
    // MODERATE mappings
    if ([
      'medium', 'average', 'normal', 'standard', 'balanced', 'regular',
      'middle', 'neutral', 'intermediate', 'sometimes', 'periodically',
      'moderately', 'mid-level', 'mid level', 'midlevel', 'medium level',
      'moderate level', 'reasonable', 'center', 'occasional-frequent',
      'fair', 'halfway', 'moderate amount', 'common', 'mid', 'standard'
    ].some(term => normalizedValue.includes(term))) {
      return "Moderate";
    }
    
    // MODERATE-HIGH mappings
    if ([
      'moderate high', 'moderate to high', 'moderatehigh', 'moderate/high',
      'elevated', 'significant', 'substantial', 'fairly high', 'considerable', 
      'above average', 'pronounced', 'notable', 'noticeable', 'robust',
      'strong', 'frequent', 'often', 'relatively high', 'higher than average',
      'heightened', 'medium-high', 'medium high', 'medium to high', 'quite high',
      'somewhat high', 'moderate-to-high'
    ].some(term => normalizedValue.includes(term))) {
      return "Moderate-High";
    }
    
    // HIGH mappings
    if ([
      'very high', 'very-high', 'veryhigh', 'intense', 'continuous', 'heavy', 
      'extreme', 'maximum', 'highest', 'extensive', 'strong', 'significant',
      'very intense', 'very-intense', 'veryintense', 'constant', 'always',
      'excessive', 'considerable', 'substantial', 'loud', 'abundant',
      'numerous', 'fast', 'rapid', 'consistent', 'dominant'
    ].some(term => normalizedValue.includes(term))) {
      return "High";
    }
    
    // Default to Moderate for any unrecognized values
    // Using specific log format to make these easy to find
    console.warn(`[METRIC_STANDARDIZATION] Unrecognized sensory metric value: "${value}", defaulting to "Moderate"`);
    return "Moderate";
  }
  
  // Private helper methods for junction tables
  
  /**
   * Get theme records for a TV show via junction table
   */
  private async getThemesForShow(tvShowId: number): Promise<Theme[]> {
    try {
      const result = await db
        .select({
          theme: themes
        })
        .from(tvShowThemes)
        .innerJoin(themes, eq(tvShowThemes.themeId, themes.id))
        .where(eq(tvShowThemes.tvShowId, tvShowId));
      
      return result.map(r => r.theme);
    } catch (error) {
      console.error("Error retrieving themes for show", error);
      // Fall back to original array column if junction table query fails
      const result = await db
        .select({ themes: tvShows.themes })
        .from(tvShows)
        .where(eq(tvShows.id, tvShowId));
      
      if (result.length === 0 || !result[0].themes) {
        return [];
      }
      
      // Convert string array to Theme objects
      return result[0].themes.map(name => ({ id: 0, name }));
    }
  }
  
  /**
   * Get platform records for a TV show via junction table
   */
  private async getPlatformsForShow(tvShowId: number): Promise<Platform[]> {
    try {
      const result = await db
        .select({
          platform: platforms
        })
        .from(tvShowPlatforms)
        .innerJoin(platforms, eq(tvShowPlatforms.platformId, platforms.id))
        .where(eq(tvShowPlatforms.tvShowId, tvShowId));
      
      return result.map(r => r.platform);
    } catch (error) {
      console.error("Error retrieving platforms for show", error);
      // Fall back to original array column if junction table query fails
      const result = await db
        .select({ platforms: tvShows.availableOn })
        .from(tvShows)
        .where(eq(tvShows.id, tvShowId));
      
      if (result.length === 0 || !result[0].platforms) {
        return [];
      }
      
      // Convert string array to Platform objects
      return result[0].platforms.map(name => ({ id: 0, name }));
    }
  }
  
  /**
   * Update themes for a TV show using the junction table
   */
  private async updateThemesForShow(tvShowId: number, themeNames: string[]): Promise<void> {
    try {
      // Use direct SQL for more reliable theme updates
      const client = await pool.connect();
      try {
        await client.query('BEGIN');
        
        // Remove existing theme associations
        await client.query('DELETE FROM tv_show_themes WHERE tv_show_id = $1', [tvShowId]);
        
        // Process each theme name
        for (const themeName of themeNames) {
          // Skip empty theme names
          if (!themeName.trim()) continue;
          
          // Find or create the theme
          let themeId: number;
          const existingTheme = await client.query('SELECT id FROM themes WHERE name = $1', [themeName]);
          
          if (existingTheme.rows.length > 0) {
            themeId = existingTheme.rows[0].id;
          } else {
            // Create new theme
            const newTheme = await client.query('INSERT INTO themes (name) VALUES ($1) RETURNING id', [themeName]);
            themeId = newTheme.rows[0].id;
          }
          
          // Create association in the junction table
          await client.query(
            'INSERT INTO tv_show_themes (tv_show_id, theme_id) VALUES ($1, $2) ON CONFLICT DO NOTHING',
            [tvShowId, themeId]
          );
        }
        
        // Also update the array column for backward compatibility
        await client.query('UPDATE tv_shows SET themes = $1 WHERE id = $2', [themeNames, tvShowId]);
        
        await client.query('COMMIT');
      } catch (error) {
        await client.query('ROLLBACK');
        throw error;
      } finally {
        client.release();
      }
    } catch (error) {
      console.error("Error updating themes for show", error);
      // Fallback to just updating the array column
      try {
        const client = await pool.connect();
        try {
          await client.query('UPDATE tv_shows SET themes = $1 WHERE id = $2', [themeNames, tvShowId]);
        } finally {
          client.release();
        }
      } catch (fallbackError) {
        console.error("Fallback theme update also failed:", fallbackError);
      }
    }
  }
  
  /**
   * Update platforms for a TV show using the junction table
   */
  private async updatePlatformsForShow(tvShowId: number, platformNames: string[]): Promise<void> {
    try {
      // Start a transaction
      await db.transaction(async (tx) => {
        // Remove existing platform associations
        await tx
          .delete(tvShowPlatforms)
          .where(eq(tvShowPlatforms.tvShowId, tvShowId));
        
        // Process each platform name
        for (const platformName of platformNames) {
          // Skip empty platform names
          if (!platformName.trim()) continue;
          
          // Find or create the platform
          let platformId: number;
          const existingPlatform = await tx
            .select()
            .from(platforms)
            .where(eq(platforms.name, platformName));
            
          if (existingPlatform.length > 0) {
            platformId = existingPlatform[0].id;
          } else {
            // Create new platform
            const newPlatform = await tx
              .insert(platforms)
              .values({ name: platformName })
              .returning();
            platformId = newPlatform[0].id;
          }
          
          // Create association in the junction table
          await tx
            .insert(tvShowPlatforms)
            .values({ tvShowId, platformId })
            .onConflictDoNothing();
        }
        
        // Also update the array column for backward compatibility
        await tx
          .update(tvShows)
          .set({ availableOn: platformNames })
          .where(eq(tvShows.id, tvShowId));
      });
    } catch (error) {
      console.error("Error updating platforms for show", error);
      // Fallback to just updating the array column
      await db
        .update(tvShows)
        .set({ availableOn: platformNames })
        .where(eq(tvShows.id, tvShowId));
    }
  }
  async getUser(id: number): Promise<User | undefined> {
    try {
      const result = await pool.query('SELECT * FROM users WHERE id = $1', [id]);
      
      if (result.rows.length === 0) {
        return undefined;
      }
      
      return {
        id: result.rows[0].id,
        email: result.rows[0].email,
        password: result.rows[0].password,
        username: result.rows[0].username,
        isAdmin: result.rows[0].is_admin,
        country: result.rows[0].country,
        createdAt: result.rows[0].created_at,
        isApproved: result.rows[0].is_approved
      };
    } catch (error) {
      console.error(`Error getting user by ID ${id}:`, error);
      return undefined;
    }
  }

  async getUserByEmail(email: string): Promise<User | undefined> {
    console.log(`Searching for user with email: ${email}`);
    
    // First, try a simple query to verify the database is accessible
    try {
      const checkResult = await pool.query('SELECT COUNT(*) FROM users');
      console.log(`Total users in database: ${checkResult.rows[0].count}`);
    } catch (error) {
      console.error('Error checking user count:', error);
    }
    
    try {
      // Try direct query without transaction to see if that's the issue
      const directResult = await pool.query('SELECT * FROM users WHERE email = $1 LIMIT 1', [email]);
      console.log(`Direct query result:`, {
        rowCount: directResult.rowCount,
        found: directResult.rows.length > 0,
        id: directResult.rows[0]?.id
      });
      
      if (directResult.rows.length > 0) {
        // Use direct query result without transaction
        return {
          id: directResult.rows[0].id,
          email: directResult.rows[0].email,
          password: directResult.rows[0].password,
          username: directResult.rows[0].username,
          isAdmin: directResult.rows[0].is_admin,
          country: directResult.rows[0].country,
          createdAt: directResult.rows[0].created_at,
          isApproved: directResult.rows[0].is_approved
        };
      } else {
        console.log(`User with email ${email} not found in direct query`);
      }
    } catch (directError) {
      console.error(`Error in direct query for email ${email}:`, directError);
    }
    
    return undefined;
  }
  
  async getUserByUsername(username: string): Promise<User | undefined> {
    console.log(`Searching for user with username: ${username}`);
    
    try {
      // Try direct query without transaction
      const directResult = await pool.query('SELECT * FROM users WHERE username = $1 LIMIT 1', [username]);
      console.log(`Direct query result for username:`, {
        rowCount: directResult.rowCount,
        found: directResult.rows.length > 0,
        id: directResult.rows[0]?.id
      });
      
      if (directResult.rows.length > 0) {
        // Use direct query result without transaction
        return {
          id: directResult.rows[0].id,
          email: directResult.rows[0].email,
          password: directResult.rows[0].password,
          username: directResult.rows[0].username,
          isAdmin: directResult.rows[0].is_admin,
          country: directResult.rows[0].country,
          createdAt: directResult.rows[0].created_at,
          isApproved: directResult.rows[0].is_approved
        };
      } else {
        console.log(`User with username ${username} not found in direct query`);
      }
    } catch (directError) {
      console.error(`Error in direct query for username ${username}:`, directError);
    }
    
    return undefined;
  }

  async createUser(insertUser: InsertUser): Promise<User> {
    const client = await pool.connect();
    
    try {
      // Start transaction
      await client.query('BEGIN');
      
      const now = new Date().toISOString();
      
      // Use the password as-is if it's already hashed (starts with $2b$), otherwise hash it
      const hashedPassword = insertUser.password && insertUser.password.startsWith('$2b$') 
        ? insertUser.password 
        : insertUser.password ? await hashPassword(insertUser.password) : null;
      
      // Ensure username is never null to match schema requirements
      const userToInsert = {
        ...insertUser,
        username: insertUser.username || '', // Convert null to empty string if needed
        password: hashedPassword,
        createdAt: now,
      };
      
      console.log('Creating user with data:', {...userToInsert, password: '[REDACTED]'});
      
      // Use client instead of pool for transaction
      const result = await client.query(`
        INSERT INTO users (email, password, username, is_admin, country, created_at, is_approved, first_name) 
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8) 
        RETURNING *
      `, [
        userToInsert.email,
        userToInsert.password,
        userToInsert.username,
        userToInsert.isAdmin || false,
        userToInsert.country || '',
        userToInsert.createdAt,
        userToInsert.isApproved || false,
        userToInsert.firstName || null
      ]);
      
      // Explicitly commit the transaction
      await client.query('COMMIT');
      
      // Convert from raw SQL result to our expected User type
      const user: User = {
        id: result.rows[0].id,
        email: result.rows[0].email,
        password: result.rows[0].password,
        username: result.rows[0].username,
        isAdmin: result.rows[0].is_admin,
        country: result.rows[0].country,
        createdAt: result.rows[0].created_at,
        isApproved: result.rows[0].is_approved
      };
      
      console.log('User created successfully with ID:', user.id);
      return user;
    } catch (error) {
      // Rollback transaction on error
      await client.query('ROLLBACK');
      console.error('Error creating user in database:', error);
      throw error; // Re-throw to be caught by the API layer
    } finally {
      // Always release the client back to the pool
      client.release();
    }
  }
  
  async getAllUsers(): Promise<User[]> {
    const client = await pool.connect();
    
    try {
      // Use a transaction to ensure data consistency
      await client.query('BEGIN');
      
      // Execute the query with the client
      const result = await client.query('SELECT * FROM users ORDER BY id DESC');
      
      // Commit the transaction
      await client.query('COMMIT');
      
      // Map the SQL results to our User type
      const userList: User[] = result.rows.map(row => ({
        id: row.id,
        email: row.email,
        password: row.password,
        username: row.username,
        isAdmin: row.is_admin,
        country: row.country,
        createdAt: row.created_at,
        isApproved: row.is_approved
      }));
      
      console.log(`Fetched ${userList.length} users from database`);
      return userList;
    } catch (error) {
      // Rollback the transaction on error
      await client.query('ROLLBACK');
      console.error('Error fetching users:', error);
      return [];
    } finally {
      // Release the client back to the pool
      client.release();
    }
  }
  
  async updateUserApproval(userId: number, isApproved: boolean): Promise<User | undefined> {
    const client = await pool.connect();
    
    try {
      // Start transaction
      await client.query('BEGIN');
      
      // Execute update with transaction
      const result = await client.query(`
        UPDATE users 
        SET is_approved = $1 
        WHERE id = $2 
        RETURNING *
      `, [isApproved, userId]);
      
      if (result.rows.length === 0) {
        await client.query('ROLLBACK');
        console.log(`No user found with ID ${userId} to update approval status`);
        return undefined;
      }
      
      // Commit the transaction
      await client.query('COMMIT');
      
      // Map the SQL result to our User type
      const updatedUser: User = {
        id: result.rows[0].id,
        email: result.rows[0].email,
        password: result.rows[0].password,
        username: result.rows[0].username,
        isAdmin: result.rows[0].is_admin,
        country: result.rows[0].country,
        createdAt: result.rows[0].created_at,
        isApproved: result.rows[0].is_approved
      };
      
      console.log(`Updated approval status for user ${updatedUser.id} to ${isApproved}`);
      return updatedUser;
    } catch (error) {
      // Rollback on error
      await client.query('ROLLBACK');
      console.error(`Error updating approval status for user ${userId}:`, error);
      return undefined;
    } finally {
      // Always release the client
      client.release();
    }
  }

  async getTvShowsByPlatform(platform: string, limit: number = 100): Promise<TvShow[]> {
    try {
      const client = await pool.connect();
      try {
        // Use parameterized query to search for shows by platform
        const result = await client.query(
          'SELECT * FROM tv_shows WHERE available_on::text LIKE $1 ORDER BY name LIMIT $2',
          [`%${platform}%`, limit]
        );
        
        console.log(`Retrieved ${result.rowCount} TV shows for platform "${platform}"`);
        
        // Map the database rows to our TvShow model, same mapping as getAllTvShows
        return result.rows.map(row => ({
          id: row.id,
          name: row.name || '',
          description: row.description || '',
          imageUrl: row.image_url,
          ageRange: row.age_range || '',
          tantrumFactor: row.tantrum_factor || '',
          themes: row.themes || [],
          
          // Stimulation metrics
          stimulationScore: row.stimulation_score || 0,
          interactivityLevel: row.interactivity_level || null,
          dialogueIntensity: row.dialogue_intensity || null,
          soundEffectsLevel: row.sound_effects_level || null,
          totalMusicLevel: row.total_music_level || null,
          musicTempo: row.music_tempo || null,
          totalSoundEffectTimeLevel: row.total_sound_effect_time_level || null,
          sceneFrequency: row.scene_frequency || null,
          animationStyle: row.animation_style || null,
          
          // Required schema fields with defaults
          episodeLength: row.episode_length || 0,
          creator: row.creator || null,
          releaseYear: row.release_year || null,
          endYear: row.end_year || null,
          isOngoing: row.is_ongoing || null,
          seasons: row.seasons || null,
          availableOn: row.available_on || [],
          creativityRating: row.creativity_rating || null,
          
          // YouTube-specific fields
          subscriberCount: row.subscriber_count || null,
          videoCount: row.video_count || null,
          channelId: row.channel_id || null,
          isYouTubeChannel: row.is_youtube_channel || false,
          publishedAt: row.published_at || null,
          
          // API data flags
          hasOmdbData: row.has_omdb_data || false,
          hasYoutubeData: row.has_youtube_data || false
        }));
      } finally {
        client.release();
      }
    } catch (error) {
      console.error(`Error fetching TV shows for platform "${platform}":`, error);
      return [];
    }
  }
  
  async getAllTvShows(): Promise<TvShow[]> {
    try {
      // Direct SQL query approach for reliability
      const client = await pool.connect();
      try {
        // Get basic show data
        const result = await client.query('SELECT * FROM tv_shows ORDER BY name');
        console.log(`Retrieved ${result.rowCount} TV shows from database`);
        
        // Create initial show objects
        const tvShows = result.rows.map(row => ({
          id: row.id,
          name: row.name || '',
          description: row.description || '',
          imageUrl: row.image_url,
          ageRange: row.age_range || '',
          episodeLength: row.episode_length || 0,
          themes: [], // Will be populated from junction table
          availableOn: [], // Will be populated from junction table
          
          // Stimulation metrics
          stimulationScore: row.stimulation_score || 0,
          interactionLevel: this.standardizeSensoryMetric(row.interaction_level),
          dialogueIntensity: this.standardizeSensoryMetric(row.dialogue_intensity),
          soundFrequency: this.standardizeSensoryMetric(row.sound_frequency),
          totalMusicLevel: this.standardizeSensoryMetric(row.total_music_level),
          musicTempo: this.standardizeSensoryMetric(row.music_tempo),
          soundEffectsLevel: this.standardizeSensoryMetric(row.sound_effects_level),
          animationStyle: row.animation_style || null,
          sceneFrequency: this.standardizeSensoryMetric(row.scene_frequency),
          totalSoundEffectTimeLevel: this.standardizeSensoryMetric(row.total_sound_effect_time_level),
          
          // Other fields
          network: row.network || null,
          year: row.year || '',
          productionCompany: row.production_company || '',
          
          // Required schema fields with defaults
          creator: row.creator || null,
          releaseYear: row.release_year || null,
          endYear: row.end_year || null,
          isOngoing: row.is_ongoing || null,
          seasons: row.seasons || null,
          totalEpisodes: row.total_episodes || null,
          productionCountry: row.production_country || null,
          language: row.language || null,
          genre: row.genre || null,
          targetAudience: row.target_audience || null,
          viewerRating: row.viewer_rating || null,
          
          // Timestamps
          createdAt: row.created_at || new Date().toISOString(),
          updatedAt: row.updated_at || new Date().toISOString(),
          
          // API data flags
          hasOmdbData: row.has_omdb_data || false,
          hasYoutubeData: row.has_youtube_data || false
        }));
        
        // Fall back to legacy approach if junction tables have issues
        try {
          // First check if junction tables exist
          const checkThemesTable = await client.query(`
            SELECT EXISTS (
              SELECT FROM information_schema.tables 
              WHERE table_name = 'tv_show_themes'
            );
          `);
          
          const junctionTablesExist = checkThemesTable.rows[0].exists;
          
          if (junctionTablesExist) {
            // Get themes from junction table
            const themesResult = await client.query(`
              SELECT tv_show_id, t.name 
              FROM tv_show_themes tst
              JOIN themes t ON tst.theme_id = t.id
            `);
            
            // Group themes by TV show ID
            const themesByShowId = new Map();
            for (const row of themesResult.rows) {
              const showId = row.tv_show_id;
              if (!themesByShowId.has(showId)) {
                themesByShowId.set(showId, []);
              }
              themesByShowId.get(showId).push(row.name);
            }
            
            // Get platforms from junction table
            const platformsResult = await client.query(`
              SELECT tv_show_id, p.name 
              FROM tv_show_platforms tsp
              JOIN platforms p ON tsp.platform_id = p.id
            `);
            
            // Group platforms by TV show ID
            const platformsByShowId = new Map();
            for (const row of platformsResult.rows) {
              const showId = row.tv_show_id;
              if (!platformsByShowId.has(showId)) {
                platformsByShowId.set(showId, []);
              }
              platformsByShowId.get(showId).push(row.name);
            }
            
            // Update each show with its themes and platforms
            for (const show of tvShows) {
              if (themesByShowId.has(show.id)) {
                show.themes = themesByShowId.get(show.id);
              }
              if (platformsByShowId.has(show.id)) {
                show.availableOn = platformsByShowId.get(show.id);
              }
            }
          } else {
            console.log("Junction tables not yet available, using legacy data format");
          }
        } catch (junctionError) {
          console.error("Error enhancing with junction table data:", junctionError);
          // Continue with original data if junction tables fail
        }
        
        return tvShows;
      } finally {
        client.release();
      }
    } catch (error) {
      console.error('Error fetching TV shows from database:', error);
      
      // Fall back to ORM if direct query fails
      try {
        console.log('Attempting to fetch TV shows using ORM...');
        const shows = await db.select().from(tvShows);
        console.log(`Retrieved ${shows.length} TV shows using ORM`);
        return shows;
      } catch (ormError) {
        console.error('ORM fallback also failed:', ormError);
        return [];
      }
    }
  }

  async getAllThemes(): Promise<{ id: number; name: string }[]> {
    try {
      const result = await pool.query('SELECT id, name FROM themes ORDER BY name');
      return result.rows;
    } catch (error) {
      console.error('Error fetching all themes:', error);
      throw error;
    }
  }

  async getTvShowById(id: number): Promise<TvShow | undefined> {
    try {
      // Use direct SQL query for reliability, similar to getAllTvShows
      const client = await pool.connect();
      try {
        const result = await client.query('SELECT * FROM tv_shows WHERE id = $1', [id]);
        
        if (result.rows.length === 0) {
          return undefined;
        }
        
        const row = result.rows[0];
        const tvShow = {
          id: row.id,
          name: row.name || '',
          description: row.description || '',
          imageUrl: row.image_url,
          ageRange: row.age_range || '',
          themes: row.themes || [],
          
          // Stimulation metrics
          stimulationScore: row.stimulation_score || 0,
          interactivityLevel: row.interactivity_level || null,
          dialogueIntensity: row.dialogue_intensity || null,
          soundFrequency: row.sound_frequency || null,
          totalMusicLevel: row.total_music_level || null,
          musicTempo: row.music_tempo || null,
          soundEffectsLevel: row.sound_effects_level || null,
          animationStyle: row.animation_style || null,
          sceneFrequency: row.scene_frequency || null,
          totalSoundEffectTimeLevel: row.total_sound_effect_time_level || null,
          
          // Other fields
          network: row.network || null,
          year: row.year || '',
          productionCompany: row.production_company || '',
          
          // Required schema fields with defaults
          episodeLength: row.episode_length || 0,
          creator: row.creator || null,
          releaseYear: row.release_year || null,
          endYear: row.end_year || null,
          isOngoing: row.is_ongoing || null,
          seasons: row.seasons || null,
          totalEpisodes: row.total_episodes || null,
          productionCountry: row.production_country || null,
          language: row.language || null,
          genre: row.genre || null,
          targetAudience: row.target_audience || null,
          viewerRating: row.viewer_rating || null,
          
          // YouTube-specific fields
          isYouTubeChannel: row.is_youtube_channel || false,
          subscriberCount: row.subscriber_count || null,
          videoCount: row.video_count || null,
          channelId: row.channel_id || null,
          publishedAt: row.published_at || null,
          availableOn: row.available_on || [],
          
          // Timestamps
          createdAt: row.created_at || new Date().toISOString(),
          updatedAt: row.updated_at || new Date().toISOString(),
          
          // API data flags
          hasOmdbData: row.has_omdb_data || false,
          hasYoutubeData: row.has_youtube_data || false
        };
        
        // Enhance with junction table data
        try {
          // Get themes from junction table
          const themesResult = await client.query(`
            SELECT t.name FROM themes t
            JOIN tv_show_themes tst ON t.id = tst.theme_id
            WHERE tst.tv_show_id = $1
          `, [id]);
          
          if (themesResult.rows.length > 0) {
            // Use themes from junction table if available
            tvShow.themes = themesResult.rows.map(row => row.name);
          }
          
          // Get platforms from junction table
          const platformsResult = await client.query(`
            SELECT p.name FROM platforms p
            JOIN tv_show_platforms tsp ON p.id = tsp.platform_id
            WHERE tsp.tv_show_id = $1
          `, [id]);
          
          if (platformsResult.rows.length > 0) {
            // Use platforms from junction table if available
            tvShow.availableOn = platformsResult.rows.map(row => row.name);
          }
        } catch (junctionError) {
          console.error("Error enhancing with junction tables:", junctionError);
          // Continue with original data if junction tables fail
        }
        
        return tvShow;
      } finally {
        client.release();
      }
    } catch (error) {
      console.error(`Error fetching TV show with ID ${id}:`, error);
      
      // Fall back to ORM if direct query fails
      try {
        const [show] = await db.select().from(tvShows).where(eq(tvShows.id, id));
        return show;
      } catch (ormError) {
        console.error(`ORM fallback for TV show ID ${id} also failed:`, ormError);
        return undefined;
      }
    }
  }

  async getTvShowsByFilter(filters: { 
    ageGroup?: string; 
    ageRange?: {min: number, max: number};
    tantrumFactor?: string; 
    sortBy?: string; 
    search?: string;
    themes?: string[];
    themeMatchMode?: 'AND' | 'OR';
    interactionLevel?: string;
    dialogueIntensity?: string;
    soundFrequency?: string;
    stimulationScoreRange?: {min: number, max: number};
  }): Promise<TvShow[]> {
    // Build query based on filters
    let query = db.select().from(tvShows);
    
    // Apply filters
    const conditions = [];
    
    // Handle age range filtering
    if ('ageRange' in filters && filters.ageRange && 'min' in filters.ageRange && 'max' in filters.ageRange) {
      const min = filters.ageRange.min;
      const max = filters.ageRange.max;
      
      // Log the age range filter for debugging
      console.log(`Filtering by age range: min=${min}, max=${max}`);

      // Extract the min and max from the show's ageRange string
      // Patterns we handle: "0-2", "3-5", "6-8", "9-12", "13+", "Any Age"
      conditions.push(
        or(
          // Special case for "Any Age" - always include these
          eq(tvShows.ageRange, "Any Age"),
          
          // Special case for other non-standard formats
          and(
            not(like(tvShows.ageRange, "%-%")), // Not a standard range with hyphen
            not(like(tvShows.ageRange, "%+%")), // Not a range ending with +
            not(eq(tvShows.ageRange, "Any Age")), // Not "Any Age"
            // Include these non-standard formats only for ages 3+ to avoid excessive filtering
            sql`${min} >= 3`
          ),
          
          // Handle standard age ranges like "3-5" - we only process if it has a hyphen
          and(
            like(tvShows.ageRange, "%-%"), // Contains a hyphen for ranges
            not(like(tvShows.ageRange, "%years%")), // Exclude ranges with "years" text
            not(like(tvShows.ageRange, "%+%")), // Not a range ending with +
            // Safe conversion with regex check
            sql`
              REGEXP_REPLACE(SPLIT_PART(${tvShows.ageRange}, '-', 1), '[^0-9]', '', 'g')::INTEGER >= ${min} AND
              REGEXP_REPLACE(SPLIT_PART(${tvShows.ageRange}, '-', 2), '[^0-9]', '', 'g')::INTEGER <= ${max}
            `
          ),
          
          // Handle ranges with + like "13+"
          and(
            like(tvShows.ageRange, "%+%"),
            // Safe conversion with regex to extract just the number
            sql`REGEXP_REPLACE(${tvShows.ageRange}, '[^0-9]', '', 'g')::INTEGER BETWEEN ${min} AND ${max}`
          ),
          
          // Include shows where the age range contains our filter range
          // For example, "2-8 years" would match filter range 3-6
          and(
            like(tvShows.ageRange, "%-%"), // Contains a hyphen for ranges
            sql`
              REGEXP_REPLACE(SPLIT_PART(${tvShows.ageRange}, '-', 1), '[^0-9]', '', 'g')::INTEGER <= ${min} AND
              REGEXP_REPLACE(SPLIT_PART(${tvShows.ageRange}, '-', 2), '[^0-9]', '', 'g')::INTEGER >= ${max}
            `
          )
        )
      );
    } 
    // Legacy support for exact age group matching
    else if (filters.ageGroup) {
      conditions.push(eq(tvShows.ageRange, filters.ageGroup));
    }
    
    if (filters.tantrumFactor) {
      // Convert descriptive term to numerical value
      let stimulationScore;
      switch (filters.tantrumFactor.toLowerCase()) {
        case 'low': stimulationScore = 1; break;
        case 'low-medium': stimulationScore = 2; break;
        case 'medium': stimulationScore = 3; break;
        case 'medium-high': stimulationScore = 4; break;
        case 'high': stimulationScore = 5; break;
      }
      
      if (stimulationScore) {
        conditions.push(eq(tvShows.stimulationScore, stimulationScore));
      }
    }
    
    if (filters.interactionLevel && filters.interactionLevel !== 'Any') {
      // Map frontend 'interactionLevel' to database 'interactivityLevel' field
      console.log("Filtering by interaction level:", filters.interactionLevel);
      
      // Handle different values for High interactivity
      if (filters.interactionLevel === 'High') {
        conditions.push(
          or(
            eq(tvShows.interactivityLevel, 'High'),
            like(tvShows.interactivityLevel, '%High%'), // Catches "Moderate-High" or "Very High"
            like(tvShows.interactivityLevel, '%to High%') // Catches "Moderate to High"
          )
        );
      } else {
        conditions.push(eq(tvShows.interactivityLevel, filters.interactionLevel));
      }
    }
    
    if (filters.dialogueIntensity) {
      // Log for debugging purposes
      console.log("Filtering by dialogue intensity:", filters.dialogueIntensity);
      conditions.push(eq(tvShows.dialogueIntensity, filters.dialogueIntensity));
    }
    
    if (filters.soundFrequency) {
      // Map frontend 'soundFrequency' to database 'soundEffectsLevel' field
      console.log("Filtering by sound frequency level:", filters.soundFrequency);
      conditions.push(eq(tvShows.soundEffectsLevel, filters.soundFrequency));
    }
    
    if (filters.stimulationScoreRange) {
      const { min, max } = filters.stimulationScoreRange;
      conditions.push(sql`${tvShows.stimulationScore} >= ${min} AND ${tvShows.stimulationScore} <= ${max}`);
    }
    
    if (filters.search) {
      // Simple text search across name and description
      const searchTerm = `%${filters.search}%`;
      conditions.push(sql`(${tvShows.name} ILIKE ${searchTerm} OR ${tvShows.description} ILIKE ${searchTerm})`);
    }
    
    // Filter by themes
    if (filters.themes && filters.themes.length > 0) {
      const themeMatchMode = filters.themeMatchMode || 'AND';
      console.log(`Filtering by themes: ${filters.themes.join(', ')}, match mode: ${themeMatchMode}`);
      
      // Don't add SQL conditions - we'll do post-query filtering entirely in JavaScript
      // This allows for more precise control over theme matching logic
      
      // Add a marker that we have theme filters but are handling them post-query
      console.log("Theme filtering will be handled in post-processing");
    }
    
    // Apply all conditions
    if (conditions.length > 0) {
      query = query.where(and(...conditions));
    }
    
    // Apply sort order
    if (filters.sortBy) {
      switch (filters.sortBy.toLowerCase()) {
        case 'name_asc':
          query = query.orderBy(tvShows.name);
          break;
        case 'name_desc':
          query = query.orderBy(desc(tvShows.name));
          break;
        case 'stimulation_asc':
          query = query.orderBy(tvShows.stimulationScore);
          break;
        case 'stimulation_desc':
          query = query.orderBy(desc(tvShows.stimulationScore));
          break;
        case 'stimulation-score':
          query = query.orderBy(tvShows.stimulationScore);
          break;
        case 'year_asc':
          query = query.orderBy(tvShows.releaseYear);
          break;
        case 'year_desc':
          query = query.orderBy(desc(tvShows.releaseYear));
          break;
        case 'rating_desc':
        case 'rating':
        case 'overall-rating':
          // For rating-based sorting, we need to use direct SQL
          // Fall through to regular query and handle rating sort post-query
          query = query.orderBy(tvShows.name); // Default order, will be overridden
          break;
        default:
          // Default to name ascending
          query = query.orderBy(tvShows.name);
      }
    } else {
      // Default sort order
      query = query.orderBy(tvShows.name);
    }
    
    // Execute query
    let shows = await query;
    
    // Handle rating-based sorting (post-query with review data)
    if (filters.sortBy === 'rating' || filters.sortBy === 'rating_desc' || filters.sortBy === 'overall-rating') {
      console.log(`Starting rating-based sorting for sortBy: ${filters.sortBy}`);
      try {
        // Get review statistics for all shows
        const client = await pool.connect();
        try {
          const reviewStats = await client.query(`
            SELECT 
              tv_show_id,
              AVG(rating) as avg_rating,
              COUNT(rating) as review_count
            FROM tv_show_reviews 
            GROUP BY tv_show_id
          `);
          
          console.log(`Found ${reviewStats.rows.length} shows with reviews`);
          
          // Create a map of show ratings
          const ratingMap = new Map();
          reviewStats.rows.forEach(row => {
            const avgRating = parseFloat(row.avg_rating) || 0;
            const reviewCount = parseInt(row.review_count) || 0;
            ratingMap.set(row.tv_show_id, {
              avgRating,
              reviewCount
            });
            console.log(`Show ID ${row.tv_show_id}: ${avgRating} stars (${reviewCount} reviews)`);
          });
          
          // Sort shows by rating (highest first)
          shows.sort((a, b) => {
            const aStats = ratingMap.get(a.id) || { avgRating: 0, reviewCount: 0 };
            const bStats = ratingMap.get(b.id) || { avgRating: 0, reviewCount: 0 };
            
            // Sort by average rating first, then by review count as tiebreaker
            if (bStats.avgRating !== aStats.avgRating) {
              return bStats.avgRating - aStats.avgRating;
            }
            return bStats.reviewCount - aStats.reviewCount;
          });
          
          console.log(`Applied rating-based sorting to ${shows.length} shows`);
          // Log the first few shows after sorting
          const topShows = shows.slice(0, 5).map(show => {
            const stats = ratingMap.get(show.id) || { avgRating: 0, reviewCount: 0 };
            return `${show.name} (${stats.avgRating} stars, ${stats.reviewCount} reviews)`;
          });
          console.log(`Top 5 shows after rating sort: ${topShows.join(', ')}`);
        } finally {
          client.release();
        }
      } catch (error) {
        console.error('Error applying rating-based sorting:', error);
        // Continue with default sorting if rating sort fails
      }
    }
    
    // Handle theme filtering (post-query for better control)
    if (filters.themes && filters.themes.length > 0) {
      const themeMatchMode = ('themeMatchMode' in filters) ? (filters.themeMatchMode || 'AND') : 'AND';
      console.log(`Post-query filtering for themes: ${filters.themes.join(', ')} using ${themeMatchMode} mode`);
      
      // Clean up search themes
      const searchThemes = filters.themes.map(theme => theme.trim());
      console.log(`Looking for themes: ${JSON.stringify(searchThemes)}`);

      // Debug how many shows we're starting with
      console.log(`Starting with ${shows.length} shows before theme filtering`);
      
      // Function to check if a show matches a specific theme
      const showMatchesTheme = (show: any, searchTheme: string): boolean => {
        if (!show.themes || !Array.isArray(show.themes) || show.themes.length === 0) {
          return false;
        }
        
        // Normalize the search theme for consistent matching
        const normalizedSearchTheme = searchTheme.toLowerCase().trim();
        
        // 1. Check for exact theme match (case insensitive)
        const hasExactTheme = show.themes.some(showTheme => 
          showTheme && showTheme.toLowerCase().trim() === normalizedSearchTheme
        );
        
        // For OR mode or exact matches, prioritize exact matches only
        if (hasExactTheme) {
          console.log(`Found exact theme match for "${searchTheme}" in show: ${show.name}`);
          return true;
        }
        
        // 2. For compound themes like "Arabic Language Learning"
        // Only if we have more than one word in the search theme
        if (normalizedSearchTheme.includes(' ')) {
          const searchWords = normalizedSearchTheme.split(' ');
          
          // Check if any show theme contains all the words in the search theme
          const hasCompoundMatch = show.themes.some(showTheme => {
            if (!showTheme) return false;
            
            const showThemeLower = showTheme.toLowerCase().trim();
            
            // If the show theme is the exact same length as the search theme
            // and contains all the words, it's likely a match with different word order
            if (Math.abs(showThemeLower.length - normalizedSearchTheme.length) < 5) {
              return searchWords.every(word => showThemeLower.includes(word));
            }
            
            return false;
          });
          
          if (hasCompoundMatch) {
            console.log(`Found compound theme match for "${searchTheme}" in show: ${show.name}`);
            return true;
          }
        }
        
        // No more partial/fuzzy matching to avoid unexpected results
        return false;
      };
      
      // Apply filtering based on theme match mode
      if (themeMatchMode === 'AND') {
        // AND mode - show must match ALL selected themes
        console.log('Using AND mode: Shows must match ALL selected themes');
        shows = shows.filter(show => 
          searchThemes.every(theme => showMatchesTheme(show, theme))
        );
      } else {
        // OR mode - show must match ANY selected theme
        console.log('Using OR mode: Shows must match ANY selected theme');
        shows = shows.filter(show => 
          searchThemes.some(theme => showMatchesTheme(show, theme))
        );
      }
      
      console.log(`Found ${shows.length} shows after theme filtering (${themeMatchMode} mode)`);
    }
    
    return shows;
  }

  async addTvShow(show: InsertTvShow): Promise<TvShow> {
    const [newShow] = await db.insert(tvShows).values(show).returning();
    return newShow;
  }

  async updateTvShow(id: number, show: Partial<InsertTvShow>): Promise<TvShow | undefined> {
    // If we're updating the image URL, save it to our custom map
    if (show.imageUrl && updateCustomImageMap) {
      try {
        updateCustomImageMap(id, show.imageUrl);
      } catch (error) {
        console.log("Error updating custom image map, continuing without it");
      }
    }
    
    // Fix the availableOn field if it's a string instead of an array
    if (show.availableOn && typeof show.availableOn === 'string') {
      // Convert comma-separated string to array
      show.availableOn = show.availableOn.split(',').map(item => item.trim());
      console.log('Converted availableOn to array:', show.availableOn);
    }
    
    // Handle YouTube-specific fields
    if (show.isYouTubeChannel && !show.availableOn) {
      show.availableOn = ['YouTube'];
    }
    
    // Extract and handle themes with junction table if they're being updated
    const themeNames = show.themes;
    // Don't delete themes from the direct update - we need them in both places
    
    // Extract and handle platforms with junction table if they're being updated
    const platformNames = show.availableOn;
    delete show.availableOn; // Remove availableOn from the direct update
    
    // Save stimulation metrics and other important details to our custom details map
    const stimulationMetrics: Record<string, any> = {};
    const importantFields = [
      'stimulationScore', 'musicTempo', 'totalMusicLevel', 'totalSoundEffectTimeLevel', 
      'sceneFrequency', 'interactivityLevel', 'dialogueIntensity', 'soundEffectsLevel',
      'animationStyle', 'ageRange', 'themes', 'description'
    ];
    
    // Round stimulation score to whole numbers if it exists
    if ('stimulationScore' in show && show.stimulationScore !== undefined) {
      show.stimulationScore = Math.round(Number(show.stimulationScore));
    }
    
    // Check if we're updating any important fields
    let hasImportantFields = false;
    for (const field of importantFields) {
      if (field in show && show[field as keyof typeof show] !== undefined) {
        stimulationMetrics[field] = show[field as keyof typeof show];
        hasImportantFields = true;
      }
    }
    
    // Save to custom details map if we have important fields to preserve
    if (hasImportantFields && updateCustomShowDetails) {
      try {
        updateCustomShowDetails(id, stimulationMetrics);
      } catch (error) {
        console.log("Error updating custom show details, continuing without it");
      }
    }
    
    const [updatedShow] = await db
      .update(tvShows)
      .set(show)
      .where(eq(tvShows.id, id))
      .returning();
      
    // Update themes if provided
    if (themeNames && Array.isArray(themeNames)) {
      try {
        console.log(`Updating themes for show ${id}:`, themeNames);
        await this.updateThemesForShow(id, themeNames);
        console.log(`Successfully updated themes for show ${id}`);
      } catch (error) {
        console.error("Error updating themes for show", id, ":", error);
        // Continue with the update even if theme update fails
      }
    } else {
      console.log(`No themes to update for show ${id}, themeNames:`, themeNames);
    }
    
    // Update platforms if provided
    if (platformNames && Array.isArray(platformNames)) {
      try {
        await this.updatePlatformsForShow(id, platformNames);
      } catch (error) {
        console.error("Error updating platforms:", error);
        // Continue with the update even if platform update fails
      }
    }
    
    // Return the updated show with junction table data included
    return this.getTvShowById(id);
  }

  async unfeaturedAllShows(): Promise<void> {
    try {
      await db.update(tvShows).set({ isFeatured: false });
    } catch (error) {
      console.error('Error unfeaturing all shows:', error);
      throw error;
    }
  }

  async deleteTvShow(id: number): Promise<boolean> {
    try {
      // First, delete any junction table entries
      await db.delete(tvShowThemes).where(eq(tvShowThemes.tvShowId, id));
      await db.delete(tvShowPlatforms).where(eq(tvShowPlatforms.tvShowId, id));
      
      // Then delete the show itself
      const result = await db.delete(tvShows).where(eq(tvShows.id, id));
      return result.count > 0;
    } catch (error) {
      console.error(`Error deleting TV show with ID ${id}:`, error);
      throw error;
    }
  }

  async getReviewsByTvShowId(tvShowId: number): Promise<TvShowReview[]> {
    try {
      // Use sql template to explicitly specify column names
      const result = await db.execute(sql`
        SELECT 
          id, 
          tv_show_id as "tvShowId",
          user_id as "userId", 
          user_name as "userName", 
          rating, 
          review, 
          show_name as "showName",
          created_at as "createdAt"
        FROM tv_show_reviews 
        WHERE tv_show_id = ${tvShowId}
        ORDER BY created_at DESC
      `);
      
      // Convert the result to a proper array
      const reviews = result.rows.map(row => ({
        id: row.id,
        tvShowId: row.tvShowId,
        userId: row.userId,
        userName: row.userName,
        rating: row.rating,
        review: row.review,
        showName: row.showName,
        createdAt: row.createdAt
      }));
      
      console.log(`Retrieved ${reviews.length} reviews for show ID ${tvShowId}`);
      return reviews;
    } catch (error) {
      console.error(`Error getting reviews for show ID ${tvShowId}:`, error);
      return [];
    }
  }
  
  async getReviewsByUserId(userId: string | number): Promise<TvShowReview[]> {
    try {
      // Convert userId to a number if it's a string
      const numericUserId = typeof userId === 'string' ? parseInt(userId) : userId;
      
      console.log(`Fetching reviews for user ID: ${numericUserId} (original type: ${typeof userId})`);
      
      // Fall back to direct SQL query since we're having issues with the ORM
      const { rows } = await db.execute(sql`
        SELECT 
          r.id, 
          r.tv_show_id AS "tvShowId",
          r.user_id AS "userId", 
          r.user_name AS "userName", 
          r.rating, 
          r.review, 
          r.created_at AS "createdAt",
          r.show_name AS "showName",
          t.name AS "tvShowName",
          t.image_url AS "showImageUrl"
        FROM tv_show_reviews r
        LEFT JOIN tv_shows t ON r.tv_show_id = t.id
        WHERE r.user_id = ${numericUserId}
        ORDER BY r.created_at DESC
      `);
      
      console.log(`Found ${rows.length} reviews for user ${numericUserId}`, 
        rows.length > 0 ? JSON.stringify(rows[0]) : 'No reviews found');
        
      return rows;
    } catch (error) {
      console.error(`Error getting reviews for user ${userId}:`, error);
      return [];
    }
  }

  async addReview(review: InsertTvShowReview): Promise<TvShowReview> {
    // Get the show name to store with the review
    let showName = null;
    try {
      if (review.tvShowId) {
        // First try with a simple query
        const show = await db.query.tvShows.findFirst({
          where: eq(tvShows.id, review.tvShowId)
        });
        
        if (show && show.name) {
          showName = show.name;
          console.log(`Found show name for review: "${showName}"`);
        } else {
          // Fallback with a direct SQL query if findFirst failed
          const result = await db.execute(sql`
            SELECT name FROM tv_shows WHERE id = ${review.tvShowId} LIMIT 1
          `);
          
          if (result && result.rows && result.rows[0]) {
            showName = result.rows[0].name;
            console.log(`Fallback: Found show name: "${showName}"`);
          }
        }
      }
    } catch (error) {
      console.error("Error getting show name for review:", error);
    }

    // Directly get show name from show ID if still missing
    if (!showName && review.tvShowId) {
      try {
        const rows = await db.execute(sql`
          SELECT name FROM tv_shows WHERE id = ${review.tvShowId}
        `);
        if (rows && rows.rows && rows.rows.length > 0) {
          showName = rows.rows[0].name;
          console.log(`Last resort: Got show name: "${showName}"`);
        }
      } catch (e) {
        console.error("Final attempt to get show name failed:", e);
      }
    }

    // Make absolutely sure we have a show name
    if (!showName && review.tvShowId) {
      try {
        // One final direct query as a failsafe
        const rows = await db.execute(sql`
          SELECT name FROM tv_shows WHERE id = ${review.tvShowId}
        `);
        
        if (rows && rows.rows && rows.rows.length > 0) {
          showName = rows.rows[0].name;
          console.log(`Final failsafe: Got show name: "${showName}"`);
        }
      } catch (e) {
        console.error("Ultimate fallback for show name failed:", e);
      }
    }
    
    // Let Postgres handle the timestamp with defaultNow()
    const [newReview] = await db
      .insert(tvShowReviews)
      .values({
        ...review,
        showName: showName || "Unknown Show"  // Fallback to prevent nulls
      })
      .returning();
    
    console.log("Saved review with showName:", showName);
    
    // Award points for submitting a review if applicable
    try {
      if (review.userId) {
        try {
          await db.execute(sql`
            UPDATE users 
            SET total_points = COALESCE(total_points, 0) + 10 
            WHERE id = ${review.userId}
          `);
          console.log(`Awarded 10 points to user ${review.userId} for review`);
        } catch (pointsError) {
          console.error("Simple points update error:", pointsError);
        }
      }
    } catch (error) {
      console.error("Error awarding points for review:", error);
    }
    
    return newReview;
  }

  async trackShowSearch(tvShowId: number): Promise<void> {
    try {
      // Use direct query with parameters to avoid timestamp issues
      const client = await pool.connect();
      
      try {
        // First check if the record exists
        const checkResult = await client.query(
          'SELECT id, search_count FROM tv_show_searches WHERE tv_show_id = $1',
          [tvShowId]
        );
        
        if (checkResult.rows.length > 0) {
          // Update existing record
          const existingSearch = checkResult.rows[0];
          const newCount = existingSearch.search_count + 1;
          await client.query(
            'UPDATE tv_show_searches SET search_count = $1, last_searched = CURRENT_TIMESTAMP WHERE id = $2',
            [newCount, existingSearch.id]
          );
        } else {
          // Insert new record
          await client.query(
            'INSERT INTO tv_show_searches (tv_show_id, search_count, last_searched) VALUES ($1, $2, CURRENT_TIMESTAMP)',
            [tvShowId, 1]
          );
        }
      } finally {
        client.release();
      }
    } catch (error) {
      // Log error but don't let it block the search functionality
      console.error(`Error tracking search for TV show ID ${tvShowId}:`, error);
    }
  }

  async trackShowView(tvShowId: number): Promise<void> {
    try {
      // Use the new separate table for view tracking
      const [existingView] = await db
        .select()
        .from(tvShowViews)
        .where(eq(tvShowViews.tvShowId, tvShowId));

      if (existingView) {
        // Update existing view record
        await db
          .update(tvShowViews)
          .set({
            viewCount: existingView.viewCount + 1
          })
          .where(eq(tvShowViews.id, existingView.id));
      } else {
        // Create new view record
        await db.insert(tvShowViews).values({
          tvShowId,
          viewCount: 1
        });
      }
    } catch (error) {
      console.error("Error tracking TV show view:", error);
      throw error;
    }
  }

  async getPopularShows(limit: number = 10): Promise<TvShow[]> {
    // Get the top viewed shows using the new dedicated view tracking table
    try {
      const popularShows = await db
        .select({
          show: tvShows,
          totalViews: tvShowViews.viewCount,
        })
        .from(tvShowViews)
        .innerJoin(tvShows, eq(tvShowViews.tvShowId, tvShows.id))
        .orderBy(desc(tvShowViews.viewCount))
        .limit(limit);

      return popularShows.map((item) => item.show);
    } catch (error) {
      console.error("Error getting popular shows:", error);
      // Fallback to get all shows if the join fails
      return this.getAllTvShows().then(shows => shows.slice(0, limit));
    }
  }

  async getHighlyRatedShows(limit: number = 24): Promise<TvShow[]> {
    try {
      // Use raw SQL with the Drizzle database connection
      const result = await db.execute(sql`
        SELECT 
          ts.*,
          ROUND(AVG(tr.rating)::numeric, 2) as avg_rating,
          COUNT(tr.rating) as review_count,
          COUNT(CASE WHEN tr.rating >= 4 THEN 1 END) as high_rating_count
        FROM tv_shows ts
        INNER JOIN tv_show_reviews tr ON ts.id = tr.tv_show_id
        GROUP BY ts.id
        HAVING COUNT(tr.rating) >= 2
        ORDER BY 
          COUNT(CASE WHEN tr.rating >= 4 THEN 1 END) DESC,
          ROUND(AVG(tr.rating)::numeric, 2) DESC,
          COUNT(tr.rating) DESC
        LIMIT ${limit}
      `);
      
      // Check if result is array or has rows property
      const rows = Array.isArray(result) ? result : result.rows || [];
      
      return rows.map(row => ({
        id: row.id,
        name: row.name,
        description: row.description,
        imageUrl: row.image_url,
        ageRange: row.age_range,
        episodeLength: row.episode_length,
        themes: row.themes,
        availableOn: row.available_on,
        stimulationScore: row.stimulation_score,
        interactionLevel: row.interactivity_level,
        dialogueIntensity: row.dialogue_intensity,
        soundFrequency: row.sound_frequency,
        totalMusicLevel: row.total_music_level,
        musicTempo: row.music_tempo,
        soundEffectsLevel: row.sound_effects_level,
        animationStyle: row.animation_style,
        sceneFrequency: row.scene_frequency,
        totalSoundEffectTimeLevel: row.total_sound_effect_time_level,
        network: row.network,
        year: row.year,
        productionCompany: row.production_company,
        creator: row.creator,
        releaseYear: row.release_year,
        endYear: row.end_year,
        isOngoing: row.is_ongoing,
        seasons: row.seasons,
        totalEpisodes: row.total_episodes,
        productionCountry: row.production_country,
        language: row.language,
        genre: row.genre,
        targetAudience: row.target_audience,
        viewerRating: row.viewer_rating,
        contentRating: row.content_rating,
        awards: row.awards,
        synopsis: row.synopsis,
        tags: row.tags,
        isYouTubeChannel: row.is_youtube_channel,
        channelId: row.channel_id,
        subscriberCount: row.subscriber_count,
        videoCount: row.video_count,
        publishedAt: row.published_at,
        hasOmdbData: row.has_omdb_data,
        interactivityLevel: row.interactivity_level,
        creativityRating: row.creativity_rating,
        isFeatured: row.is_featured,
        hasYoutubeData: row.has_youtube_data
      }));
    } catch (error) {
      console.error("Error getting highly rated shows:", error);
      return [];
    }
  }

  async importShowsFromGitHub(githubShows: TvShowGitHub[]): Promise<TvShow[]> {
    const importedShows: TvShow[] = [];

    for (const githubShow of githubShows) {
      try {
        if (!githubShow.title) {
          console.warn("Skipping show with no title:", githubShow);
          continue;
        }

        // Check if the show already exists
        const [existingShow] = await db
          .select()
          .from(tvShows)
          .where(eq(tvShows.name, githubShow.title));

        if (existingShow) {
          // Update the existing show
          
          // Check for custom image URL first
          const preservedImageUrl = preserveCustomImageUrl(existingShow.id, existingShow.imageUrl);
          
          // Create the update object with GitHub data
          const updateData = {
            // Use the correct property names from the TvShowGitHub type
            description: existingShow.description, // Keep existing description if not provided
            stimulationScore: typeof githubShow.stimulation_score === 'number' 
              ? Math.round(githubShow.stimulation_score) 
              : Math.round(existingShow.stimulationScore),
            dialogueIntensity: githubShow.dialogue_intensity || existingShow.dialogueIntensity,
            soundEffectsLevel: githubShow.sound_effects_level || existingShow.soundEffectsLevel,
            interactivityLevel: githubShow.interactivity_level || existingShow.interactivityLevel,
            ageRange: githubShow.target_age_group || existingShow.ageRange,
            themes: githubShow.themes || existingShow.themes,
            availableOn: [githubShow.platform] || existingShow.availableOn,
            releaseYear: typeof githubShow.release_year === 'number' && !isNaN(githubShow.release_year) ? githubShow.release_year : existingShow.releaseYear,
            endYear: typeof githubShow.end_year === 'number' && !isNaN(githubShow.end_year) ? githubShow.end_year : existingShow.endYear,
            episodeLength: githubShow.avg_episode_length && !isNaN(parseInt(githubShow.avg_episode_length)) ? parseInt(githubShow.avg_episode_length) : existingShow.episodeLength,
            seasons: githubShow.seasons && !isNaN(parseInt(githubShow.seasons)) ? parseInt(githubShow.seasons) : existingShow.seasons,
            // Preserve our custom image URLs during imports
            imageUrl: preservedImageUrl || githubShow.imageUrl || getDefaultImageUrl(githubShow.title, githubShow.image_filename) || existingShow.imageUrl,
          };
          
          // Apply custom details preservation - this will prioritize any custom stimulation metrics
          // and other important details we've saved from admin edits
          const mergedData = preserveCustomShowDetails(existingShow.id, existingShow, updateData);
          
          const [updatedShow] = await db
            .update(tvShows)
            .set(mergedData)
            .where(eq(tvShows.id, existingShow.id))
            .returning();

          importedShows.push(updatedShow);
        } else {
          // Insert new show with default values for required fields
          const tvShow: Partial<InsertTvShow> = {
            name: githubShow.title,
            description: 'A children\'s TV show', // Default description
            stimulationScore: typeof githubShow.stimulation_score === 'number' ? Math.round(githubShow.stimulation_score) : 3,
            dialogueIntensity: githubShow.dialogue_intensity || 'Medium',
            soundEffectsLevel: githubShow.sound_effects_level || 'Medium',
            interactivityLevel: githubShow.interactivity_level || 'Medium',
            ageRange: githubShow.target_age_group || '3-5',
            themes: githubShow.themes || [],
            availableOn: [githubShow.platform],
            releaseYear: typeof githubShow.release_year === 'number' && !isNaN(githubShow.release_year) ? githubShow.release_year : null,
            endYear: typeof githubShow.end_year === 'number' && !isNaN(githubShow.end_year) ? githubShow.end_year : null,
            episodeLength: githubShow.avg_episode_length && !isNaN(parseInt(githubShow.avg_episode_length)) ? parseInt(githubShow.avg_episode_length) : 15,
            seasons: githubShow.seasons && !isNaN(parseInt(githubShow.seasons)) ? parseInt(githubShow.seasons) : null,
            imageUrl: githubShow.imageUrl || getDefaultImageUrl(githubShow.title, githubShow.image_filename),
            // Add default values for required fields using proper camelCase
            overallRating: 3
          };

          const [newShow] = await db.insert(tvShows).values(tvShow).returning();
          importedShows.push(newShow);
        }
      } catch (error) {
        console.error(`Error importing show ${githubShow.title}:`, error);
      }
    }

    return importedShows;
  }

  // Favorites methods
  async addFavorite(userId: number, tvShowId: number): Promise<Favorite> {
    // Check if the favorite already exists
    const [existingFavorite] = await db
      .select()
      .from(favorites)
      .where(and(
        eq(favorites.userId, userId),
        eq(favorites.tvShowId, tvShowId)
      ));

    if (existingFavorite) {
      return existingFavorite;
    }

    // Add the favorite
    const now = new Date().toISOString();
    const [favorite] = await db
      .insert(favorites)
      .values({
        userId,
        tvShowId,
        createdAt: now,
      })
      .returning();

    return favorite;
  }

  async removeFavorite(userId: number, tvShowId: number): Promise<boolean> {
    const result = await db
      .delete(favorites)
      .where(and(
        eq(favorites.userId, userId),
        eq(favorites.tvShowId, tvShowId)
      ));

    return result.count > 0;
  }

  async getUserFavorites(userId: number): Promise<TvShow[]> {
    const favoriteShows = await db
      .select({
        show: tvShows,
      })
      .from(favorites)
      .innerJoin(tvShows, eq(favorites.tvShowId, tvShows.id))
      .where(eq(favorites.userId, userId))
      .orderBy(tvShows.name);

    return favoriteShows.map(item => item.show);
  }

  async isFavorite(userId: number, tvShowId: number): Promise<boolean> {
    const [favorite] = await db
      .select()
      .from(favorites)
      .where(and(
        eq(favorites.userId, userId),
        eq(favorites.tvShowId, tvShowId)
      ));

    return !!favorite;
  }

  async getSimilarShows(userId: number, limit: number = 5): Promise<TvShow[]> {
    // Get user's favorite shows
    const userFavorites = await this.getUserFavorites(userId);
    
    if (userFavorites.length === 0) {
      // If user has no favorites, return popular shows instead
      return this.getPopularShows(limit);
    }
    
    // Extract features from user's favorites to build a profile
    const favoriteIds = userFavorites.map(show => show.id);
    const avgStimulationScore = Math.round(
      userFavorites.reduce((sum, show) => sum + show.stimulationScore, 0) / userFavorites.length
    );
    
    // Get common themes from user's favorites
    const themeFrequency: Record<string, number> = {};
    userFavorites.forEach(show => {
      show.themes?.forEach(theme => {
        themeFrequency[theme] = (themeFrequency[theme] || 0) + 1;
      });
    });
    
    // Get top themes (those that appear in at least 25% of favorites)
    const minThemeCount = Math.max(1, Math.floor(userFavorites.length * 0.25));
    const commonThemes = Object.entries(themeFrequency)
      .filter(([_, count]) => count >= minThemeCount)
      .map(([theme]) => theme);
    
    // Find shows with similar characteristics but not already in favorites
    // This is a simple recommendation algorithm that checks for shows with
    // similar stimulation score and at least one common theme
    const stimScoreRange = { min: Math.max(1, avgStimulationScore - 1), max: Math.min(5, avgStimulationScore + 1) };
    
    const similarShows = await db
      .select()
      .from(tvShows)
      .where(
        and(
          sql`${tvShows.stimulationScore} >= ${stimScoreRange.min} AND ${tvShows.stimulationScore} <= ${stimScoreRange.max}`,
          favoriteIds.length > 0 
            ? sql`NOT (${tvShows.id} IN (${sql.join(favoriteIds)}))`
            : sql`1=1`
        )
      )
      .orderBy(desc(tvShows.stimulationScore)) // Sort by stimulation score for consistent results
      .limit(limit * 2); // Get more than we need to filter by themes
    
    // Score each show based on theme matches and stimulation score similarity
    interface ScoredShow {
      show: TvShow;
      score: number;
    }
    
    const scoredShows: ScoredShow[] = similarShows.map(show => {
      let score = 0;
      
      // Score based on stimulation score similarity (0-5 points)
      const stimDiff = Math.abs(show.stimulationScore - avgStimulationScore);
      score += (5 - stimDiff);
      
      // Score based on theme matches (3 points per match)
      if (show.themes) {
        commonThemes.forEach(theme => {
          if (show.themes?.includes(theme)) {
            score += 3;
          }
        });
      }
      
      return { show, score };
    });
    
    // Sort by score and take the top 'limit' shows
    return scoredShows
      .sort((a, b) => b.score - a.score)
      .slice(0, limit)
      .map(item => item.show);
  }

  async getSimilarShowsWithMetadata(userId: number, limit: number = 5): Promise<any[]> {
    const favoriteIds = await db
      .select({ showId: favorites.tvShowId })
      .from(favorites)
      .where(eq(favorites.userId, userId))
      .then(rows => rows.map(row => row.showId));

    // Get user's average stimulation score preference
    const avgStimResult = favoriteIds.length > 0 
      ? await db
          .select({ avgStim: sql<number>`AVG(${tvShows.stimulationScore})` })
          .from(tvShows)
          .where(inArray(tvShows.id, favoriteIds))
      : null;

    const avgStimulationScore = avgStimResult?.[0]?.avgStim ?? 3;

    // Get common themes from user's favorites
    const commonThemes = favoriteIds.length > 0
      ? await db
          .select({ themes: tvShows.themes })
          .from(tvShows)
          .where(inArray(tvShows.id, favoriteIds))
          .then(rows => 
            rows
              .flatMap(row => row.themes || [])
              .reduce((acc, theme) => {
                acc[theme] = (acc[theme] || 0) + 1;
                return acc;
              }, {} as Record<string, number>)
          )
          .then(themeCounts => 
            Object.entries(themeCounts)
              .sort(([,a], [,b]) => b - a)
              .slice(0, 5)
              .map(([theme]) => theme)
          )
      : [];

    const stimScoreRange = { min: Math.max(1, avgStimulationScore - 1), max: Math.min(5, avgStimulationScore + 1) };
    
    // Get recommended shows with aggregated review and favorite data
    const showsWithMetadata = await db
      .select({
        id: tvShows.id,
        name: tvShows.name,
        description: tvShows.description,
        ageRange: tvShows.ageRange,
        episodeLength: tvShows.episodeLength,
        creator: tvShows.creator,
        releaseYear: tvShows.releaseYear,
        endYear: tvShows.endYear,
        isOngoing: tvShows.isOngoing,
        stimulationScore: tvShows.stimulationScore,
        interactivityLevel: tvShows.interactivityLevel,
        themes: tvShows.themes,
        imageUrl: tvShows.imageUrl,
        videoUrl: tvShows.videoUrl,
        platforms: tvShows.platforms,
        tags: tvShows.tags,
        averageRating: sql<number>`COALESCE(AVG(${tvShowReviews.rating}), 0)`,
        reviewCount: sql<number>`COUNT(DISTINCT ${tvShowReviews.id})`,
        isFavorite: sql<boolean>`BOOL_OR(${favorites.userId} = ${userId})`,
      })
      .from(tvShows)
      .leftJoin(tvShowReviews, eq(tvShowReviews.tvShowId, tvShows.id))
      .leftJoin(favorites, eq(favorites.tvShowId, tvShows.id))
      .where(
        and(
          sql`${tvShows.stimulationScore} >= ${stimScoreRange.min} AND ${tvShows.stimulationScore} <= ${stimScoreRange.max}`,
          favoriteIds.length > 0 
            ? not(inArray(tvShows.id, favoriteIds))
            : sql`1=1`
        )
      )
      .groupBy(tvShows.id)
      .orderBy(desc(tvShows.stimulationScore))
      .limit(limit * 2);

    // Score and sort the shows
    const scoredShows = showsWithMetadata.map(show => {
      let score = 0;
      
      const stimDiff = Math.abs(show.stimulationScore - avgStimulationScore);
      score += (5 - stimDiff);
      
      if (show.themes) {
        commonThemes.forEach(theme => {
          if (show.themes?.includes(theme)) {
            score += 3;
          }
        });
      }
      
      return { ...show, score };
    });

    return scoredShows
      .sort((a, b) => b.score - a.score)
      .slice(0, limit);
  }

  async getUserProfileWithMetadata(userId: number): Promise<any> {
    // Get user basic info
    const userResult = await db
      .select()
      .from(users)
      .where(eq(users.id, userId))
      .limit(1);

    if (userResult.length === 0) {
      return null;
    }

    const user = userResult[0];

    // Get user's points
    const pointsResult = await this.getUserPoints(userId);

    // Get user's reviews with show information
    const reviewsWithShows = await db
      .select({
        id: tvShowReviews.id,
        rating: tvShowReviews.rating,
        review: tvShowReviews.review,
        createdAt: tvShowReviews.createdAt,
        showId: tvShowReviews.tvShowId,
        showName: tvShows.name,
        showImageUrl: tvShows.imageUrl,
      })
      .from(tvShowReviews)
      .leftJoin(tvShows, eq(tvShowReviews.tvShowId, tvShows.id))
      .where(eq(tvShowReviews.userId, userId))
      .orderBy(desc(tvShowReviews.createdAt))
      .limit(20);

    // Get user's favorites with show information
    const favoritesWithShows = await db
      .select({
        id: favorites.id,
        createdAt: favorites.createdAt,
        showId: favorites.tvShowId,
        showName: tvShows.name,
        showImageUrl: tvShows.imageUrl,
        showAgeRange: tvShows.ageRange,
        showStimulationScore: tvShows.stimulationScore,
      })
      .from(favorites)
      .leftJoin(tvShows, eq(favorites.tvShowId, tvShows.id))
      .where(eq(favorites.userId, userId))
      .orderBy(desc(favorites.createdAt))
      .limit(20);

    // Get user's points history
    const pointsHistory = await this.getUserPointsHistory(userId);

    // Transform favorites data to match frontend expectations
    const transformedFavorites = favoritesWithShows.map((fav: any) => ({
      id: fav.showId,
      name: fav.showName,
      imageUrl: fav.showImageUrl,
      ageRange: fav.showAgeRange,
      stimulationScore: fav.showStimulationScore,
      createdAt: fav.createdAt
    }));

    // Transform reviews data to match frontend expectations
    const transformedReviews = reviewsWithShows.map((review: any) => ({
      id: review.id,
      tvShowId: review.showId,
      userId: userId.toString(),
      userName: user.username,
      rating: review.rating,
      review: review.review,
      createdAt: review.createdAt,
      showName: review.showName || 'Unknown Show'
    }));

    return {
      user: {
        id: user.id,
        username: user.username,
        backgroundColor: user.backgroundColor || '#6366f1',
        joinedAt: user.createdAt
      },
      points: pointsResult,
      pointsHistory: pointsHistory || [],
      reviews: transformedReviews || [],
      favorites: transformedFavorites || []
    };
  }
  
  // -------------------------------------------------------------------------
  // Gamification Methods
  // -------------------------------------------------------------------------
  
  async getUserPoints(userId: number): Promise<{ 
    total: number; 
    breakdown: {
      reviews: number;
      upvotesGiven: number;
      upvotesReceived: number;
      consecutiveLogins: number;
      loginRewards: number;
      shares: number;
      referrals: number;
      showSubmissions: number;
      researchRead: number;
    },
    rank: string;
  }> {
    try {
      // Get user's total points and rank
      const [userResult] = await db
        .select({ 
          totalPoints: users.totalPoints,
          rank: users.rank
        })
        .from(users)
        .where(eq(users.id, userId));
      
      const totalPoints = userResult?.totalPoints || 0;
      const userRank = userResult?.rank || 'TV Watcher';
      
      // Get point breakdowns by category
      const reviewPoints = await this.getPointsByActivityType(userId, 'review');
      const upvotesGivenPoints = await this.getPointsByActivityType(userId, 'upvote_given');
      const upvotesReceivedPoints = await this.getPointsByActivityType(userId, 'upvote_received');
      const loginStreakPoints = await this.getPointsByActivityType(userId, 'login_streak');
      const loginRewardPoints = await this.getPointsByActivityType(userId, 'login_reward');
      const sharePoints = await this.getPointsByActivityType(userId, 'share');
      const referralClickPoints = await this.getPointsByActivityType(userId, 'referral_click');
      const submissionPoints = await this.getPointsByActivityType(userId, 'show_submission');
      const submissionApprovedPoints = await this.getPointsByActivityType(userId, 'show_submission_approved');
      const totalSubmissionPoints = submissionPoints + submissionApprovedPoints;
      const researchPoints = await this.getPointsByActivityType(userId, 'research_read');
      
      return {
        total: totalPoints,
        breakdown: {
          reviews: reviewPoints,
          upvotesGiven: upvotesGivenPoints,
          upvotesReceived: upvotesReceivedPoints,
          consecutiveLogins: loginStreakPoints,
          loginRewards: loginRewardPoints,
          shares: sharePoints,
          referrals: referralClickPoints,
          showSubmissions: totalSubmissionPoints,
          researchRead: researchPoints
        },
        rank: userRank
      };
    } catch (error) {
      console.error('Error getting user points:', error);
      return {
        total: 0,
        breakdown: {
          reviews: 0,
          upvotesGiven: 0,
          upvotesReceived: 0,
          consecutiveLogins: 0,
          loginRewards: 0,
          shares: 0,
          referrals: 0,
          showSubmissions: 0,
          researchRead: 0
        },
        rank: 'TV Watcher'
      };
    }
  }
  
  // Helper method to get points by activity type
  private async getPointsByActivityType(userId: number, activityType: string): Promise<number> {
    try {
      const result = await db
        .select({ 
          sum: sql`COALESCE(SUM(${userPointsHistory.points}), 0)` 
        })
        .from(userPointsHistory)
        .where(
          and(
            eq(userPointsHistory.userId, userId),
            eq(userPointsHistory.activityType, activityType)
          )
        );
      
      return Number(result[0]?.sum || 0);
    } catch (error) {
      console.error(`Error getting ${activityType} points:`, error);
      return 0;
    }
  }
  
  async getUserPointsHistory(userId: number): Promise<any[]> {
    try {
      const history = await db
        .select()
        .from(userPointsHistory)
        .where(eq(userPointsHistory.userId, userId))
        .orderBy(desc(userPointsHistory.createdAt));
      
      return history;
    } catch (error) {
      console.error('Error getting user points history:', error);
      return [];
    }
  }

  async getUserReviews(userId: number): Promise<any[]> {
    try {
      // Get reviews for this user with proper show names from tv_shows table
      const reviews = await db
        .select({
          id: tvShowReviews.id,
          tvShowId: tvShowReviews.tvShowId,
          userId: tvShowReviews.userId,
          userName: tvShowReviews.userName,
          rating: tvShowReviews.rating,
          review: tvShowReviews.review,
          createdAt: tvShowReviews.createdAt,
          showName: tvShows.name
        })
        .from(tvShowReviews)
        .leftJoin(tvShows, eq(tvShowReviews.tvShowId, tvShows.id))
        .where(eq(tvShowReviews.userId, userId.toString()))
        .orderBy(desc(tvShowReviews.createdAt));
      
      return reviews.map(review => ({
        ...review,
        showName: review.showName || 'Unknown Show'
      }));
    } catch (error) {
      console.error('Error getting user reviews:', error);
      return [];
    }
  }
  
  async awardPoints(userId: number, points: number, activityType: string, description?: string): Promise<any> {
    console.log(`ATTEMPTING TO AWARD ${points} POINTS TO USER ${userId} FOR ${activityType}`);
    
    // Using transaction for database integrity
    return await db.transaction(async (tx) => {
      try {
        console.log(`Starting transaction to award points...`);
        
        // Add to points history
        const [pointHistory] = await tx
          .insert(userPointsHistory)
          .values({
            userId: userId,
            points: points,
            activityType: activityType,
            description: description || null
          })
          .returning();
        
        console.log(`Added entry to points history: ${JSON.stringify(pointHistory)}`);
        
        // Use direct SQL query to update total points to avoid schema mismatches
        try {
          // DIRECT DB OPERATION: Update points using simplified approach
          // This ensures we increment the points directly in the database
          
          // Using sql template literal instead of raw query to ensure parameters are passed correctly
          const updateResult = await tx.execute(sql`
            UPDATE users 
            SET total_points = COALESCE(total_points, 0) + ${points} 
            WHERE id = ${userId} 
            RETURNING total_points, id
          `);
          
          console.log(`Update result: ${JSON.stringify(updateResult.rows)}`);
          
          if (updateResult.rows.length > 0) {
            const newTotal = parseInt(updateResult.rows[0]?.total_points || '0');
            console.log(`User ${userId} now has ${newTotal} total points`);
            
            // Update user rank based on total points
            let newRank = 'TV Watcher';
            if (newTotal >= 10000) newRank = 'TV Guru';
            else if (newTotal >= 5000) newRank = 'TV Expert';
            else if (newTotal >= 1000) newRank = 'TV Enthusiast';
            else if (newTotal >= 500) newRank = 'TV Fan';
            else if (newTotal >= 100) newRank = 'TV Viewer';
            
            // Update user rank
            await tx.execute(
              `UPDATE users SET rank = $1 WHERE id = $2`,
              [newRank, userId]
            );
            
            console.log(`Updated user ${userId} rank to ${newRank}`);
          } else {
            console.log(`No user found with ID ${userId} - points not added`);
          }
        } catch (sqlError) {
          // If SQL update fails, log error but don't fail the transaction
          // Points history is still recorded
          console.error('Error updating user points total:', sqlError);
          console.error(sqlError);
        }
        
        console.log(`Points award complete for user ${userId}`);
        return pointHistory;
      } catch (error) {
        console.error('Error awarding points:', error);
        console.error(error);
        throw error;
      }
    });
  }
  
  async getTopUsers(limit: number = 10): Promise<any[]> {
    try {
      const topUsers = await db
        .select({
          id: users.id,
          username: users.username,
          totalPoints: users.totalPoints,
          rank: users.rank,
          backgroundColor: users.backgroundColor,
          country: users.country
        })
        .from(users)
        .where(sql`${users.totalPoints} > 0`)
        .orderBy(desc(users.totalPoints))
        .limit(limit);
      
      return topUsers;
    } catch (error) {
      console.error('Error getting top users:', error);
      return [];
    }
  }
  
  // Update a user's last login date for login reward tracking
  async updateUserLastLoginDate(userId: string | number, date: Date): Promise<boolean> {
    try {
      await db
        .update(users)
        .set({ lastLoginDate: date })
        .where(eq(users.id, userId.toString()));
      
      return true;
    } catch (error) {
      console.error('Error updating user last login date:', error);
      return false;
    }
  }
  
  async updateUserLoginStreak(userId: string): Promise<number> {
    // DISABLED: Login streak feature is disabled in favor of login rewards
    console.log('Login streak feature is disabled, only updating last login date');
    
    return await db.transaction(async (tx) => {
      try {
        const now = new Date();
        
        // Only update the last login date, but keep login streak as is
        await tx
          .update(users)
          .set({ 
            lastLoginDate: now
          })
          .where(eq(users.id, userId));
        
        // Return 1 to indicate the function executed successfully
        // But no streak was actually updated
        return 1;
      } catch (error) {
        console.error('Error updating last login date:', error);
        return 1;
      }
    });
  }
  
  // Review upvotes methods
  async addReviewUpvote(userId: number, reviewId: number): Promise<any> {
    let client = null;
    
    try {
      // First check if the upvote already exists using a simple query
      const checkQuery = await pool.query(
        'SELECT id FROM review_upvotes WHERE user_id = $1 AND review_id = $2 LIMIT 1',
        [userId, reviewId]
      );
      
      // If already upvoted, return early
      if (checkQuery.rowCount > 0) {
        console.log(`User ${userId} already upvoted review ${reviewId}`);
        return { 
          success: true, 
          already_upvoted: true,
          upvoteId: checkQuery.rows[0].id
        };
      }
      
      // Acquire a new client for the transaction
      client = await pool.connect();
      
      // Begin transaction
      await client.query('BEGIN');
      
      try {
        // Add the upvote using direct SQL
        const insertResult = await client.query(
          'INSERT INTO review_upvotes (user_id, review_id) VALUES ($1, $2) RETURNING id',
          [userId, reviewId]
        );
        
        if (insertResult.rowCount === 0) {
          throw new Error('Failed to insert upvote record');
        }
        
        const upvoteId = insertResult.rows[0].id;
        
        // First get the review details - using a safer approach that won't fail if there's a schema mismatch
        const reviewDetailsQuery = await client.query(
          'SELECT user_id as author_id, tv_show_id FROM tv_show_reviews WHERE id = $1',
          [reviewId]
        );
        
        let authorId = null;
        let showName = "a TV Show";
        
        // Only proceed with show name lookup if we found the review
        if (reviewDetailsQuery.rowCount > 0) {
          authorId = reviewDetailsQuery.rows[0].author_id;
          const tvShowId = reviewDetailsQuery.rows[0].tv_show_id;
          
          // Get show name in a separate query to avoid join failures
          try {
            const showQuery = await client.query(
              'SELECT name FROM tv_shows WHERE id = $1',
              [tvShowId]
            );
            
            if (showQuery.rowCount > 0) {
              showName = showQuery.rows[0].name || "a TV Show";
            }
          } catch (showError) {
            console.log("Could not get show name, using default:", showError.message);
          }
        }
        
        // Award points and track activity
        try {
          // First make sure the points history table exists
          const historyExists = await client.query(
            "SELECT EXISTS (SELECT FROM information_schema.tables WHERE table_name = 'user_points_history')"
          );
          
          if (historyExists.rows[0].exists) {
            // 1. Add upvote given to points history with better description
            const upvoteDescription = `Upvoted a review of ${showName}`;
            await client.query(
              'INSERT INTO user_points_history (user_id, points, activity_type, description) VALUES ($1, $2, $3, $4)',
              [userId, 1, 'upvote_given', upvoteDescription]
            );
            
            // 2. Update total points for the upvoter
            await client.query(
              'UPDATE users SET total_points = COALESCE(total_points, 0) + 1 WHERE id = $1 RETURNING total_points',
              [userId]
            );
            
            console.log(`Updated upvoter's (${userId}) total points with +1 point`);
            
            // Only award points to author if not self-upvoting
            if (authorId && authorId !== userId) {
              // 3. Add points to history for the review author
              const receivedDescription = `Your review of ${showName} received an upvote`;
              await client.query(
                'INSERT INTO user_points_history (user_id, points, activity_type, description) VALUES ($1, $2, $3, $4)',
                [authorId, 2, 'upvote_received', receivedDescription]
              );
              
              // 4. Update total points for the author
              const authorPointsResult = await client.query(
                'UPDATE users SET total_points = COALESCE(total_points, 0) + 2 WHERE id = $1 RETURNING total_points',
                [authorId]
              );
              
              if (authorPointsResult.rowCount > 0) {
                console.log(`Updated author's (${authorId}) total points with +2 points. New total: ${authorPointsResult.rows[0].total_points}`);
              }
            }
          }
        } catch (pointsError) {
          // Log the error but don't fail the transaction
          console.error('Points awarding encountered an error:', pointsError);
        }
        
        // Commit transaction
        await client.query('COMMIT');
        
        return { success: true, upvoteId: upvoteId };
      } catch (upvoteError) {
        // Rollback transaction on error
        if (client) {
          await client.query('ROLLBACK').catch(() => {});
        }
        console.error('Transaction error in addReviewUpvote:', upvoteError);
        throw upvoteError;
      } finally {
        // Release the client in finally block
        if (client) {
          client.release();
        }
      }
    } catch (error) {
      console.error('Error in addReviewUpvote:', error);
      throw error;
    }
  }
  
  async removeReviewUpvote(userId: number, reviewId: number): Promise<boolean> {
    try {
      // Get direct access to database  
      const client = await pool.connect();
      
      try {
        // Begin transaction
        await client.query('BEGIN');
        
        // Delete the upvote using direct SQL
        const deleteResult = await client.query(
          'DELETE FROM review_upvotes WHERE user_id = $1 AND review_id = $2 RETURNING id',
          [userId, reviewId]
        );
        
        const wasDeleted = deleteResult.rowCount > 0;
        
        // If we successfully deleted an upvote, record it
        if (wasDeleted) {
          try {
            // Check if points history table exists first
            const tableCheckResult = await client.query(
              "SELECT EXISTS (SELECT FROM information_schema.tables WHERE table_name = 'user_points_history')"
            );
            
            if (tableCheckResult.rows[0].exists) {
              // Record the removal in history
              await client.query(
                'INSERT INTO user_points_history (user_id, points, activity_type, description) VALUES ($1, $2, $3, $4)',
                [userId, 0, 'upvote_removed', 'Removed upvote from review']
              );
              
              // Note: We don't actually remove points awarded previously
            }
          } catch (historyError) {
            console.log('History tracking skipped:', historyError.message);
            // Continue with transaction, upvote removal is the primary concern
          }
        }
        
        // Commit transaction
        await client.query('COMMIT');
        
        return wasDeleted;
      } catch (error) {
        // Rollback on error
        await client.query('ROLLBACK');
        console.error('Error removing review upvote:', error);
        return false;
      } finally {
        // Always release the client back to the pool
        client.release();
      }
    } catch (error) {
      console.error('Error in removeReviewUpvote:', error);
      return false;
    }
  }
  
  async getReviewUpvotes(reviewId: number): Promise<any[]> {
    try {
      const result = await db
        .select({
          upvote: reviewUpvotes,
          username: users.username
        })
        .from(reviewUpvotes)
        .innerJoin(users, eq(reviewUpvotes.userId, users.id))
        .where(eq(reviewUpvotes.reviewId, reviewId))
        .orderBy(desc(reviewUpvotes.createdAt));
      
      return result.map(r => ({
        ...r.upvote,
        username: r.username
      }));
    } catch (error) {
      console.error('Error getting review upvotes:', error);
      return [];
    }
  }
  
  async hasUserUpvotedReview(userId: number, reviewId: number): Promise<boolean> {
    try {
      // Use direct database access for reliability 
      const client = await pool.connect();
      
      try {
        const result = await client.query(
          'SELECT EXISTS(SELECT 1 FROM review_upvotes WHERE user_id = $1 AND review_id = $2)',
          [userId, reviewId]
        );
        
        return result.rows[0].exists;
      } finally {
        client.release();
      }
    } catch (error) {
      console.error('Error checking if user upvoted review:', error);
      return false;
    }
  }
  
  // Research summaries methods
  async getResearchSummaries(): Promise<any[]> {
    try {
      const summaries = await db
        .select({
          id: researchSummaries.id,
          title: researchSummaries.title,
          summary: researchSummaries.summary,
          fullText: researchSummaries.fullText,
          category: researchSummaries.category,
          imageUrl: researchSummaries.imageUrl,
          source: researchSummaries.source,
          publishedDate: researchSummaries.publishedDate,
          createdAt: researchSummaries.createdAt,
          updatedAt: researchSummaries.updatedAt
        })
        .from(researchSummaries)
        .orderBy(desc(researchSummaries.createdAt));
      
      return summaries;
    } catch (error) {
      console.error('Error getting research summaries:', error);
      return [];
    }
  }
  
  async getResearchSummary(id: number): Promise<any | undefined> {
    try {
      const [summary] = await db
        .select({
          id: researchSummaries.id,
          title: researchSummaries.title,
          summary: researchSummaries.summary,
          fullText: researchSummaries.fullText,
          category: researchSummaries.category,
          imageUrl: researchSummaries.imageUrl,
          source: researchSummaries.source,
          publishedDate: researchSummaries.publishedDate,
          createdAt: researchSummaries.createdAt,
          updatedAt: researchSummaries.updatedAt
        })
        .from(researchSummaries)
        .where(eq(researchSummaries.id, id));
      
      return summary;
    } catch (error) {
      console.error('Error getting research summary:', error);
      return undefined;
    }
  }
  
  async hasUserReadResearch(userId: string, researchId: number): Promise<boolean> {
    try {
      const result = await db
        .select()
        .from(userReadResearch)
        .where(
          and(
            eq(userReadResearch.userId, userId),
            eq(userReadResearch.researchId, researchId)
          )
        );
      
      return result.length > 0;
    } catch (error) {
      console.error('Error checking if user read research:', error);
      return false;
    }
  }
  
  async markResearchAsRead(userId: string, researchId: number): Promise<any> {
    // First check if already read
    const alreadyRead = await this.hasUserReadResearch(userId, researchId);
    
    if (alreadyRead) {
      console.log(`User ${userId} already read research ${researchId}`);
      return { alreadyRead: true };
    }
    
    // Parse userId to number for the points system
    const numericUserId = parseInt(userId);
    console.log(`ATTEMPTING TO AWARD 5 POINTS TO USER ${numericUserId} FOR research_read`);
    
    try {
      // Mark as read
      const [record] = await db
        .insert(userReadResearch)
        .values({
          userId: userId,
          researchId: researchId
        })
        .returning();
      
      console.log(`User ${numericUserId} marking research as read`);
      
      try {
        // Insert directly into user_points_history table
        await db.execute(sql`
          INSERT INTO user_points_history 
          (user_id, points, activity_type, description, created_at, reference_id) 
          VALUES 
          (${numericUserId}, 5, 'research_read', ${`Read a research summary (ID: ${researchId})`}, NOW(), ${researchId})
        `);
        
        // Update total points
        await db.execute(sql`
          UPDATE users 
          SET total_points = COALESCE(total_points, 0) + 5
          WHERE id = ${numericUserId}
        `);
        
        console.log(`Updated user ${numericUserId}'s total points to (adding 5 research read points)`);
      } catch (pointsError) {
        console.error('Error adding research read points:', pointsError);
        console.error(pointsError);
        // Continue even if points award fails
      }
      
      return record;
    } catch (error) {
      console.error('Error marking research as read:', error);
      throw error;
    }
  }
  
  async getUserReadResearch(userId: string): Promise<any[]> {
    try {
      // Explicitly select only the fields that exist
      const result = await db
        .select({
          id: researchSummaries.id,
          title: researchSummaries.title,
          summary: researchSummaries.summary,
          fullText: researchSummaries.fullText,
          category: researchSummaries.category,
          imageUrl: researchSummaries.imageUrl,
          source: researchSummaries.source,
          publishedDate: researchSummaries.publishedDate,
          createdAt: researchSummaries.createdAt,
          updatedAt: researchSummaries.updatedAt,
          readAt: userReadResearch.readAt
        })
        .from(userReadResearch)
        .innerJoin(researchSummaries, eq(userReadResearch.researchId, researchSummaries.id))
        .where(eq(userReadResearch.userId, userId))
        .orderBy(desc(userReadResearch.readAt));
      
      return result;
    } catch (error) {
      console.error('Error getting user read research:', error);
      return [];
    }
  }
  
  async addResearchSummary(data: any): Promise<any> {
    try {
      console.log("Adding research summary with data:", data);
      
      const [summary] = await db
        .insert(researchSummaries)
        .values({
          title: data.title,
          summary: data.summary || null,
          fullText: data.fullText || null,
          category: data.category,
          imageUrl: data.imageUrl || null,
          source: data.source || null,
          originalUrl: data.originalUrl || null,
          publishedDate: data.publishedDate || null,
          headline: data.headline || null,
          subHeadline: data.subHeadline || null,
          keyFindings: data.keyFindings || null
        })
        .returning();
      
      console.log("Research summary added successfully:", summary);
      return summary;
    } catch (error) {
      console.error('Error adding research summary:', error);
      throw error;
    }
  }
  
  // NEW: Show submissions methods with smart duplicate detection and priority system
  
  // Helper function to normalize show names for duplicate detection
  private normalizeShowName(name: string): string {
    return name
      .toLowerCase()
      .replace(/[^\w\s]/g, '') // Remove special characters
      .replace(/\s+/g, ' ') // Normalize spaces
      .trim();
  }

  async addShowSubmission(data: { userId: string; showName: string; whereTheyWatch: string }): Promise<any> {
    return await db.transaction(async (tx) => {
      try {
        const normalizedName = this.normalizeShowName(data.showName);
        
        // Check if THIS user already submitted this show
        const userExistingSubmission = await tx
          .select()
          .from(showSubmissions)
          .where(
            and(
              eq(showSubmissions.userId, data.userId),
              eq(showSubmissions.normalizedName, normalizedName),
              eq(showSubmissions.status, 'pending')
            )
          )
          .limit(1);

        if (userExistingSubmission.length > 0) {
          // User already submitted this show - return error
          throw new Error("You have already submitted this show. Please wait for review or submit a different show.");
        }

        // Always create individual submission - no consolidation at submission time
        const [newSubmission] = await tx
          .insert(showSubmissions)
          .values({
            userId: data.userId,
            showName: data.showName,
            normalizedName: normalizedName,
            whereTheyWatch: data.whereTheyWatch,
            status: 'pending',
            requestCount: 1,
            priorityScore: 1,
          })
          .returning();
        
        return { ...newSubmission, isNewSubmission: true };
      } catch (error) {
        console.error('Error adding show submission:', error);
        throw error;
      }
    });
  }

  async getPendingShowSubmissions(): Promise<any[]> {
    try {
      const submissions = await db
        .select({
          id: showSubmissions.id,
          showName: showSubmissions.showName,
          whereTheyWatch: showSubmissions.whereTheyWatch,
          requestCount: showSubmissions.requestCount,
          priorityScore: showSubmissions.priorityScore,
          createdAt: showSubmissions.createdAt,
          status: showSubmissions.status,
        })
        .from(showSubmissions)
        .where(eq(showSubmissions.status, 'pending'))
        .orderBy(desc(showSubmissions.priorityScore), desc(showSubmissions.requestCount));
      
      return submissions;
    } catch (error) {
      console.error('Error getting pending show submissions:', error);
      return [];
    }
  }

  async getUserShowSubmissions(userId: string): Promise<any[]> {
    try {
      const submissions = await db
        .select({
          id: showSubmissions.id,
          userId: showSubmissions.userId,
          showName: showSubmissions.showName,
          whereTheyWatch: showSubmissions.whereTheyWatch,
          status: showSubmissions.status,
          createdAt: showSubmissions.createdAt,
          normalizedName: showSubmissions.normalizedName,
          rejectionReason: notifications.message
        })
        .from(showSubmissions)
        .leftJoin(
          notifications,
          and(
            eq(notifications.userId, parseInt(userId)),
            eq(notifications.relatedShowName, showSubmissions.normalizedName),
            eq(notifications.type, 'show_rejection')
          )
        )
        .where(eq(showSubmissions.userId, userId))
        .orderBy(desc(showSubmissions.createdAt));
      
      return submissions;
    } catch (error) {
      console.error('Error getting user show submissions:', error);
      return [];
    }
  }

  async getConsolidatedShowSubmissions(): Promise<any[]> {
    try {
      // Get consolidated view for admin - group by normalized name and count requests
      const result = await db
        .select({
          normalized_name: showSubmissions.normalizedName,
          show_name: showSubmissions.showName,
          request_count: sql`COUNT(*)::int`,
          first_requested: sql`MIN(${showSubmissions.createdAt})`,
          last_requested: sql`MAX(${showSubmissions.createdAt})`,
          status: showSubmissions.status,
          platforms: sql`ARRAY_AGG(DISTINCT ${showSubmissions.whereTheyWatch})`,
          requested_by_users: sql`ARRAY_AGG(DISTINCT (SELECT username FROM users WHERE id = ${showSubmissions.userId}))`
        })
        .from(showSubmissions)
        .where(eq(showSubmissions.status, 'pending'))
        .groupBy(showSubmissions.normalizedName, showSubmissions.showName, showSubmissions.status)
        .orderBy(sql`COUNT(*) DESC, MIN(${showSubmissions.createdAt}) ASC`);
      
      return result;
    } catch (error) {
      console.error('Error getting consolidated show submissions:', error);
      return [];
    }
  }

  async approveShowSubmission(submissionId: number, adminUserId: string, linkedShowId: number): Promise<any> {
    return await db.transaction(async (tx) => {
      try {
        // Get the submission details
        const [submission] = await tx
          .select()
          .from(showSubmissions)
          .where(eq(showSubmissions.id, submissionId));

        if (!submission) {
          throw new Error('Submission not found');
        }

        // Update submission status
        const [updatedSubmission] = await tx
          .update(showSubmissions)
          .set({
            status: 'approved',
            processedAt: new Date(),
            processedBy: adminUserId,
            linkedShowId: linkedShowId,
          })
          .where(eq(showSubmissions.id, submissionId))
          .returning();

        // Award 20 points to the original submitter
        await this.awardPoints(
          parseInt(submission.userId),
          20,
          'show_submission',
          `Show submission "${submission.showName}" was approved and added to the database`
        );

        return updatedSubmission;
      } catch (error) {
        console.error('Error approving show submission:', error);
        throw error;
      }
    });
  }

  // Get users who submitted a specific show
  async getUsersWhoSubmittedShow(normalizedName: string): Promise<string[]> {
    try {
      const result = await db
        .select({ userId: showSubmissions.userId })
        .from(showSubmissions)
        .where(
          and(
            eq(showSubmissions.normalizedName, normalizedName),
            eq(showSubmissions.status, 'pending')
          )
        );
      
      return result.map(r => r.userId);
    } catch (error) {
      console.error('Error getting users who submitted show:', error);
      return [];
    }
  }

  // Reject show submission
  async rejectShowSubmission(normalizedName: string): Promise<void> {
    try {
      await db
        .update(showSubmissions)
        .set({ 
          status: 'rejected',
          processedAt: new Date()
        })
        .where(
          and(
            eq(showSubmissions.normalizedName, normalizedName),
            eq(showSubmissions.status, 'pending')
          )
        );
    } catch (error) {
      console.error('Error rejecting show submission:', error);
      throw error;
    }
  }

  // Create notification
  async createNotification(data: {
    userId: string;
    type: string;
    message: string;
    isRead: boolean;
    relatedShowName?: string;
  }): Promise<any> {
    try {
      const [notification] = await db
        .insert(notifications)
        .values({
          userId: parseInt(data.userId), // Convert string to integer
          type: data.type,
          message: data.message,
          isRead: data.isRead,
          relatedShowName: data.relatedShowName,
        })
        .returning();
      
      return notification;
    } catch (error) {
      console.error('Error creating notification:', error);
      throw error;
    }
  }

  // Update user password
  async updateUserPassword(userId: string, hashedPassword: string): Promise<boolean> {
    try {
      await db
        .update(users)
        .set({ password: hashedPassword })
        .where(eq(users.id, userId));
      
      console.log(`Password updated successfully for user ${userId}`);
      return true;
    } catch (error) {
      console.error('Error updating user password:', error);
      return false;
    }
  }
}

// Helper function to build a default image URL
function getDefaultImageUrl(title: string | undefined, image_filename: string | undefined): string {
  // Check if image_filename exists and use it
  if (image_filename) {
    return `https://raw.githubusercontent.com/ledhaseeb/tvtantrum/main/client/public/images/${image_filename}`;
  }
  
  // Check if title exists
  if (!title) {
    return `https://raw.githubusercontent.com/ledhaseeb/tvtantrum/main/client/public/images/default.jpg`;
  }
  
  // Format the title for a URL-friendly string
  const formattedTitle = title
    .replace(/[^a-zA-Z0-9]/g, "")  // Remove all non-alphanumeric characters
    .toLowerCase();
  
  return `https://raw.githubusercontent.com/ledhaseeb/tvtantrum/main/client/public/images/${formattedTitle}.jpg`;
}

export const storage = new DatabaseStorage();
</file>

<file path="server/routes.ts">
import express, { Express, Request, Response, NextFunction } from "express";
import { createServer, type Server } from "http";
// Use database storage
import { storage } from "./database-storage";
import { githubService } from "./github";
import { omdbService } from "./omdb";
import { youtubeService, extractYouTubeReleaseYear, getCleanDescription } from "./youtube";
import { searchService } from "./services/searchService";
import { ZodError } from "zod";
import { insertTvShowReviewSchema, insertFavoriteSchema, TvShowGitHub, tempGhlUsers, users, insertTempGhlUserSchema } from "@shared/schema";
import { db } from "./db";
import { eq, desc, sql } from "drizzle-orm";
import fs from 'fs';
import { parse } from 'csv-parse/sync';
import { setupAuth, comparePasswords } from "./auth";
// Use the new consolidated utility files
import * as imageOptimizer from "../image-optimizer.js";
import * as imageManager from "../image-manager.js";
import * as dataManager from "../data-manager.js";
import * as apiDataUpdater from "../api-data-updater.js";
import { upload, optimizeImage, uploadErrorHandler } from "./image-upload";
import { lookupRouter } from "./lookup-api";
import { createShortUrl, resolveShortUrl } from "./url-shortener";
import { trackReferral, trackReferralClick } from "./referral-system";
import path from "path";
import bcrypt from "bcrypt";

export async function registerRoutes(app: Express): Promise<Server> {
  // Basic test endpoint to verify routing works
  app.get('/api/test', (req, res) => {
    console.log('TEST ENDPOINT HIT');
    res.json({ message: 'Server routing is working', timestamp: new Date().toISOString() });
  });

  // Add health check endpoint
  app.get('/api/health', (_req, res) => {
    res.status(200).send('OK');
  });

  // GHL webhook endpoint for form submissions
  app.post('/api/ghl-webhook', async (req: Request, res: Response) => {
    try {
      console.log('=== GHL WEBHOOK RECEIVED ===');
      console.log('Timestamp:', new Date().toISOString());
      console.log('Body:', JSON.stringify(req.body, null, 2));
      console.log('================================');
      
      const { email, first_name } = req.body;
      
      if (!email) {
        console.error('No email in webhook payload');
        return res.status(200).json({ message: 'Email required' });
      }
      
      // Check if user exists
      const existing = await db.execute(
        sql`SELECT id FROM temp_ghl_users WHERE email = ${email} LIMIT 1`
      );
      
      if (existing.rows.length > 0) {
        console.log('User already exists:', email);
        return res.status(200).json({ message: 'User exists' });
      }
      
      // Insert new user
      await db.execute(
        sql`INSERT INTO temp_ghl_users (email, first_name, created_at, updated_at) 
            VALUES (${email}, ${first_name || null}, NOW(), NOW())`
      );
      
      console.log('Successfully inserted user:', email);
      res.status(200).json({ message: 'Success' });
      
    } catch (error: any) {
      console.error('Webhook error:', error);
      res.status(200).json({ message: 'Error', error: error.message });
    }
  });

  // Test endpoint
  app.get('/api/webhook-test', (req: Request, res: Response) => {
    res.json({ 
      message: 'Webhook endpoint reachable',
      timestamp: new Date().toISOString()
    });
  });

  // Set up authentication
  setupAuth(app);
  
  // Auth routes - using original custom authentication system
  app.get('/api/auth/user', (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Not authenticated" });
    }
    res.json(req.user);
  });
  
  // Debug endpoint to check session info
  app.get('/api/auth/session-debug', (req, res) => {
    const sessionInfo = {
      isAuthenticated: req.isAuthenticated(),
      sessionID: req.sessionID || null,
      user: req.user ? {
        id: req.user.id,
        username: req.user.username,
        // Don't include sensitive data like passwords
      } : null,
      session: req.session ? {
        cookie: req.session.cookie,
        userId: req.session.userId,
      } : null
    };
    
    res.json(sessionInfo);
  });
  
  // Check if user is admin
  app.get('/api/user/is-admin', (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Not authenticated" });
    }
    try {
      res.json(req.user!.isAdmin || false);
    } catch (error) {
      console.error("Error checking admin status:", error);
      res.status(500).json({ message: "Failed to check admin status" });
    }
  });
  
  // Add user authentication endpoints
  
  // Get current user - main endpoint the frontend expects
  app.get('/api/user', (req, res) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Not authenticated" });
    }
    res.json(req.user);
  });
  
  // Get user dashboard data
  app.get('/api/user/dashboard', async (req, res) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "Not authenticated" });
      }
      
      const userId = req.user!.id;
      
      // Convert userId to integer for database operations
      const parsedUserId = parseInt(userId);
      
      // Get user data directly from database to ensure we have the correct total_points
      const { pool } = await import('./db');
      const userResult = await pool.query(
        'SELECT * FROM users WHERE id = $1',
        [parsedUserId]
      );
      
      const user = userResult.rows[0];
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      
      // Get user reviews
      let reviews = [];
      try {
        reviews = await storage.getReviewsByUserId(parsedUserId);
      } catch (error) {
        console.error('Error getting user reviews:', error);
      }
      
      // Get user favorites
      let favorites = [];
      try {
        const { getUserFavorites } = await import("./database-favorites");
        favorites = await getUserFavorites(parsedUserId);
      } catch (error) {
        console.error('Error getting user favorites:', error);
      }
      
      // Default point breakdown structure
      const defaultPointsBreakdown = {
        reviews: 0,
        upvotesGiven: 0,
        upvotesReceived: 0,
        consecutiveLogins: 0,
        loginRewards: 0,
        shares: 0,
        referrals: 0,
        showSubmissions: 0,
        researchRead: 0
      };
      
      // Get user's gamification data
      let pointsInfo = { 
        total: 0, 
        breakdown: {
          ...defaultPointsBreakdown
        }, 
        rank: 'TV Watcher' 
      };
      
      try {
        if (typeof storage.getUserPoints === 'function') {
          const dbPoints = await storage.getUserPoints(userId);
          if (dbPoints) {
            pointsInfo = dbPoints;
          }
        }
        
        // Always calculate points based on user activities in case db doesn't have updated information
        // Each review is worth 5 points (this value should match the points in INSERT statements)
        const reviewPoints = reviews.length * 5;
        
        // Update the breakdown
        pointsInfo.breakdown.reviews = reviewPoints;
        
        // Recalculate total points
        pointsInfo.total = reviewPoints + 
                          (pointsInfo.breakdown.upvotesGiven || 0) + 
                          (pointsInfo.breakdown.upvotesReceived || 0) + 
                          (pointsInfo.breakdown.consecutiveLogins || 0) +
                          (pointsInfo.breakdown.loginRewards || 0) +
                          (pointsInfo.breakdown.shares || 0) + 
                          (pointsInfo.breakdown.referrals || 0) +
                          (pointsInfo.breakdown.showSubmissions || 0) + 
                          (pointsInfo.breakdown.researchRead || 0);
        
        // Determine rank based on total points
        if (pointsInfo.total >= 100) pointsInfo.rank = 'TV Enthusiast';
        if (pointsInfo.total >= 500) pointsInfo.rank = 'TV Expert';
        if (pointsInfo.total >= 1000) pointsInfo.rank = 'TV Master';
        
        // Import pool to use for direct queries
        const { pool } = await import('./db');
        
        // Ensure we have review points history records for each review
        try {
          // First clear out any bad "Review of null" entries
          try {
            const parsedUserId = parseInt(userId);
            await pool.query(
              `DELETE FROM user_points_history 
               WHERE user_id = $1 
               AND activity_type = 'review' 
               AND description = 'Review of null'`,
              [parsedUserId]
            );
          } catch (clearError) {
            console.error("Error clearing old null reviews:", clearError);
          }

          // Let's directly create point history records for all reviews
          for (const review of reviews) {
            console.log(`Processing review points for review ID ${review.id}`);
            
            try {
              // Convert userId to integer for database operations
              const parsedUserId = parseInt(userId);
              
              // Get the proper show name from the TV shows table
              let showName = review.tvShowName || review.showName;
              if (!showName && review.tvShowId) {
                try {
                  const showResult = await pool.query(
                    `SELECT name FROM tv_shows WHERE id = $1`,
                    [review.tvShowId]
                  );
                  if (showResult.rows.length > 0) {
                    showName = showResult.rows[0].name;
                  }
                } catch (err) {
                  console.error("Error getting show name for points:", err);
                }
              }
              
              if (!showName) {
                showName = "a TV show";
              }
              
              // First check if we already have a record for this specific review ID
              const existingRecords = await pool.query(
                `SELECT id FROM user_points_history 
                 WHERE user_id = $1 
                 AND activity_type = 'review'
                 AND reference_id = $2`,
                [parsedUserId, review.id]
              );
              
              // Only add if no record exists for this specific review
              if (existingRecords.rowCount === 0) {
                // Add points with the correct show name and reference to the review
                await pool.query(
                  `INSERT INTO user_points_history (user_id, points, activity_type, description, reference_id)
                   VALUES ($1, $2, $3, $4, $5)`,
                  [parsedUserId, 5, 'review', `Review of ${showName}`, review.id]
                );
                
                console.log(`Successfully added points for review of ${showName}`);
              } else {
                // Update the description to make sure it's correct
                await pool.query(
                  `UPDATE user_points_history 
                   SET description = $1 
                   WHERE user_id = $2 AND activity_type = 'review' AND reference_id = $3`,
                  [`Review of ${showName}`, parsedUserId, review.id]
                );
                console.log(`Updated points record for review of ${showName}`);
              }
            } catch (reviewPointsError) {
              console.error(`Error recording points for review ${review.id}:`, reviewPointsError);
            }
          }
          
          // Force recalculation of points from the history records
          const parsedUserId = parseInt(userId);
          
          const pointsRecords = await pool.query(
            `SELECT SUM(points) as total FROM user_points_history WHERE user_id = $1 AND activity_type = 'review'`,
            [parsedUserId]
          );
          
          if (pointsRecords.rows.length > 0) {
            pointsInfo.breakdown.reviews = parseInt(pointsRecords.rows[0].total || '0');
            console.log(`Updated review points from history: ${pointsInfo.breakdown.reviews}`);
            
            // Recalculate total again with the fresh data
            pointsInfo.total = pointsInfo.breakdown.reviews + 
                          (pointsInfo.breakdown.upvotesGiven || 0) + 
                          (pointsInfo.breakdown.upvotesReceived || 0) + 
                          (pointsInfo.breakdown.consecutiveLogins || 0) +
                          (pointsInfo.breakdown.shares || 0) + 
                          (pointsInfo.breakdown.referrals || 0) +
                          (pointsInfo.breakdown.showSubmissions || 0) + 
                          (pointsInfo.breakdown.researchRead || 0);
          }
        } catch (error) {
          console.error('Error recording review points history:', error);
        }
        
        console.log(`Calculated points for user ${userId}: Total=${pointsInfo.total}, Reviews=${reviewPoints}`);
      } catch (error) {
        console.error('Error getting user points:', error);
      }
      
      // Get user points history
      let pointsHistory = [];
      try {
        if (typeof storage.getUserPointsHistory === 'function') {
          pointsHistory = await storage.getUserPointsHistory(userId) || [];
        }
      } catch (error) {
        console.error('Error getting user points history:', error);
      }
      
      // Get similar shows with metadata (reviews, favorites) in a single query
      let recommendedShows = [];
      try {
        if (typeof storage.getSimilarShowsWithMetadata === 'function') {
          recommendedShows = await storage.getSimilarShowsWithMetadata(userId, 5) || [];
        } else {
          recommendedShows = await storage.getSimilarShows(userId, 5) || [];
        }
      } catch (error) {
        console.error('Error getting recommended shows:', error);
      }
      
      // Get user login streak
      let loginStreak = { currentStreak: 0, weeklyStreak: 0, monthlyStreak: 0 };
      try {
        if (typeof storage.getUserLoginStreak === 'function') {
          loginStreak = await storage.getUserLoginStreak(userId) || loginStreak;
        }
      } catch (error) {
        console.error('Error getting user login streak:', error);
      }

      // Get leaderboard data (top 10 users)
      let topUsers = [];
      try {
        if (typeof storage.getTopUsers === 'function') {
          topUsers = await storage.getTopUsers(10) || [];
        }
      } catch (error) {
        console.error('Error getting top users:', error);
      }
      
      // Get read research summaries
      let readResearch = [];
      try {
        // Use direct database query for read research
        const readResult = await pool.query(
          `SELECT r.*, urr.read_at 
           FROM user_read_research urr
           JOIN research_summaries r ON urr.research_id = r.id
           WHERE urr.user_id = $1
           ORDER BY urr.read_at DESC`,
          [parsedUserId]
        );
        readResearch = readResult.rows || [];
      } catch (error) {
        console.error('Error getting read research:', error);
      }
      
      // Get show submissions - empty placeholder for now
      let submissions = [];
      
      // Get most recent activity from points history for the activity feed
      let recentActivity = [];
      try {
        // Get the 10 most recent activities from points history
        recentActivity = pointsHistory.slice(0, 10);
      } catch (error) {
        console.error('Error getting recent activity:', error);
      }
      
      // Compile dashboard data
      const dashboardData = {
        user,
        points: user.total_points || 0, // Use the database total_points directly
        pointsBreakdown: pointsInfo.breakdown || defaultPointsBreakdown,
        rank: user.rank || "TV Watcher",
        reviews,
        favorites,
        pointsHistory,
        readResearch,
        submissions,
        recommendedShows,
        streak: loginStreak?.currentStreak || 0,
        weeklyStreak: loginStreak?.weeklyStreak || 0,
        monthlyStreak: loginStreak?.monthlyStreak || 0,
        leaderboard: topUsers,
        recentActivity  // Add the recent activity to the dashboard data
      };
      
      res.json(dashboardData);
    } catch (error) {
      console.error("Error fetching user dashboard:", error);
      res.status(500).json({ message: "Failed to fetch user dashboard" });
    }
  });
  
  // Serve static files from the public directory
  app.use('/uploads', express.static(path.join(process.cwd(), 'public/uploads')));
  
  // Register the lookup API router
  app.use('/api/lookup-show', lookupRouter);
  
  // Skip GitHub data import on server start to fix database errors
  console.log("Skipping GitHub data import on startup to prevent database errors");
  
  // Skip custom data loading on startup for better performance
  // Custom data is now applied directly to the database using the apply-custom-data.js script
  console.log("Startup optimization: Custom data loading skipped for faster server startup.");
  console.log("To apply custom data to the database, run: node apply-custom-data.js");
  
  // Helper function to clean up YouTube description text
  const getCleanYouTubeDescription = (description: string): string => {
    if (!description) return '';
    
    // Strip out common YouTube description elements
    return description
      .replace(/Follow us on social media:[\s\S]*?(?=\n\n|$)/, '')
      .replace(/Subscribe to our channel:[\s\S]*?(?=\n\n|$)/, '')
      .replace(/Visit our website:[\s\S]*?(?=\n\n|$)/, '')
      .replace(/\bhttps?:\/\/\S+\b/g, '')  // Remove URLs
      .replace(/\n{3,}/g, '\n\n')          // Normalize line breaks
      .replace(/\s{2,}/g, ' ')             // Normalize spaces
      .trim();
  };
  
  // Extract year information and creator functions
  function extractYearInfo(yearStr: string) {
    if (!yearStr) return { releaseYear: null, endYear: null, isOngoing: null };
    
    const parts = yearStr.split('–');
    const releaseYear = parts[0] ? parseInt(parts[0]) : null;
    const endYear = parts[1] && parts[1].trim() !== '' ? parseInt(parts[1]) : null;
    const isOngoing = parts.length > 1 && (parts[1].trim() === '' || !parts[1]);
    
    return { releaseYear, endYear, isOngoing };
  }
  
  // Extract creator info from director and writer fields
  function extractCreator(director: string, writer: string) {
    if (director && director !== 'N/A') return director;
    if (writer && writer !== 'N/A') return writer;
    return null;
  }

  // Get all TV shows - using dedicated search service for reliability
  app.get("/api/tv-shows", async (req: Request, res: Response) => {
    try {
      // For search queries, use the dedicated search service
      if (req.query.search && typeof req.query.search === 'string' && req.query.search.trim()) {
        const searchTerm = req.query.search.trim();
        console.log(`Search service search for: "${searchTerm}"`);
        
        // Use our dedicated search service
        const results = await searchService.searchShows(searchTerm);
        
        // Track search in the background if we have results
        if (results.length > 0) {
          const showId = results[0].id;
          searchService.trackSearchHit(showId);
        }
        
        return res.json(results);
      }
      
      // For the admin page, get all shows without filtering
      if (Object.keys(req.query).length === 0) {
        console.log("Admin dashboard: Getting all TV shows without filters");
        const allShows = await storage.getAllTvShows();
        return res.json(allShows);
      }
      
      // For any other filter combinations, use the search service
      console.log("Filter query detected:", req.query);
      
      // Convert query params to the correct format for the search service
      const filters: any = {};
      
      // Copy over direct string filters
      if (req.query.ageGroup) filters.ageGroup = req.query.ageGroup;
      if (req.query.tantrumFactor) filters.tantrumFactor = req.query.tantrumFactor;
      if (req.query.interactionLevel) filters.interactionLevel = req.query.interactionLevel;
      if (req.query.dialogueIntensity) filters.dialogueIntensity = req.query.dialogueIntensity;
      if (req.query.soundFrequency) filters.soundFrequency = req.query.soundFrequency;
      if (req.query.sortBy) filters.sortBy = req.query.sortBy;
      if (req.query.themeMatchMode) filters.themeMatchMode = req.query.themeMatchMode;
      if (req.query.search) filters.search = req.query.search;
      
      // Handle themes special case - convert from string or array
      if (req.query.themes) {
        filters.themes = typeof req.query.themes === 'string'
          ? req.query.themes.split(',').map((theme: string) => theme.trim())
          : (req.query.themes as string[]).map((theme: string) => theme.trim());
      }
      
      // Handle stimulation score range filter
      if (req.query.stimulationScoreRange) {
        try {
          filters.stimulationScoreRange = typeof req.query.stimulationScoreRange === 'string'
            ? JSON.parse(req.query.stimulationScoreRange as string)
            : req.query.stimulationScoreRange;
        } catch (error) {
          console.error('Error parsing stimulationScoreRange:', error);
        }
      }
      
      // Handle age range filter
      if (req.query.ageRange) {
        try {
          const ageRange = typeof req.query.ageRange === 'string'
            ? JSON.parse(req.query.ageRange as string)
            : req.query.ageRange;
          
          if (ageRange && typeof ageRange === 'object' && 'min' in ageRange && 'max' in ageRange) {
            filters.ageRangeMin = ageRange.min;
            filters.ageRangeMax = ageRange.max;
          }
        } catch (error) {
          console.error('Error parsing ageRange:', error);
        }
      }
      
      // Handle individual age range parameters (fallback)
      if (req.query.ageRangeMin && req.query.ageRangeMax) {
        filters.ageRangeMin = parseInt(req.query.ageRangeMin as string);
        filters.ageRangeMax = parseInt(req.query.ageRangeMax as string);
      }
      
      // Use the search service for filtered search
      const shows = await searchService.searchWithFilters(filters);
      return res.json(shows);
    } catch (error) {
      console.error("Error in TV shows API:", error);
      res.status(500).json({ message: "Failed to fetch TV shows" });
    }
  });

  // Get popular TV shows
  app.get("/api/shows/popular", async (req: Request, res: Response) => {
    try {
      const limitStr = req.query.limit;
      const limit = limitStr && typeof limitStr === 'string' ? parseInt(limitStr) : 10;
      
      const shows = await storage.getPopularShows(limit);
      res.json(shows);
    } catch (error) {
      console.error("Error fetching popular TV shows:", error);
      res.status(500).json({ message: "Failed to fetch popular TV shows" });
    }
  });

  // Get the featured show
  app.get("/api/shows/featured", async (req: Request, res: Response) => {
    try {
      const shows = await storage.getTvShowsByFilter({});
      // Find the show that has isFeatured set to true
      const featuredShow = shows.find(show => show.isFeatured);
      
      if (featuredShow) {
        res.json(featuredShow);
      } else {
        res.status(404).json({ message: "No featured show found" });
      }
    } catch (error) {
      console.error("Error fetching featured show:", error);
      res.status(500).json({ message: "Failed to fetch featured show" });
    }
  });

  app.get("/api/shows/highly-rated", async (req: Request, res: Response) => {
    try {
      const limit = parseInt(req.query.limit as string) || 24;
      const highlyRatedShows = await storage.getHighlyRatedShows(limit);
      res.json(highlyRatedShows);
    } catch (error) {
      console.error('Error fetching highly rated shows:', error);
      res.status(500).json({ 
        message: "Error retrieving highly rated shows", 
        error: error instanceof Error ? error.message : "Unknown error" 
      });
    }
  });

  // These functions have already been defined above, so we don't need to redefine them.

// Get single TV show by ID
  app.get("/api/shows/:id", async (req: Request, res: Response) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid show ID" });
      }
      
      const show = await storage.getTvShowById(id);
      if (!show) {
        return res.status(404).json({ message: "TV show not found" });
      }
      
      // Get reviews for this show
      const reviews = await storage.getReviewsByTvShowId(id);
      console.log(`Found ${reviews?.length || 0} reviews for show ID ${id}`);
      
      // Track this view
      await storage.trackShowView(id);
      
      // Enhance reviews with upvote information
      const enhancedReviews = await Promise.all(reviews.map(async (review) => {
        // Get upvotes for this review
        const upvotes = await storage.getReviewUpvotes(review.id);
        
        // Check if the current user has upvoted this review
        let userHasUpvoted = false;
        if (req.isAuthenticated() && req.user) {
          // Parse user ID to integer since database expects integer
          const parsedUserId = parseInt(req.user.id);
          userHasUpvoted = await storage.hasUserUpvotedReview(parsedUserId, review.id);
        }
        
        return {
          ...review,
          upvoteCount: upvotes.length,
          userHasUpvoted
        };
      }));
      
      // Attach enhanced reviews to the show object
      show.reviews = enhancedReviews;
      
      // Check if this is a YouTube show
      const isYouTubeShow = show.availableOn?.includes('YouTube');
      
      let externalData = {
        omdb: null,
        youtube: null
      };
      
      try {
        // For all shows, try to get OMDb data
        const omdbData = await omdbService.getShowData(show.name);
        console.log(`OMDb data for ${show.name}:`, omdbData ? 'Found' : 'Not found');
        
        if (omdbData) {
          // If this is the first time we get OMDb data for this show, update the metadata
          if (!show.creator || !show.releaseYear || show.description === 'A children\'s TV show') {
            // Extract year information
            const { releaseYear, endYear, isOngoing } = extractYearInfo(omdbData.year);
            
            // Extract creator information
            const creator = extractCreator(omdbData.director, omdbData.writer);
            
            // Update show with this additional metadata if it's not already set
            const updateData: any = {};
            
            if (!show.creator && creator) {
              updateData.creator = creator;
            }
            
            if (!show.releaseYear && releaseYear) {
              updateData.releaseYear = releaseYear;
            }
            
            if (!show.endYear && endYear) {
              updateData.endYear = endYear;
            }
            
            // Only update isOngoing if we have valid year data
            if (releaseYear && !show.isOngoing) {
              updateData.isOngoing = isOngoing;
            }
            
            // If we have a plot and the current description is generic, update it
            if (omdbData.plot && omdbData.plot !== 'N/A' && 
                (show.description === 'A children\'s TV show' || !show.description)) {
              updateData.description = omdbData.plot;
            }
            
            // Only update if we have new data
            if (Object.keys(updateData).length > 0) {
              console.log(`Updating metadata for "${show.name}" with OMDb data:`, updateData);
              await storage.updateTvShow(id, updateData);
            }
          }
          
          // Only include OMDb data in the response if it has valid values (not empty or 'N/A')
          if (omdbData) {
            // Filter out any empty values or "N/A" values
            const filteredOmdbData: any = {};
            let hasValidData = false;
            
            for (const [key, value] of Object.entries(omdbData)) {
              if (value && value !== 'N/A' && value !== '') {
                filteredOmdbData[key] = value;
                hasValidData = true;
              }
            }
            
            // Only include the data if there's at least one valid field
            if (hasValidData) {
              externalData.omdb = filteredOmdbData;
            }
          }
        }
        
        // If this is a YouTube show, also get YouTube data
        if (isYouTubeShow) {
          // For YouTube shows, use YouTube API
          const youtubeData = await youtubeService.getChannelData(show.name);
          console.log(`YouTube data for ${show.name}:`, youtubeData ? 'Found' : 'Not found');
          
          if (youtubeData) {
            // Extract release year from publishedAt date
            const releaseYear = extractYouTubeReleaseYear(youtubeData.publishedAt);
            
            // Set creator to channel name if no better info
            const creator = youtubeData.title;
            
            // Update data object for database changes
            const updateData: any = {};
            
            // Update metadata if not already set
            if (!show.creator && creator) {
              updateData.creator = creator;
            }
            
            if (!show.releaseYear && releaseYear) {
              updateData.releaseYear = releaseYear;
            }
            
            // YouTube shows are typically ongoing
            if (typeof show.isOngoing !== 'boolean') {
              updateData.isOngoing = true;
            }
            
            // Get a cleaned description from YouTube
            const cleanDescription = getCleanDescription(youtubeData.description);
            
            // Update description if generic or missing
            if (cleanDescription && (show.description === 'A children\'s TV show' || !show.description)) {
              updateData.description = cleanDescription;
            }
            
            // If show has no image, use YouTube thumbnail
            if (!show.imageUrl && youtubeData.thumbnailUrl) {
              updateData.imageUrl = youtubeData.thumbnailUrl;
            }
            
            // Add YouTube-specific data
            updateData.subscriberCount = youtubeData.subscriberCount;
            updateData.videoCount = youtubeData.videoCount;
            updateData.channelId = youtubeData.channelId;
            updateData.isYouTubeChannel = true;
            updateData.publishedAt = youtubeData.publishedAt;
            
            // Only update if we have new data
            if (Object.keys(updateData).length > 0) {
              console.log(`Updating metadata for "${show.name}" with YouTube data:`, updateData);
              await storage.updateTvShow(id, updateData);
            }
          }
          
          // Only include YouTube data in the response if it has valid values
          if (youtubeData) {
            // Filter out any empty or null values
            const filteredYouTubeData: any = {};
            let hasValidData = false;
            
            for (const [key, value] of Object.entries(youtubeData)) {
              if (value && value !== '') {
                filteredYouTubeData[key] = value;
                hasValidData = true;
              }
            }
            
            // Only include the data if there's at least one valid field
            if (hasValidData) {
              externalData.youtube = filteredYouTubeData;
            }
          }
        }
      } catch (error) {
        console.error(`Error fetching external data for ${show.name}:`, error);
        // Continue even if data fetch fails
      }
      
      // Create a complete response that includes both stored and external data
      const response = {
        ...show,
        reviews,
        externalData
      };
      
      // Make sure the YouTube data from the database is directly accessible
      // by exposing it at the top level of the response
      if (show.isYouTubeChannel || show.subscriberCount || show.videoCount) {
        console.log(`Show ${show.name} has YouTube channel data`);
        
        // Make sure the YouTube specific fields are directly available in the response
        response.isYouTubeChannel = true;
        response.subscriberCount = show.subscriberCount;
        response.videoCount = show.videoCount;
        response.publishedAt = show.publishedAt;
        response.channelId = show.channelId;
      }
      
      res.json(response);
    } catch (error) {
      console.error("Error fetching TV show:", error);
      res.status(500).json({ message: "Failed to fetch TV show" });
    }
  });

  // Get reviews for a specific TV show by ID
  app.get("/api/reviews/:id", async (req: Request, res: Response) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid show ID" });
      }
      
      const reviews = await storage.getReviewsByTvShowId(id);
      res.json(reviews);
    } catch (error) {
      console.error("Error fetching reviews:", error);
      res.status(500).json({ message: "Failed to fetch reviews" });
    }
  });

  // Add a new review for a TV show
  app.post("/api/shows/:id/reviews", async (req: Request, res: Response) => {
    try {
      // Check if user is authenticated
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "You must be logged in to submit reviews" });
      }
      
      // Convert user ID to a number if it's a string
      const userId = typeof req.user!.id === 'string' ? parseInt(req.user!.id) : req.user!.id;
      const userName = req.user!.username || "Anonymous";
      
      console.log("Submitting review as user:", userId, userName, "User ID type:", typeof userId);
      
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid show ID" });
      }
      
      const show = await storage.getTvShowById(id);
      if (!show) {
        return res.status(404).json({ message: "TV show not found" });
      }
      
      // Make sure we always have the show name
      console.log("Review data:", {
        ...req.body,
        userId,
        userName,
        showName: show.name
      });
      
      // Validate and prepare review data
      const reviewData = {
        ...req.body,
        tvShowId: id,
        userId: userId,
        userName: userName,
        showName: show.name
      };
      
      // Double-check that show name is set
      if (!reviewData.showName && show && show.name) {
        reviewData.showName = show.name;
        console.log("Fixed missing show name:", show.name);
      }
      
      // Add review to storage
      const newReview = await storage.addReview(reviewData);
      console.log("New review created:", newReview);
      
      res.status(201).json(newReview);
    } catch (error) {
      if (error instanceof ZodError) {
        return res.status(400).json({ 
          message: "Invalid review data", 
          errors: error.errors 
        });
      }
      
      console.error("Error adding TV show review:", error);
      res.status(500).json({ message: "Failed to add TV show review" });
    }
  });

  // Manually refresh data from GitHub
  app.post("/api/refresh-data", async (req: Request, res: Response) => {
    try {
      const showsData = await githubService.fetchTvShowsData();
      const importedShows = await storage.importShowsFromGitHub(showsData);
      
      res.json({ 
        message: "Data refreshed successfully", 
        count: importedShows.length 
      });
    } catch (error) {
      console.error("Error refreshing data:", error);
      res.status(500).json({ message: "Failed to refresh data" });
    }
  });
  
  // Endpoint to optimize show images using OMDB posters
  app.post("/api/optimize-images", async (req: Request, res: Response) => {
    try {
      // Temporarily removed admin check to run optimization directly
      // if (!req.user?.isAdmin) {
      //   return res.status(403).json({ message: "Unauthorized. Admin privileges required." });
      // }
      
      console.log("Starting image optimization process...");
      // Use our consolidated image optimizer utility instead
      const shows = await storage.getAllTvShows();
      const results = {
        total: shows.length,
        successful: [],
        failed: []
      };
      
      for (const show of shows) {
        try {
          if (show.imageUrl) {
            const localImagePath = await imageOptimizer.getImage(show.imageUrl, show.id);
            if (localImagePath) {
              const optimizedUrl = await imageOptimizer.optimizeImage(localImagePath, show.id);
              if (optimizedUrl) {
                await imageOptimizer.updateShowImage(show.id, optimizedUrl);
                results.successful.push(show.id);
              } else {
                results.failed.push(show.id);
              }
            }
          }
        } catch (error) {
          console.error(`Error optimizing image for show ${show.id}:`, error);
          results.failed.push(show.id);
        }
      }
      
      res.json({
        message: `Processed ${results.total} shows. Updated ${results.successful.length} images successfully.`,
        successful: results.successful.length,
        failed: results.failed.length,
        results
      });
    } catch (error) {
      console.error("Error optimizing images:", error);
      res.status(500).json({ message: "Failed to optimize images" });
    }
  });
  
  // Endpoint to update YouTube metadata for shows marked as available on YouTube
  app.post("/api/update-youtube-metadata", async (req: Request, res: Response) => {
    try {
      // Check if user is admin
      if (!req.user?.isAdmin) {
        return res.status(403).json({ message: "Unauthorized. Admin privileges required." });
      }
      
      console.log("Starting YouTube metadata update process...");
      
      // Get limit parameter with a default of 10 shows
      const limit = req.body.limit || 10;
      
      // Get all shows marked as available on YouTube
      const youtubeShows = await storage.getTvShowsByPlatform('YouTube', limit);
      
      console.log(`Processing ${youtubeShows.length} YouTube shows`);
      
      // Track results
      const results = {
        total: youtubeShows.length,
        successful: [] as any[],
        failed: [] as any[],
        skipped: [] as any[]
      };
      
      // Process each YouTube show
      for (const show of youtubeShows) {
        try {
          // Skip shows that already have YouTube data
          if (show.isYouTubeChannel && show.channelId) {
            results.skipped.push({
              id: show.id,
              name: show.name,
              reason: 'Already has YouTube metadata'
            });
            continue;
          }
          
          console.log(`Processing YouTube show: ${show.name}`);
          
          // Fetch YouTube data
          const youtubeData = await youtubeService.getChannelData(show.name);
          
          if (!youtubeData) {
            results.failed.push({
              id: show.id,
              name: show.name,
              reason: 'No YouTube data found'
            });
            continue;
          }
          
          // Build update data
          const updateData: any = {
            subscriberCount: youtubeData.subscriberCount,
            videoCount: youtubeData.videoCount,
            channelId: youtubeData.channelId,
            isYouTubeChannel: true,
            publishedAt: youtubeData.publishedAt
          };
          
          // Extract release year from publishedAt date
          const releaseYear = extractYouTubeReleaseYear(youtubeData.publishedAt);
          
          // Add creator if missing
          if (!show.creator) {
            updateData.creator = youtubeData.title;
          }
          
          // Add release year if missing
          if (!show.releaseYear && releaseYear) {
            updateData.releaseYear = releaseYear;
          }
          
          // YouTube shows are typically ongoing
          if (typeof show.isOngoing !== 'boolean') {
            updateData.isOngoing = true;
          }
          
          // Get a cleaned description
          const cleanDescription = getCleanDescription(youtubeData.description);
          
          // Update description if generic or missing
          if (cleanDescription && (show.description === 'A children\'s TV show' || !show.description)) {
            updateData.description = cleanDescription;
          }
          
          // If show has no image, use YouTube thumbnail
          if (!show.imageUrl && youtubeData.thumbnailUrl) {
            updateData.imageUrl = youtubeData.thumbnailUrl;
          }
          
          // Update the show in the database
          const updatedShow = await storage.updateTvShow(show.id, updateData);
          
          if (updatedShow) {
            results.successful.push({
              id: show.id,
              name: show.name,
              updates: updateData
            });
          } else {
            results.failed.push({
              id: show.id,
              name: show.name,
              reason: 'Failed to update in database'
            });
          }
          
          // Add a small delay to avoid rate limiting
          await new Promise(resolve => setTimeout(resolve, 250));
        } catch (error) {
          console.error(`Error processing YouTube show ${show.name}:`, error);
          results.failed.push({
            id: show.id,
            name: show.name,
            reason: 'Processing error'
          });
        }
      }
      
      res.json({
        message: `Processed ${results.total} YouTube shows. Updated ${results.successful.length} successfully.`,
        ...results
      });
    } catch (error) {
      console.error("Error updating YouTube metadata:", error);
      res.status(500).json({ message: "Failed to update YouTube metadata" });
    }
  });
  
  // Endpoint to update show metadata (creator, release_year, end_year, is_ongoing) from OMDb
  app.post("/api/update-metadata", async (req: Request, res: Response) => {
    try {
      // Check if user is admin
      if (!req.user?.isAdmin) {
        return res.status(403).json({ message: "Unauthorized. Admin privileges required." });
      }
      
      console.log("Starting metadata update process...");
      
      // Get all shows from the database
      const shows = await storage.getAllTvShows();
      
      // Keep track of results
      const results = {
        total: shows.length,
        successful: [] as any[],
        failed: [] as any[],
        skipped: [] as any[]
      };
      
      // Process each show
      for (const show of shows) {
        try {
          // Check if this is a YouTube show
          const isYouTubeShow = show.availableOn?.includes('YouTube');
          
          // Skip shows that already have complete metadata
          if (show.creator && show.releaseYear && (show.endYear || show.isOngoing) &&
              show.description !== 'A children\'s TV show' && show.description) {
            results.skipped.push({
              id: show.id,
              name: show.name,
              reason: 'Already has complete metadata'
            });
            continue;
          }
          
          // Update data object for database changes
          const updateData: any = {};
          
          if (isYouTubeShow) {
            // For YouTube shows, try to get data from YouTube API
            console.log(`Processing YouTube show: ${show.name}`);
            
            // Extract the channel name - usually it's just the show name
            const channelName = show.name;
            
            // Fetch YouTube data
            const youtubeData = await youtubeService.getChannelData(channelName);
            
            if (!youtubeData) {
              results.failed.push({
                id: show.id,
                name: show.name,
                reason: 'No YouTube data found'
              });
              continue;
            }
            
            // Extract release year from publishedAt date
            const releaseYear = extractYouTubeReleaseYear(youtubeData.publishedAt);
            
            // Set creator to channel name if no better info
            const creator = youtubeData.title;
            
            // Update metadata if not already set
            if (!show.creator && creator) {
              updateData.creator = creator;
            }
            
            if (!show.releaseYear && releaseYear) {
              updateData.releaseYear = releaseYear;
            }
            
            // YouTube shows are typically ongoing
            if (typeof show.isOngoing !== 'boolean') {
              updateData.isOngoing = true;
            }
            
            // Get a cleaned description from YouTube
            const cleanDescription = getCleanDescription(youtubeData.description);
            
            // Update description if generic or missing
            if (cleanDescription && (show.description === 'A children\'s TV show' || !show.description)) {
              updateData.description = cleanDescription;
            }
            
            // If show has no image, use YouTube thumbnail
            if (!show.imageUrl && youtubeData.thumbnailUrl) {
              updateData.imageUrl = youtubeData.thumbnailUrl;
            }
            
            // Add YouTube-specific data
            updateData.subscriberCount = youtubeData.subscriberCount;
            updateData.videoCount = youtubeData.videoCount;
            updateData.channelId = youtubeData.channelId;
            updateData.isYouTubeChannel = true;
            updateData.publishedAt = youtubeData.publishedAt;
          } else {
            // For regular TV shows, use OMDb
            const omdbData = await omdbService.getShowData(show.name);
            if (!omdbData) {
              results.failed.push({
                id: show.id,
                name: show.name,
                reason: 'No OMDb data found'
              });
              continue;
            }
            
            // Extract year information
            const { releaseYear, endYear, isOngoing } = extractYearInfo(omdbData.year);
            
            // Extract creator information
            const creator = extractCreator(omdbData.director, omdbData.writer);
            
            // Update metadata if not already set
            if (!show.creator && creator) {
              updateData.creator = creator;
            }
            
            if (!show.releaseYear && releaseYear) {
              updateData.releaseYear = releaseYear;
            }
            
            if (!show.endYear && endYear) {
              updateData.endYear = endYear;
            }
            
            // Only update isOngoing if we have valid year data
            if (releaseYear && typeof show.isOngoing !== 'boolean') {
              updateData.isOngoing = isOngoing;
            }
            
            // If we have a plot and the current description is generic, update it
            if (omdbData.plot && omdbData.plot !== 'N/A' && 
                (show.description === 'A children\'s TV show' || !show.description)) {
              updateData.description = omdbData.plot;
            }
          }
          
          // Only update if we have new data
          if (Object.keys(updateData).length > 0) {
            const dataSource = isYouTubeShow ? 'YouTube' : 'OMDb';
            console.log(`Updating metadata for "${show.name}" with ${dataSource} data:`, updateData);
            
            const updatedShow = await storage.updateTvShow(show.id, updateData);
            
            if (updatedShow) {
              results.successful.push({
                id: show.id,
                name: show.name,
                source: dataSource,
                updates: updateData
              });
            } else {
              results.failed.push({
                id: show.id,
                name: show.name,
                reason: `Failed to update in storage after ${dataSource} lookup`
              });
            }
          } else {
            results.skipped.push({
              id: show.id,
              name: show.name,
              reason: 'No new metadata to update'
            });
          }
          
          // Add a small delay to avoid rate limiting
          await new Promise(resolve => setTimeout(resolve, 250));
          
        } catch (error) {
          console.error(`Error updating metadata for show "${show.name}":`, error);
          results.failed.push({
            id: show.id,
            name: show.name,
            reason: 'Error during processing'
          });
        }
      }
      
      res.json({
        message: `Processed ${results.total} shows. Updated ${results.successful.length} successfully.`,
        successful: results.successful.length,
        failed: results.failed.length,
        skipped: results.skipped.length,
        results
      });
    } catch (error) {
      console.error("Error updating metadata:", error);
      res.status(500).json({ message: "Failed to update metadata" });
    }
  });

  // Endpoint to update a specific show with OMDB image
  app.post("/api/shows/:id/update-image", async (req: Request, res: Response) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid show ID" });
      }
      
      const show = await storage.getTvShowById(id);
      if (!show) {
        return res.status(404).json({ message: "TV show not found" });
      }
      
      // Check if this show has a custom image from customImageMap.json 
      const customImageMap = imageManager.loadCustomImageMap();
      const customImageUrl = customImageMap[id];
      
      // If the show already has a custom image or the current image is in the custom-images folder, don't overwrite it
      if (customImageUrl || 
          (show.imageUrl && (
            show.imageUrl.includes('/custom-images/') || 
            show.imageUrl.includes('client/public/custom-images/')
          ))
      ) {
        console.log(`Preserving custom image for "${show.name}"`);
        return res.json({
          success: true,
          message: `Kept existing custom image for "${show.name}"`,
          show: show
        });
      }
      
      console.log(`Looking up OMDB poster for "${show.name}"`);
      const omdbData = await omdbService.getShowData(show.name);
      
      if (omdbData && omdbData.poster && omdbData.poster !== 'N/A') {
        console.log(`Found OMDB poster for "${show.name}": ${omdbData.poster}`);
        
        // Since this is not a custom image, we'll use OMDB's poster but won't add it to customImageMap.json
        // This way it can be easily replaced by a custom image later
        const updatedShow = await storage.updateTvShow(id, {
          imageUrl: omdbData.poster
        });
        
        if (updatedShow) {
          res.json({
            success: true,
            message: `Updated "${show.name}" with OMDB poster`,
            show: updatedShow
          });
        } else {
          res.status(500).json({
            success: false,
            message: "Failed to update show in storage"
          });
        }
      } else {
        res.status(404).json({
          success: false,
          message: "No OMDB poster found for this show"
        });
      }
    } catch (error) {
      console.error("Error updating show image:", error);
      res.status(500).json({ 
        success: false,
        message: "Failed to update show image",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });
  
  // Endpoint to update a show with a local image file
  app.post("/api/shows/:id/update-with-local-image", async (req: Request, res: Response) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid show ID" });
      }
      
      const { imageUrl } = req.body;
      if (!imageUrl) {
        return res.status(400).json({ message: "Image URL is required" });
      }
      
      const show = await storage.getTvShowById(id);
      if (!show) {
        return res.status(404).json({ message: "TV show not found" });
      }
      
      // Save to our custom image map and update the show
      imageManager.updateCustomImageMap(id, imageUrl);
      
      // Update the show with the local image URL
      const updatedShow = await storage.updateTvShow(id, { imageUrl });
      
      if (updatedShow) {
        res.json({
          success: true,
          message: `Updated "${show.name}" with local image`,
          show: updatedShow
        });
      } else {
        res.status(500).json({
          success: false,
          message: "Failed to update show in storage"
        });
      }
    } catch (error) {
      console.error("Error updating show with local image:", error);
      res.status(500).json({ 
        success: false,
        message: "Failed to update show with local image",
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Import data from CSV file
  app.post("/api/import-csv", async (req: Request, res: Response) => {
    try {
      // Check if CSV file exists
      const csvFilePath = 'tvshow_sensory_data.csv';
      if (!fs.existsSync(csvFilePath)) {
        return res.status(404).json({ message: "CSV file not found" });
      }

      // Read and parse CSV file
      const fileContent = fs.readFileSync(csvFilePath, 'utf8');
      const records = parse(fileContent, {
        columns: true,
        skip_empty_lines: true
      });

      console.log(`Parsed ${records.length} records from CSV`);
      
      // Transform CSV data to GitHub format
      const transformedShows: TvShowGitHub[] = records.map((record: any, index: number) => {
        // Split the themes into an array and trim each value
        const themes = record['Themes, Teachings, Guidance'] 
          ? record['Themes, Teachings, Guidance'].split(',').map((t: string) => t.trim())
          : [];

        // Convert string numbers to actual numbers
        const stimulationScore = parseInt(record['Stimulation Score']) || 3;
        
        // Debug the CSV data for Arthur
        if (record['Programs'] === 'Arthur') {
          console.log('Arthur data in CSV:', {
            title: record['Programs'],
            sound_effects: record['Sound Effects'],
            dialogue: record['Dialougue Intensity']
          });
        }

        return {
          title: record['Programs'] || `Show ${index + 1}`,
          stimulation_score: stimulationScore,
          platform: record['TV or YouTube'] || 'TV',
          target_age_group: record['Target Age Group'] || '4-8',
          seasons: record['Seasons'] || null,
          avg_episode_length: record['Avg. Epsiode'] || null,
          themes: themes,
          interactivity_level: record['Interactivity Level'] || 'Moderate',
          animation_style: record['Animation Styles'] || 'Traditional 2D',
          dialogue_intensity: record['Dialougue Intensity'] || 'Moderate',
          sound_effects_level: record['Sound Effects'] || 'Moderate',
          music_tempo: record['Music Tempo'] || 'Moderate',
          total_music_level: record['Total Music'] || 'Moderate',
          total_sound_effect_time_level: record['Total Sound Effect Time'] || 'Moderate',
          scene_frequency: record['Scene Frequency'] || 'Moderate',
          image_filename: `${record['Programs']?.toLowerCase().replace(/[^a-z0-9]/g, '')}.jpg` || 'default.jpg',
          id: index + 1,
          // Add image URL based on the show title for GitHub repo format
          imageUrl: `https://raw.githubusercontent.com/ledhaseeb/tvtantrum/main/client/public/images/${record['Programs']?.toLowerCase().replace(/[^a-z0-9]/g, '')}.jpg`
        };
      });

      // Import processed data to storage
      const importedShows = await storage.importShowsFromGitHub(transformedShows);
      console.log(`Imported ${importedShows.length} TV shows from CSV`);
      
      res.json({ 
        message: "CSV data imported successfully", 
        count: importedShows.length 
      });
    } catch (error) {
      console.error('Error importing CSV data:', error);
      res.status(500).json({ 
        message: "Failed to import CSV data", 
        error: error instanceof Error ? error.message : 'Unknown error' 
      });
    }
  });

  // Add favorite routes, protected by authentication
  // Add a show to user's favorites
  app.post("/api/favorites", async (req: Request, res: Response) => {
    // Debug authentication state
    console.log('Favorites POST - Auth state:', {
      isAuthenticated: req.isAuthenticated(),
      hasUser: !!req.user,
      userId: req.user?.id,
      sessionId: req.sessionID
    });
    
    // Check if user is authenticated - more robust check
    if (!req.isAuthenticated() || !req.user) {
      console.log('Favorites POST - Authentication failed');
      return res.status(401).json({ message: "You must be logged in to use favorites" });
    }

    try {
      const { tvShowId } = req.body;
      if (!tvShowId || isNaN(parseInt(tvShowId))) {
        return res.status(400).json({ message: "Invalid show ID" });
      }

      // Import favorites functions
      const { addFavorite } = await import("./database-favorites");
      
      const userId = req.user!.id;
      const favorite = await addFavorite(userId, parseInt(tvShowId));
      
      res.status(201).json(favorite);
    } catch (error) {
      console.error("Error adding favorite:", error);
      res.status(500).json({ message: "Failed to add favorite" });
    }
  });

  // Remove a show from user's favorites
  app.delete("/api/favorites/:tvShowId", async (req: Request, res: Response) => {
    // Check if user is authenticated
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "You must be logged in to use favorites" });
    }

    try {
      const tvShowId = parseInt(req.params.tvShowId);
      if (isNaN(tvShowId)) {
        return res.status(400).json({ message: "Invalid show ID" });
      }

      // Import favorites functions
      const { removeFavorite } = await import("./database-favorites");
      
      const userId = req.user!.id;
      const result = await removeFavorite(userId, tvShowId);
      
      if (result) {
        res.status(200).json({ message: "Show removed from favorites" });
      } else {
        res.status(404).json({ message: "Show was not in favorites" });
      }
    } catch (error) {
      console.error("Error removing favorite:", error);
      res.status(500).json({ message: "Failed to remove favorite" });
    }
  });

  // Get user's favorites
  app.get("/api/favorites", async (req: Request, res: Response) => {
    // Check if user is authenticated
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "You must be logged in to view favorites" });
    }

    try {
      // Import favorites functions
      const { getUserFavorites } = await import("./database-favorites");
      
      const userId = req.user!.id;
      const favorites = await getUserFavorites(userId);
      
      res.json(favorites);
    } catch (error) {
      console.error("Error fetching favorites:", error);
      res.status(500).json({ message: "Failed to fetch favorites" });
    }
  });

  // Check if a show is in the user's favorites
  app.get("/api/favorites/:tvShowId", async (req: Request, res: Response) => {
    // Check if user is authenticated
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "You must be logged in to check favorites" });
    }

    try {
      const tvShowId = parseInt(req.params.tvShowId);
      if (isNaN(tvShowId)) {
        return res.status(400).json({ message: "Invalid show ID" });
      }

      // Import favorites functions
      const { isFavorite } = await import("./database-favorites");
      
      const userId = req.user!.id;
      const isFav = await isFavorite(userId, tvShowId);
      
      res.json({ isFavorite: isFav });
    } catch (error) {
      console.error("Error checking favorite status:", error);
      res.status(500).json({ message: "Failed to check favorite status" });
    }
  });

  // Get similar shows based on user's favorites
  app.get("/api/recommendations", async (req: Request, res: Response) => {
    // Check if user is authenticated
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "You must be logged in to get recommendations" });
    }

    try {
      const userId = req.user!.id;
      const limitStr = req.query.limit;
      const limit = limitStr && typeof limitStr === 'string' ? parseInt(limitStr) : 5;
      
      // Import favorites functions
      const { getSimilarShows } = await import("./database-favorites");
      
      const recommendations = await getSimilarShows(userId, limit);
      
      res.json(recommendations);
    } catch (error) {
      console.error("Error fetching recommendations:", error);
      res.status(500).json({ message: "Failed to fetch recommendations" });
    }
  });
  
  // Get similar shows for a specific show
  app.get("/api/shows/:id/similar", async (req: Request, res: Response) => {
    try {
      const id = parseInt(req.params.id);
      console.log(`Fetching similar shows for show ID: ${id}`);
      
      if (isNaN(id)) {
        console.log("Invalid show ID provided");
        return res.status(400).json({ message: "Invalid show ID" });
      }
      
      const limitStr = req.query.limit;
      const limit = limitStr && typeof limitStr === 'string' ? parseInt(limitStr) : 4;
      
      // Since we don't have a showId-based similar function, use the user-based one instead
      // Or get shows with similar themes/properties
      const show = await storage.getTvShowById(id);
      if (!show) {
        return res.status(404).json({ message: "Show not found" });
      }
      
      // Get all shows and filter them manually by similar properties
      const allShows = await storage.getAllTvShows();
      const similarShows = allShows
        .filter(s => s.id !== id) // Exclude current show
        .map(s => {
          // Calculate similarity score
          let score = 0;
          
          // Similar age range
          if (s.ageRange === show.ageRange) score += 3;
          
          // Similar stimulation score (within 10 points)
          if (Math.abs((s.stimulationScore || 0) - (show.stimulationScore || 0)) <= 10) score += 4;
          
          // Similar themes
          const showThemes = show.themes || [];
          const otherThemes = s.themes || [];
          const commonThemes = showThemes.filter(theme => otherThemes.includes(theme));
          score += commonThemes.length * 2;
          
          // Similar dialogue intensity
          if (s.dialogueIntensity === show.dialogueIntensity) score += 2;
          
          // Similar animation style
          if (s.animationStyle === show.animationStyle) score += 2;
          
          return { show: s, score };
        })
        .sort((a, b) => b.score - a.score) // Sort by highest score
        .slice(0, limit) // Get requested number
        .map(item => item.show); // Return just the shows
        
      console.log(`Found ${similarShows.length} similar shows for show ID ${id}`);
      
      // Log some sample data
      if (similarShows.length > 0) {
        console.log("First similar show:", {
          id: similarShows[0].id,
          name: similarShows[0].name
        });
      }
      
      res.json(similarShows);
    } catch (error) {
      console.error("Error fetching similar shows:", error);
      res.status(500).json({ message: "Failed to fetch similar shows" });
    }
  });

  // Check if a user is admin (for color palette access)
  app.get("/api/user/is-admin", async (req: Request, res: Response) => {
    // Check if user is authenticated
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "You must be logged in" });
    }

    try {
      res.json({ isAdmin: req.user!.isAdmin });
    } catch (error) {
      console.error("Error checking admin status:", error);
      res.status(500).json({ message: "Failed to check admin status" });
    }
  });
  
  // Check if username is available
  app.get("/api/check-username", async (req: Request, res: Response) => {
    try {
      const username = req.query.username as string;
      
      if (!username || username.length < 2) {
        return res.status(400).json({ available: false, message: "Username is too short" });
      }
      
      const existingUser = await storage.getUserByUsername(username);
      res.json({ available: !existingUser });
    } catch (error) {
      console.error("Error checking username:", error);
      res.status(500).json({ available: false, message: "Server error" });
    }
  });
  
  // Check if email is available
  app.get("/api/check-email", async (req: Request, res: Response) => {
    try {
      const email = req.query.email as string;
      
      if (!email || !email.includes('@')) {
        return res.status(400).json({ available: false, message: "Invalid email format" });
      }
      
      const existingUser = await storage.getUserByEmail(email);
      res.json({ available: !existingUser });
    } catch (error) {
      console.error("Error checking email:", error);
      res.status(500).json({ available: false, message: "Server error" });
    }
  });
  
  // Image upload endpoint for TV shows - used by both add and edit forms
  app.post("/api/shows/upload-image", upload.single('image'), uploadErrorHandler, async (req: Request, res: Response) => {
    // Check if user is authenticated and has admin privileges
    if (!req.isAuthenticated() || !req.user?.isAdmin) {
      return res.status(403).json({ message: "Unauthorized: Admin access required" });
    }
    
    try {
      if (!req.file) {
        return res.status(400).json({ message: "No image file provided" });
      }
      
      // Optimize the uploaded image
      const optimizedImagePath = await optimizeImage(req.file.path);
      
      // Return the path to the optimized image
      res.json({
        originalPath: `/uploads/${path.basename(req.file.path)}`,
        optimizedPath: optimizedImagePath,
        message: "Image uploaded and optimized successfully"
      });
    } catch (error) {
      console.error("Error processing image upload:", error);
      res.status(500).json({ 
        message: "Failed to process image upload", 
        error: error instanceof Error ? error.message : 'Unknown error' 
      });
    }
  });
  
  // Add a new TV show (admin only)
  app.post("/api/shows", async (req: Request, res: Response) => {
    // Check if user is authenticated and has admin privileges
    if (!req.isAuthenticated() || !req.user?.isAdmin) {
      return res.status(403).json({ message: "Unauthorized: Admin access required" });
    }
    
    try {
      // Validate that required fields are present
      const { name, description } = req.body;
      
      if (!name || !name.trim()) {
        return res.status(400).json({ message: "Show name is required" });
      }
      
      // Process themes if they're provided as an array
      if (req.body.themes && Array.isArray(req.body.themes)) {
        // Filter out any empty themes
        req.body.themes = req.body.themes.filter((theme: string) => theme.trim() !== '');
      }
      
      // Ensure stimulation score is a whole number if provided
      if (req.body.stimulationScore !== undefined) {
        req.body.stimulationScore = Math.round(Number(req.body.stimulationScore));
      }
      
      // Ensure all required fields have default values to avoid database constraint errors
      const currentYear = new Date().getFullYear();
      const showData = {
        ...req.body,
        // Set default values for any missing required fields
        episodeLength: req.body.episodeLength || 15,
        seasons: req.body.seasons || 1,
        releaseYear: req.body.releaseYear || currentYear,
        endYear: req.body.endYear || null,
        isOngoing: req.body.isOngoing !== undefined ? req.body.isOngoing : true,
        creator: req.body.creator || '',
        availableOn: Array.isArray(req.body.availableOn) ? req.body.availableOn : [],
        // Use stimulation score as the overall rating since they're the same
        overallRating: req.body.stimulationScore || 3 // Using stimulation score for overall rating
      };
      
      console.log("Adding show with data:", JSON.stringify({
        name: showData.name,
        episodeLength: showData.episodeLength,
        seasons: showData.seasons
      }, null, 2));
      
      // Add the show to the database
      const newShow = await storage.addTvShow(showData);
      
      // If an image URL was provided, add it to our custom image map
      if (showData.imageUrl) {
        imageManager.updateCustomImageMap(newShow.id, showData.imageUrl);
      }
      
      console.log(`Created new TV show: ${name} (ID: ${newShow.id})`);
      
      res.status(201).json(newShow);
    } catch (error) {
      console.error("Error adding new TV show:", error);
      res.status(500).json({ 
        message: "Failed to add new TV show", 
        error: error instanceof Error ? error.message : 'Unknown error' 
      });
    }
  });
  
  // Update a TV show (admin only)
  app.patch("/api/shows/:id", async (req: Request, res: Response) => {
    try {
      // Parse ID once
      const id = parseInt(req.params.id);
      
      // Check if user is authenticated and is an admin
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "You must be logged in" });
      }
      
      if (!req.user?.isAdmin) {
        return res.status(403).json({ message: "Not authorized to update shows" });
      }
      
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID" });
      }

      // Validate the show exists
      const existingShow = await storage.getTvShowById(id);
      if (!existingShow) {
        return res.status(404).json({ message: "Show not found" });
      }

      console.log(`Updating show #${id} with data:`, JSON.stringify(req.body, null, 2));

      // Update the show
      const updatedShow = await storage.updateTvShow(id, req.body);
      if (!updatedShow) {
        console.error(`Failed to update show #${id}`);
        return res.status(500).json({ message: "Failed to update show" });
      }

      console.log(`Show #${id} updated successfully:`, JSON.stringify(updatedShow, null, 2));
      res.json(updatedShow);
    } catch (error) {
      console.error("Error updating TV show:", error);
      res.status(500).json({ message: "Failed to update TV show" });
    }
  });

  // Toggle featured status for a TV show (admin only)
  app.patch("/api/shows/:id/featured", async (req: Request, res: Response) => {
    try {
      const id = parseInt(req.params.id);
      
      // Check if user is authenticated and is an admin
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "You must be logged in" });
      }
      
      if (!req.user?.isAdmin) {
        return res.status(403).json({ message: "Not authorized to update featured status" });
      }
      
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID" });
      }

      const { is_featured } = req.body;
      
      if (typeof is_featured !== 'boolean') {
        return res.status(400).json({ message: "is_featured must be a boolean" });
      }

      // If setting a show as featured, first unfeature all other shows
      if (is_featured) {
        await storage.unfeaturedAllShows();
      }

      // Update the show's featured status
      const updatedShow = await storage.updateTvShow(id, { isFeatured: is_featured });
      
      if (!updatedShow) {
        return res.status(404).json({ message: "Show not found" });
      }

      res.json(updatedShow);
    } catch (error) {
      console.error("Error updating featured status:", error);
      res.status(500).json({ message: "Failed to update featured status" });
    }
  });

  // Delete a TV show (admin only)
  app.delete("/api/shows/:id", async (req: Request, res: Response) => {
    try {
      // Parse ID once
      const id = parseInt(req.params.id);
      
      // Check if user is authenticated and is an admin
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "You must be logged in" });
      }
      
      if (!req.user?.isAdmin) {
        return res.status(403).json({ message: "Not authorized to delete shows" });
      }
      
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid ID" });
      }

      // Validate the show exists
      const existingShow = await storage.getTvShowById(id);
      if (!existingShow) {
        return res.status(404).json({ message: "Show not found" });
      }

      console.log(`Attempting to delete TV show: ${existingShow.name} (ID: ${id})`);
      
      // Delete the show from the database
      const deleteResult = await storage.deleteTvShow(id);
      
      if (!deleteResult) {
        console.error(`Failed to delete show with ID ${id}`);
        return res.status(500).json({ message: "Failed to delete TV show" });
      }
      
      console.log(`Successfully deleted TV show: ${existingShow.name} (ID: ${id})`);
      res.status(200).json({ message: "TV show deleted successfully" });
    } catch (error) {
      console.error("Error deleting TV show:", error);
      res.status(500).json({ message: "Failed to delete TV show" });
    }
  });
  
  // Admin-only API to delete a review
  app.delete("/api/admin/reviews/:id", async (req: Request, res: Response) => {
    try {
      // Check if user is authenticated and is an admin
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "You must be logged in" });
      }
      
      if (!req.user?.isAdmin) {
        return res.status(403).json({ message: "Admin access required" });
      }
      
      const reviewId = parseInt(req.params.id);
      if (isNaN(reviewId)) {
        return res.status(400).json({ message: "Invalid review ID" });
      }
      
      // Import admin functions
      const { deleteReview } = await import("./admin-functions");
      
      // Delete the review and handle points deduction
      const result = await deleteReview(reviewId);
      
      if (!result.success) {
        return res.status(404).json({ message: "Review not found or could not be deleted" });
      }
      
      res.status(200).json({ 
        message: "Review deleted successfully by admin",
        pointsDeducted: result.pointsDeducted
      });
    } catch (error) {
      console.error("Error deleting review:", error);
      res.status(500).json({ message: "Failed to delete review" });
    }
  });
  
  // Admin-only API to standardize all sensory metrics to approved scale
  app.post("/api/admin/standardize-metrics", async (req: Request, res: Response) => {
    try {
      // Check if user is authenticated and is an admin
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "You must be logged in" });
      }
      
      if (!req.user?.isAdmin) {
        return res.status(403).json({ message: "Admin access required" });
      }
      
      // Cast storage to DatabaseStorage to access the standardization method
      const dbStorage = storage as DatabaseStorage;
      if (typeof dbStorage.standardizeAllSensoryMetrics !== 'function') {
        return res.status(500).json({ 
          success: false, 
          error: 'Database storage required for this operation' 
        });
      }
      
      // Run the standardization
      const result = await dbStorage.standardizeAllSensoryMetrics();
      return res.json(result);
    } catch (error) {
      console.error('Error standardizing sensory metrics:', error);
      return res.status(500).json({ 
        success: false, 
        error: 'Failed to standardize metrics' 
      });
    }
  });
  
  // Admin-only API to optimize all custom images for SEO
  app.post("/api/admin/optimize-custom-images", async (req: Request, res: Response) => {
    try {
      // Check if user is authenticated and is an admin
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "You must be logged in" });
      }
      
      if (!req.user?.isAdmin) {
        return res.status(403).json({ message: "Not authorized to optimize images" });
      }
      
      // Get all shows with non-optimized images that need SEO optimization
      const shows = await storage.getAllTvShows();
      
      // Filter shows that need image optimization (non-OMDB images that aren't already optimized)
      const showsToOptimize = shows.filter(show => 
        show.imageUrl && 
        !show.imageUrl.includes('/uploads/optimized/') &&
        !show.imageUrl.includes('m.media-amazon.com') &&
        !show.imageUrl.includes('omdbapi.com')
      );
      
      console.log(`Found ${showsToOptimize.length} custom images to optimize`);
      
      // Import modules are already available at the top of file
      // We'll use the existing imports instead
      
      // Ensure temp directory exists
      const tempDir = './tmp_images';
      if (!fs.existsSync(tempDir)) {
        fs.mkdirSync(tempDir, { recursive: true });
      }
      
      // Prepare results
      const optimizationResults = [];
      let optimizedCount = 0;
      let errorCount = 0;
      let skippedCount = 0;
      
      // Process each image
      for (const show of showsToOptimize) {
        try {
          console.log(`Processing image for show ${show.id}: ${show.name}`);
          
          // Skip if URL is null or malformed
          if (!show.imageUrl) {
            console.log(`Skipping - null image URL for show ${show.id}`);
            skippedCount++;
            optimizationResults.push({
              id: show.id,
              name: show.name,
              status: "skipped",
              reason: "Null image URL"
            });
            continue;
          }
          
          // Download image if it's a remote URL
          let localImagePath = null;
          
          if (show.imageUrl.startsWith('http')) {
            try {
              // Download the image
              const response = await fetch(show.imageUrl);
              if (!response.ok) {
                throw new Error(`Failed to download image: ${response.status} ${response.statusText}`);
              }
              
              const buffer = await response.buffer();
              
              // Save image to temp location
              const timestamp = Date.now();
              const uniqueFilename = `show-${show.id}-${timestamp}.jpg`;
              localImagePath = path.join(tempDir, uniqueFilename);
              
              fs.writeFileSync(localImagePath, buffer);
              console.log(`Downloaded image to: ${localImagePath}`);
            } catch (error) {
              console.error(`Error downloading image for show ${show.id}:`, error);
              errorCount++;
              optimizationResults.push({
                id: show.id,
                name: show.name,
                status: "error",
                reason: `Download error: ${error instanceof Error ? error.message : "Unknown error"}`
              });
              continue;
            }
          } else if (show.imageUrl.startsWith('/')) {
            // For local images, check if they exist
            const possiblePaths = [
              path.join('public', show.imageUrl),
              path.join('public', 'uploads', path.basename(show.imageUrl)),
              path.join('public', 'custom-images', path.basename(show.imageUrl)),
              path.join('public', 'images', path.basename(show.imageUrl)),
              path.join('attached_assets', path.basename(show.imageUrl)),
              show.imageUrl.substring(1) // Try without leading slash
            ];
            
            for (const checkPath of possiblePaths) {
              if (fs.existsSync(checkPath)) {
                localImagePath = checkPath;
                console.log(`Found local image at ${localImagePath}`);
                break;
              }
            }
            
            if (!localImagePath) {
              console.log(`Could not find local image at any expected location: ${show.imageUrl}`);
              skippedCount++;
              optimizationResults.push({
                id: show.id,
                name: show.name,
                status: "skipped",
                reason: "Local image not found"
              });
              continue;
            }
          } else {
            console.log(`Unsupported image URL format: ${show.imageUrl}`);
            skippedCount++;
            optimizationResults.push({
              id: show.id,
              name: show.name,
              status: "skipped",
              reason: "Unsupported image URL format"
            });
            continue;
          }
          
          // Now optimize the image
          try {
            // Use our existing image optimization function
            const optimizedUrl = await optimizeImage(localImagePath);
            
            // Update the show in the database with the new optimized URL
            await storage.updateTvShow(show.id, {
              imageUrl: optimizedUrl
            });
            
            // Update custom image map too
            imageManager.updateCustomImageMap(show.id, optimizedUrl);
            
            console.log(`Optimized image for show ${show.id}: ${optimizedUrl}`);
            optimizedCount++;
            optimizationResults.push({
              id: show.id,
              name: show.name,
              status: "success",
              oldImageUrl: show.imageUrl,
              newImageUrl: optimizedUrl
            });
            
            // Clean up temp file if we downloaded it
            if (localImagePath.startsWith('./tmp_images')) {
              try {
                fs.unlinkSync(localImagePath);
              } catch (e) {
                // Ignore cleanup errors
              }
            }
          } catch (error) {
            console.error(`Error optimizing image for show ${show.id}:`, error);
            errorCount++;
            optimizationResults.push({
              id: show.id,
              name: show.name,
              status: "error",
              reason: `Optimization error: ${error instanceof Error ? error.message : "Unknown error"}`
            });
          }
        } catch (error) {
          console.error(`Error processing show ${show.id}:`, error);
          errorCount++;
          optimizationResults.push({
            id: show.id,
            name: show.name,
            status: "error",
            reason: `Processing error: ${error instanceof Error ? error.message : "Unknown error"}`
          });
        }
      }
      
      // Return results
      return res.json({
        message: "Custom image optimization complete",
        total: showsToOptimize.length,
        optimized: optimizedCount,
        skipped: skippedCount,
        errors: errorCount,
        results: optimizationResults
      });
    } catch (error) {
      console.error('Error in optimize-custom-images:', error);
      return res.status(500).json({ 
        message: "Error during custom image optimization", 
        error: error instanceof Error ? error.message : "Unknown error" 
      });
    }
  });

  // -------------------------------------------------------------------------
  // Gamification API Routes
  // -------------------------------------------------------------------------
  
  // Get user points
  app.get("/api/user/points", async (req: Request, res: Response) => {
    try {
      const userId = req.session?.userId;
      if (!userId) {
        return res.status(401).json({ message: "You must be logged in to view your points" });
      }
      
      const points = await storage.getUserPoints(userId);
      res.json(points);
    } catch (error) {
      console.error('Error getting user points:', error);
      res.status(500).json({ 
        message: "Error retrieving user points", 
        error: error instanceof Error ? error.message : "Unknown error" 
      });
    }
  });
  
  // Get user points history
  app.get("/api/user/points/history", async (req: Request, res: Response) => {
    try {
      const userId = req.session?.userId;
      if (!userId) {
        return res.status(401).json({ message: "You must be logged in to view your points history" });
      }
      
      const history = await storage.getUserPointsHistory(userId);
      res.json(history);
    } catch (error) {
      console.error('Error getting user points history:', error);
      res.status(500).json({ 
        message: "Error retrieving points history", 
        error: error instanceof Error ? error.message : "Unknown error" 
      });
    }
  });
  
  // Get leaderboard
  app.get("/api/leaderboard", async (req: Request, res: Response) => {
    try {
      const limit = req.query.limit ? parseInt(req.query.limit as string) : 10;
      const leaderboard = await storage.getTopUsers(limit);
      res.json(leaderboard);
    } catch (error) {
      console.error('Error getting leaderboard:', error);
      res.status(500).json({ 
        message: "Error retrieving leaderboard", 
        error: error instanceof Error ? error.message : "Unknown error" 
      });
    }
  });
  
  // Upvote a review (awards points to the review author)
  app.post("/api/reviews/:reviewId/upvote", async (req: Request, res: Response) => {
    try {
      const { reviewId } = req.params;
      
      if (!req.isAuthenticated() || !req.user) {
        return res.status(401).json({ message: "You must be logged in to upvote reviews" });
      }
      
      // Get user ID from authenticated user
      const userId = req.user.id;
      console.log(`Upvote attempt by user ${userId} for review ${reviewId}`);
      
      // Convert userId to integer since database expects integer for userId column
      const parsedUserId = parseInt(userId);
      
      // Add upvote and award points to the review author
      const upvote = await storage.addReviewUpvote(parsedUserId, parseInt(reviewId));
      
      res.json({ success: true, upvote });
    } catch (error) {
      console.error('Error upvoting review:', error);
      res.status(500).json({ 
        message: "Error upvoting review", 
        error: error instanceof Error ? error.message : "Unknown error" 
      });
    }
  });
  
  // Remove upvote from a review
  app.delete("/api/reviews/:reviewId/upvote", async (req: Request, res: Response) => {
    try {
      const { reviewId } = req.params;
      
      if (!req.isAuthenticated() || !req.user) {
        return res.status(401).json({ message: "You must be logged in to remove upvotes" });
      }
      
      // Get user ID from authenticated user
      const userId = req.user.id;
      console.log(`Remove upvote attempt by user ${userId} for review ${reviewId}`);
      
      // Convert userId to integer since database expects integer for userId column
      const parsedUserId = parseInt(userId);
      
      const removed = await storage.removeReviewUpvote(parsedUserId, parseInt(reviewId));
      res.json({ success: removed });
    } catch (error) {
      console.error('Error removing upvote:', error);
      res.status(500).json({ 
        message: "Error removing upvote", 
        error: error instanceof Error ? error.message : "Unknown error" 
      });
    }
  });
  
  // Get upvotes for a review
  app.get("/api/reviews/:reviewId/upvotes", async (req: Request, res: Response) => {
    try {
      const { reviewId } = req.params;
      const upvotes = await storage.getReviewUpvotes(parseInt(reviewId));
      res.json(upvotes);
    } catch (error) {
      console.error('Error getting review upvotes:', error);
      res.status(500).json({ 
        message: "Error retrieving review upvotes", 
        error: error instanceof Error ? error.message : "Unknown error" 
      });
    }
  });
  
  // Removed duplicate dashboard endpoint
  
  // User Profile endpoint
  app.get("/api/user/profile/:userId", async (req: Request, res: Response) => {
    try {
      const { userId } = req.params;
      const parsedUserId = parseInt(userId);
      
      if (isNaN(parsedUserId)) {
        return res.status(400).json({ message: "Invalid user ID" });
      }
      
      // Use optimized method that gets all data in fewer queries
      let profileData;
      if (typeof storage.getUserProfileWithMetadata === 'function') {
        profileData = await storage.getUserProfileWithMetadata(parsedUserId);
      } else {
        // Fallback to individual queries
        const user = await storage.getUser(parsedUserId);
        if (!user) {
          return res.status(404).json({ message: "User not found" });
        }
        
        const points = await storage.getUserPoints(parsedUserId);
        const pointsHistory = await storage.getUserPointsHistory(parsedUserId);
        const reviews = await storage.getUserReviews(parsedUserId);
        const favorites = await storage.getUserFavorites(parsedUserId);
        
        profileData = {
          user: {
            id: user.id,
            username: user.username,
            backgroundColor: user.backgroundColor || '#6366f1',
            joinedAt: user.createdAt
          },
          points,
          pointsHistory,
          reviews: reviews || [],
          favorites: favorites || []
        };
      }
      
      if (!profileData) {
        return res.status(404).json({ message: "User not found" });
      }
      
      res.json(profileData);
    } catch (error) {
      console.error("Error fetching user profile:", error);
      res.status(500).json({ message: "Failed to fetch user profile" });
    }
  });

  // User Points
  app.get("/api/user/points", async (req: Request, res: Response) => {
    try {
      const userId = req.session?.userId;
      if (!userId) {
        return res.status(401).json({ message: "You must be logged in to view points" });
      }
      
      // Convert userId to integer since database expects integer
      const parsedUserId = parseInt(userId);
      
      const points = await storage.getUserPoints(parsedUserId);
      res.json({ points });
    } catch (error) {
      console.error("Error fetching user points:", error);
      res.status(500).json({ message: "Failed to fetch user points" });
    }
  });
  
  app.get("/api/user/points/history", async (req: Request, res: Response) => {
    try {
      const userId = req.session?.userId;
      if (!userId) {
        return res.status(401).json({ message: "You must be logged in to view points history" });
      }
      
      // Convert userId to integer since database expects integer
      const parsedUserId = parseInt(userId);
      
      const history = await storage.getUserPointsHistory(parsedUserId);
      res.json(history);
    } catch (error) {
      console.error("Error fetching points history:", error);
      res.status(500).json({ message: "Failed to fetch points history" });
    }
  });
  
  // Review Upvotes
  app.post("/api/reviews/:reviewId/upvote", async (req: Request, res: Response) => {
    try {
      const userId = req.session?.userId;
      if (!userId) {
        return res.status(401).json({ message: "You must be logged in to upvote reviews" });
      }
      
      // Convert userId to integer for database operations
      const parsedUserId = parseInt(userId);
      
      const reviewId = parseInt(req.params.reviewId);
      
      if (isNaN(reviewId)) {
        return res.status(400).json({ message: "Invalid review ID" });
      }
      
      const upvote = await storage.addReviewUpvote(parsedUserId, reviewId);
      res.json(upvote);
    } catch (error) {
      console.error("Error upvoting review:", error);
      res.status(500).json({ message: "Failed to upvote review" });
    }
  });
  
  app.delete("/api/reviews/:reviewId/upvote", async (req: Request, res: Response) => {
    try {
      const userId = req.session?.userId;
      if (!userId) {
        return res.status(401).json({ message: "You must be logged in to remove upvotes" });
      }
      
      // Convert userId to integer for database operations
      const parsedUserId = parseInt(userId);
      
      const reviewId = parseInt(req.params.reviewId);
      
      if (isNaN(reviewId)) {
        return res.status(400).json({ message: "Invalid review ID" });
      }
      
      await storage.removeReviewUpvote(parsedUserId, reviewId);
      res.json({ success: true });
    } catch (error) {
      console.error("Error removing upvote:", error);
      res.status(500).json({ message: "Failed to remove upvote" });
    }
  });
  
  // Update user background color
  app.put("/api/user/background-color", async (req: Request, res: Response) => {
    try {
      const userId = req.session?.passport?.user;
      if (!userId) {
        return res.status(401).json({ message: "You must be logged in to update background color" });
      }
      
      const { backgroundColor } = req.body;
      if (!backgroundColor) {
        return res.status(400).json({ message: "Background color is required" });
      }
      
      // Convert userId to integer for database operations
      const parsedUserId = parseInt(userId);
      
      // Update user's background color in database
      const updatedUser = await db
        .update(users)
        .set({ backgroundColor })
        .where(eq(users.id, parsedUserId))
        .returning();
      
      if (updatedUser.length === 0) {
        return res.status(404).json({ message: "User not found" });
      }
      
      res.json({ 
        success: true, 
        backgroundColor,
        message: "Background color updated successfully" 
      });
    } catch (error) {
      console.error("Error updating background color:", error);
      res.status(500).json({ message: "Failed to update background color" });
    }
  });

  app.get("/api/reviews/:reviewId/upvotes", async (req: Request, res: Response) => {
    try {
      const reviewId = parseInt(req.params.reviewId);
      
      if (isNaN(reviewId)) {
        return res.status(400).json({ message: "Invalid review ID" });
      }
      
      const upvotes = await storage.getReviewUpvotes(reviewId);
      res.json(upvotes);
    } catch (error) {
      console.error("Error fetching upvotes:", error);
      res.status(500).json({ message: "Failed to fetch upvotes" });
    }
  });
  
  // Research Summaries
  app.get("/api/research", async (req: Request, res: Response) => {
    try {
      const summaries = await storage.getResearchSummaries();
      
      // Check if user is logged in to determine read status
      if (req.isAuthenticated()) {
        const userId = req.user!.id;
        const userReadIds = (await storage.getUserReadResearch(userId.toString())).map(r => r.id);
        const summariesWithReadStatus = summaries.map(summary => ({
          ...summary,
          hasRead: userReadIds.includes(summary.id)
        }));
        res.json(summariesWithReadStatus);
      } else {
        res.json(summaries.map(summary => ({
          ...summary,
          hasRead: false
        })));
      }
    } catch (error) {
      console.error("Error fetching research summaries:", error);
      res.status(500).json({ message: "Failed to fetch research summaries" });
    }
  });
  
  app.get("/api/research/:id", async (req: Request, res: Response) => {
    try {
      const id = parseInt(req.params.id);
      
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid research ID" });
      }
      
      const summary = await storage.getResearchSummary(id);
      
      if (!summary) {
        return res.status(404).json({ message: "Research summary not found" });
      }
      
      // Check if user has read this research
      if (req.isAuthenticated()) {
        const userId = req.user!.id;
        const hasRead = await storage.hasUserReadResearch(userId.toString(), id);
        res.json({
          ...summary,
          hasRead
        });
      } else {
        res.json({
          ...summary,
          hasRead: false
        });
      }
    } catch (error) {
      console.error("Error fetching research summary:", error);
      res.status(500).json({ message: "Failed to fetch research summary" });
    }
  });
  
  app.post("/api/research/:id/mark-read", async (req: Request, res: Response) => {
    try {
      // Check if user is authenticated using the same method as other endpoints
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "You must be logged in to mark research as read" });
      }
      
      const userId = req.user!.id;
      
      const researchId = parseInt(req.params.id);
      
      if (isNaN(researchId)) {
        return res.status(400).json({ message: "Invalid research ID" });
      }
      
      const readRecord = await storage.markResearchAsRead(userId, researchId);
      res.json(readRecord);
    } catch (error) {
      console.error("Error marking research as read:", error);
      res.status(500).json({ message: "Failed to mark research as read" });
    }
  });
  
  // Admin only - add research summary
  app.post("/api/research", async (req: Request, res: Response) => {
    try {
      const userId = req.session?.userId;
      if (!userId) {
        return res.status(401).json({ message: "You must be logged in to add research summaries" });
      }
      
      const user = await storage.getUser(userId);
      
      if (!user?.isAdmin) {
        return res.status(403).json({ message: "Only administrators can add research summaries" });
      }
      
      const summary = await storage.addResearchSummary(req.body);
      res.json(summary);
    } catch (error) {
      console.error("Error adding research summary:", error);
      res.status(500).json({ message: "Failed to add research summary" });
    }
  });
  
  // Show Submissions
  app.post("/api/show-submissions", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "You must be logged in to submit shows" });
      }
      
      const userId = req.user!.id;
      
      const submission = await storage.addShowSubmission({
        ...req.body,
        userId
      });
      res.json(submission);
    } catch (error) {
      console.error("Error submitting show:", error);
      res.status(500).json({ message: "Failed to submit show" });
    }
  });
  
  // Get user's own submissions
  app.get("/api/show-submissions/my", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "You must be logged in to view submissions" });
      }
      
      const userId = req.user!.id.toString();
      const submissions = await storage.getUserShowSubmissions(userId);
      res.json(submissions);
    } catch (error) {
      console.error("Error fetching user show submissions:", error);
      res.status(500).json({ message: "Failed to fetch show submissions" });
    }
  });

  // Admin endpoint for pending submissions
  app.get("/api/show-submissions/pending", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "You must be logged in to view submissions" });
      }
      
      const user = req.user!;
      
      if (!user.isAdmin) {
        return res.status(403).json({ message: "Only administrators can view pending submissions" });
      }
      
      const submissions = await storage.getConsolidatedShowSubmissions();
      res.json(submissions);
    } catch (error) {
      console.error("Error fetching pending show submissions:", error);
      res.status(500).json({ message: "Failed to fetch pending submissions" });
    }
  });

  // Complete registration endpoint
  app.post("/api/complete-registration", async (req: Request, res: Response) => {
    try {
      const { email, username, password, country } = req.body;
      
      if (!email || !username || !password || !country) {
        return res.status(400).json({ error: "Email, username, password, and country are required" });
      }

      // Check if user already exists
      const existingUser = await storage.getUserByEmail(email);
      if (existingUser) {
        return res.status(400).json({ error: "User with this email already exists" });
      }

      // Check if username is taken
      const existingUsername = await storage.getUserByUsername(username);
      if (existingUsername) {
        return res.status(400).json({ error: "Username is already taken" });
      }

      // Find the temp GHL user record using direct SQL
      const tempUserResult = await db.execute(
        sql`SELECT id, email, first_name, country, referrer_id, referred_show_id FROM temp_ghl_users WHERE email = ${email} LIMIT 1`
      );

      if (tempUserResult.rows.length === 0) {
        return res.status(400).json({ error: "No registration record found for this email" });
      }

      const tempUser = tempUserResult.rows[0];

      // Create the actual user account with bcrypt hashing
      const hashedPassword = await bcrypt.hash(password, 10);
      
      const newUser = await storage.createUser({
        email,
        username,
        password: hashedPassword,
        firstName: tempUser.first_name,
        country: country, // Use country from request body
        isApproved: true, // Auto-approve GHL users
      });

      // Mark the temp user as having completed registration
      await db.execute(
        sql`UPDATE temp_ghl_users SET registration_completed_at = NOW() WHERE id = ${tempUser.id}`
      );

      res.status(201).json({ 
        message: "Registration completed successfully",
        userId: newUser.id 
      });

    } catch (error) {
      console.error("Error completing registration:", error);
      res.status(500).json({ error: "Failed to complete registration" });
    }
  });

  // Change password endpoint
  app.post("/api/change-password", async (req: Request, res: Response) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ error: "Not authenticated" });
    }

    try {
      const { currentPassword, newPassword } = req.body;

      if (!currentPassword || !newPassword) {
        return res.status(400).json({ error: "Current password and new password are required" });
      }

      if (newPassword.length < 6) {
        return res.status(400).json({ error: "New password must be at least 6 characters long" });
      }

      // Get current user from database
      const currentUser = await storage.getUserByUsername(req.user.username);
      if (!currentUser) {
        return res.status(404).json({ error: "User not found" });
      }

      // Verify current password using the same method as login
      const isCurrentPasswordValid = await comparePasswords(currentPassword, currentUser.password);
      if (!isCurrentPasswordValid) {
        return res.status(400).json({ error: "Current password is incorrect" });
      }

      // Hash new password
      const hashedNewPassword = await bcrypt.hash(newPassword, 10);

      // Update password in database
      await storage.updateUserPassword(currentUser.id, hashedNewPassword);

      res.json({ message: "Password changed successfully" });
    } catch (error) {
      console.error("Change password error:", error);
      res.status(500).json({ error: "Failed to change password" });
    }
  });

  // Admin password reset endpoint
  app.post("/api/admin/reset-password", async (req: Request, res: Response) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ error: "Not authenticated" });
    }

    // Check if user is admin
    const currentUser = await storage.getUserByUsername(req.user.username);
    if (!currentUser || !currentUser.isAdmin) {
      return res.status(403).json({ error: "Admin access required" });
    }

    try {
      const { userId } = req.body;

      if (!userId) {
        return res.status(400).json({ error: "User ID is required" });
      }

      // Generate a secure temporary password (12 characters, mix of letters, numbers, symbols)
      const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnpqrstuvwxyz23456789!@#$%&*';
      let tempPassword = '';
      for (let i = 0; i < 12; i++) {
        tempPassword += chars.charAt(Math.floor(Math.random() * chars.length));
      }

      // Hash the temporary password
      const hashedTempPassword = await bcrypt.hash(tempPassword, 10);

      // Update password in database
      const success = await storage.updateUserPassword(userId, hashedTempPassword);
      
      if (!success) {
        return res.status(500).json({ error: "Failed to update password" });
      }

      // Log the admin action for security auditing
      console.log(`Admin ${currentUser.username} (ID: ${currentUser.id}) reset password for user ID: ${userId} at ${new Date().toISOString()}`);

      res.json({ 
        message: "Password reset successfully",
        temporaryPassword: tempPassword 
      });
    } catch (error) {
      console.error("Error resetting password:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });

  // Test endpoint to verify webhook is reachable
  app.get("/api/webhook-test", (req: Request, res: Response) => {
    res.json({ 
      message: 'Webhook endpoint is reachable',
      timestamp: new Date().toISOString(),
      url: req.url 
    });
  });

  // Single dedicated GHL webhook endpoint
  app.post("/api/ghl-webhook", async (req: Request, res: Response) => {
    try {
      console.log('=== GHL WEBHOOK RECEIVED ===');
      console.log('Timestamp:', new Date().toISOString());
      console.log('Method:', req.method);
      console.log('Headers:', JSON.stringify(req.headers, null, 2));
      console.log('Body:', JSON.stringify(req.body, null, 2));
      console.log('================================');
      
      const formData = req.body;
      
      // Extract email and first name from GHL webhook payload
      const email = formData.email || formData.customData?.email || formData.contact?.email || formData.contact?.emailAddress;
      const firstName = formData.first_name || formData.customData?.first_name || formData.contact?.firstName || formData.contact?.first_name;
      const contactId = formData.contact_id || formData.contact?.id || formData.contactId;
      
      console.log('Extracted data:', { email, firstName, contactId });
      console.log('Available form fields:', Object.keys(formData));

      if (!email) {
        console.error('No email found in webhook payload');
        return res.status(200).json({ 
          message: 'Webhook received but processing failed',
          error: 'Email is required' 
        });
      }
      
      // Database insertion with error handling
      try {
        // Check if user already exists
        const existingCheck = await db.execute(
          sql`SELECT id FROM temp_ghl_users WHERE email = ${email} LIMIT 1`
        );
        
        if (existingCheck.rows.length > 0) {
          console.log('User already exists:', email);
          return res.status(200).json({ 
            message: 'User already exists',
            userId: existingCheck.rows[0].id 
          });
        }
        
        // Insert new user
        const insertResult = await db.execute(
          sql`INSERT INTO temp_ghl_users (email, first_name, contact_id, created_at, updated_at) 
              VALUES (${email}, ${firstName || null}, ${contactId || null}, NOW(), NOW()) 
              RETURNING id`
        );
        
        const newUser = insertResult.rows[0];
        console.log('Successfully inserted new user:', newUser);
        
        // Process any pending referral data
        await processPendingReferral(email, newUser.id);
        
        res.status(200).json({ 
          message: 'Webhook processed successfully',
          userId: newUser.id 
        });
        
      } catch (dbError: any) {
        console.error('Database error:', dbError.message);
        console.error('Full error:', dbError);
        
        // Return success to GHL to prevent retries
        res.status(200).json({ 
          message: 'Webhook received but processing failed',
          error: dbError.message 
        });
      }
      
    } catch (error: any) {
      console.error('Webhook processing error:', error);
      res.status(200).json({ 
        message: 'Webhook received but processing failed',
        error: error.message 
      });
    }
  });

  // Store pending referral data when someone visits a shared link
  app.post("/api/store-referral", async (req: Request, res: Response) => {
    try {
      const { email, referrerId, referredShowId } = req.body;
      
      if (!email || !referrerId || !referredShowId) {
        return res.status(400).json({ error: 'Missing required referral data' });
      }
      
      // Store or update pending referral
      await db.execute(
        sql`INSERT INTO pending_referrals (email, referrer_id, referred_show_id, created_at) 
            VALUES (${email}, ${parseInt(referrerId)}, ${parseInt(referredShowId)}, NOW())
            ON CONFLICT (email) DO UPDATE SET 
            referrer_id = ${parseInt(referrerId)},
            referred_show_id = ${parseInt(referredShowId)},
            created_at = NOW()`
      );
      
      console.log('Stored pending referral:', { email, referrerId, referredShowId });
      res.json({ success: true });
      
    } catch (error) {
      console.error('Error storing pending referral:', error);
      res.status(500).json({ error: 'Failed to store referral data' });
    }
  });

  // Process pending referral when user completes registration
  async function processPendingReferral(email: string, ghlUserId: any) {
    try {
      // Look for pending referral data
      const pendingReferral = await db.execute(
        sql`SELECT referrer_id, referred_show_id FROM pending_referrals WHERE email = ${email} LIMIT 1`
      );
      
      if (pendingReferral.rows.length > 0) {
        const { referrer_id, referred_show_id } = pendingReferral.rows[0];
        
        console.log('Found pending referral for', email, ':', { referrer_id, referred_show_id });
        
        // Update the GHL user record with referral data
        await db.execute(
          sql`UPDATE temp_ghl_users 
              SET referrer_id = ${referrer_id}, referred_show_id = ${referred_show_id}, updated_at = NOW()
              WHERE id = ${ghlUserId}`
        );
        
        // Process the referral if both users exist in main users table
        const [referrer] = await db.select().from(users).where(eq(users.id, parseInt(referrer_id))).limit(1);
        const [referred] = await db.select().from(users).where(eq(users.email, email)).limit(1);
        
        if (referrer && referred) {
          console.log('Both users found, processing referral:', { referrerId: referrer.id, referredId: referred.id });
          await trackReferral(referrer.id.toString(), referred.id.toString());
        } else {
          console.log('Users not yet in main table, referral will be processed when registration completes');
        }
        
        // Clean up pending referral
        await db.execute(
          sql`DELETE FROM pending_referrals WHERE email = ${email}`
        );
        
        console.log('Successfully processed pending referral for', email);
      } else {
        console.log('No pending referral found for', email);
      }
    } catch (error) {
      console.error('Error processing pending referral:', error);
    }
  }

  // Get GHL registrations for admin dashboard
  app.get("/api/admin/ghl-funnel", async (req: Request, res: Response) => {
    try {
      console.log('GHL funnel request - session data:', {
        hasSession: !!req.session,
        userId: req.session?.userId,
        sessionData: req.session
      });

      if (!req.session?.userId) {
        return res.status(401).json({ message: "Authentication required" });
      }

      // Check if user is admin - convert string ID to number for database query
      const userId = parseInt(req.session.userId);
      console.log('Looking up user with ID:', userId);
      
      const [user] = await db
        .select()
        .from(users)
        .where(eq(users.id, userId))
        .limit(1);

      console.log('User lookup result:', user);

      if (!user?.isAdmin) {
        return res.status(403).json({ message: "Admin access required" });
      }

      // Get all GHL registrations
      const registrations = await db
        .select()
        .from(tempGhlUsers)
        .orderBy(desc(tempGhlUsers.createdAt));

      // Calculate summary statistics
      const total = registrations.length;
      const verified = registrations.filter(r => r.isVerified).length;
      const completed = registrations.filter(r => r.hasCompletedRegistration).length;
      const pending = total - completed;

      const summary = {
        total,
        verified,
        completed,
        pending,
        conversionRate: total > 0 ? ((completed / total) * 100).toFixed(1) : '0'
      };

      res.json({ registrations, summary });
      
    } catch (error) {
      console.error('Error fetching GHL registrations:', error);
      res.status(500).json({ message: "Failed to fetch GHL registrations" });
    }
  });

  // URL Shortener endpoints

  // Create a short URL for sharing
  app.post("/api/short-url", async (req: Request, res: Response) => {
    try {
      const { showId, originalUrl } = req.body;
      
      if (!showId) {
        return res.status(400).json({ message: "Show ID is required" });
      }

      const userId = req.isAuthenticated() ? req.user!.id : undefined;
      const result = await createShortUrl(parseInt(showId), userId, originalUrl);
      
      if (!result) {
        return res.status(500).json({ message: "Failed to create short URL" });
      }

      res.json(result);
    } catch (error) {
      console.error("Error creating short URL:", error);
      res.status(500).json({ message: "Failed to create short URL" });
    }
  });

  // Resolve short URL (redirect)
  app.get("/s/:shortCode", async (req: Request, res: Response) => {
    try {
      const { shortCode } = req.params;
      const originalUrl = await resolveShortUrl(shortCode);
      
      if (!originalUrl) {
        return res.status(404).json({ message: "Short URL not found" });
      }

      // Redirect to the original URL
      res.redirect(302, originalUrl);
    } catch (error) {
      console.error("Error resolving short URL:", error);
      res.status(500).json({ message: "Failed to resolve short URL" });
    }
  });

  // Track referral click and award points
  app.post("/api/referral/click", async (req: Request, res: Response) => {
    try {
      const { referrerId, showId } = req.body;
      
      if (!referrerId || !showId) {
        return res.status(400).json({ message: "Referrer ID and Show ID are required" });
      }

      // Get client IP address
      const clientIp = req.ip || req.connection.remoteAddress || 'unknown';
      const userAgent = req.get('User-Agent');
      
      const result = await trackReferralClick(
        parseInt(referrerId), 
        parseInt(showId), 
        clientIp, 
        userAgent
      );
      
      res.json(result);
    } catch (error) {
      console.error("Error tracking referral click:", error);
      res.status(500).json({ message: "Failed to track referral click" });
    }
  });

  app.get("/api/show-submissions", async (req: Request, res: Response) => {
    try {
      if (!req.isAuthenticated()) {
        return res.status(401).json({ message: "You must be logged in to view submissions" });
      }
      
      const user = req.user!;
      
      // Admin can see consolidated submissions view
      if (user.isAdmin) {
        const submissions = await storage.getConsolidatedShowSubmissions();
        res.json(submissions);
      } else {
        // Regular users only see their own submissions
        const submissions = await storage.getUserShowSubmissions(user.id.toString());
        res.json(submissions);
      }
    } catch (error) {
      console.error("Error fetching show submissions:", error);
      res.status(500).json({ message: "Failed to fetch show submissions" });
    }
  });
  
  // Admin only - update submission status
  app.put("/api/show-submissions/:id/status", async (req: Request, res: Response) => {
    try {
      const userId = req.session?.userId;
      if (!userId) {
        return res.status(401).json({ message: "You must be logged in to update submission status" });
      }
      
      const user = await storage.getUser(userId);
      
      if (!user?.isAdmin) {
        return res.status(403).json({ message: "Only administrators can update submission status" });
      }
      
      const id = parseInt(req.params.id);
      const { status } = req.body;
      
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid submission ID" });
      }
      
      if (!["pending", "approved", "rejected"].includes(status)) {
        return res.status(400).json({ message: "Invalid status. Must be 'pending', 'approved', or 'rejected'" });
      }
      
      const submission = await storage.updateShowSubmissionStatus(id, status);
      res.json(submission);
    } catch (error) {
      console.error("Error updating submission status:", error);
      res.status(500).json({ message: "Failed to update submission status" });
    }
  });
  
  // User Leaderboard
  app.get("/api/leaderboard", async (req: Request, res: Response) => {
    try {
      const limit = req.query.limit ? parseInt(req.query.limit as string) : 10;
      const topUsers = await storage.getTopUsers(limit);
      
      // Return only necessary user info (username, points)
      const leaderboard = topUsers.map(user => ({
        id: user.id,
        username: user.username,
        totalPoints: user.totalPoints || 0
      }));
      
      res.json(leaderboard);
    } catch (error) {
      console.error("Error fetching leaderboard:", error);
      res.status(500).json({ message: "Failed to fetch leaderboard" });
    }
  });

  // Reject show submission endpoint
  app.post("/api/show-submissions/reject", async (req: Request, res: Response) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ error: "Not authenticated" });
    }

    // Check if user is admin
    const currentUser = await storage.getUserByUsername(req.user.username);
    if (!currentUser || !currentUser.isAdmin) {
      return res.status(403).json({ error: "Admin access required" });
    }

    try {
      const { normalizedName, rejectionReason } = req.body;

      if (!normalizedName) {
        return res.status(400).json({ error: "Normalized name is required" });
      }

      // Get all users who submitted this show request
      const submissionUsers = await storage.getUsersWhoSubmittedShow(normalizedName);
      
      // Create rejection notifications for all users who requested this show
      const notificationPromises = submissionUsers.map(async (userId: string) => {
        return storage.createNotification({
          userId: userId,
          type: 'show_rejection',
          message: `Your show request has been reviewed and declined${rejectionReason ? `: ${rejectionReason}` : '.'}`,
          isRead: false,
          relatedShowName: normalizedName
        });
      });

      // Wait for all notifications to be created
      await Promise.all(notificationPromises);

      // Remove the submission from pending list
      await storage.rejectShowSubmission(normalizedName);

      console.log(`Admin ${currentUser.username} rejected submission: ${normalizedName}. Notified ${submissionUsers.length} users.`);

      res.json({ 
        message: "Show submission rejected successfully",
        notifiedUsers: submissionUsers.length
      });
    } catch (error) {
      console.error("Error rejecting submission:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });

  // Get all themes for the theme selector
  app.get("/api/themes", async (req: Request, res: Response) => {
    try {
      const themes = await storage.getAllThemes();
      res.json(themes);
    } catch (error) {
      console.error("Error fetching themes:", error);
      res.status(500).json({ message: "Failed to fetch themes" });
    }
  });

  const httpServer = createServer(app);

  return httpServer;
}
</file>

</files>
